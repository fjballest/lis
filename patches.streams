diff -p --unified --exclude-from=exclude --new-file --recursive debug/Makefile /usr/src/linux/Makefile
--- debug/Makefile	Wed Dec 11 08:37:40 1996
+++ /usr/src/linux/Makefile	Wed Dec 18 12:16:56 1996
@@ -88,6 +88,7 @@ SVGA_MODE=	-DSVGA_MODE=NORMAL_VGA
 #
 
 CFLAGS = -Wall -Wstrict-prototypes -g -O2 -fomit-frame-pointer -fno-strength-reduce
+CFLAGS += -DDMG_SEM
 
 ifdef CONFIG_CPP
 CFLAGS := $(CFLAGS) -x c++
@@ -116,7 +117,8 @@ endif
 ARCHIVES	=kernel/kernel.o mm/mm.o fs/fs.o ipc/ipc.o net/network.a
 FILESYSTEMS	=fs/filesystems.a
 DRIVERS		=drivers/block/block.a \
-		 drivers/char/char.a
+		 drivers/char/char.a \
+		 drivers/streams/streams.a
 LIBS		=$(TOPDIR)/lib/lib.a
 SUBDIRS		=kernel drivers mm fs net ipc lib
 
Binary files debug/arch/i386/boot/bbootsect and /usr/src/linux/arch/i386/boot/bbootsect differ
Binary files debug/arch/i386/boot/bzImage and /usr/src/linux/arch/i386/boot/bzImage differ
Binary files debug/arch/i386/boot/compressed/bvmlinux and /usr/src/linux/arch/i386/boot/compressed/bvmlinux differ
Binary files debug/arch/i386/boot/compressed/bvmlinux.out and /usr/src/linux/arch/i386/boot/compressed/bvmlinux.out differ
Binary files debug/arch/i386/boot/tools/bbuild and /usr/src/linux/arch/i386/boot/tools/bbuild differ
diff -p --unified --exclude-from=exclude --new-file --recursive debug/arch/i386/kernel/entry.S /usr/src/linux/arch/i386/kernel/entry.S
--- debug/arch/i386/kernel/entry.S	Mon Dec  2 16:38:21 1996
+++ /usr/src/linux/arch/i386/kernel/entry.S	Mon Dec 16 16:36:35 1996
@@ -669,4 +669,7 @@ ENTRY(sys_call_table)
 	.long SYMBOL_NAME(sys_sched_rr_get_interval)
 	.long SYMBOL_NAME(sys_nanosleep)
 	.long SYMBOL_NAME(sys_mremap)
-	.space (NR_syscalls-163)*4
+	.long SYMBOL_NAME(sys_putpmsg)
+	.long SYMBOL_NAME(sys_getpmsg)		/* 165 */
+	.long SYMBOL_NAME(sys_poll)
+	.space (NR_syscalls-166)*4
diff -p --unified --exclude-from=exclude --new-file --recursive debug/arch/i386/lib/semaphore.S /usr/src/linux/arch/i386/lib/semaphore.S
--- debug/arch/i386/lib/semaphore.S	Mon Dec  2 16:38:21 1996
+++ /usr/src/linux/arch/i386/lib/semaphore.S	Wed Dec 18 14:35:13 1996
@@ -25,3 +25,11 @@ ENTRY(up_wakeup)
 	call SYMBOL_NAME(__up)
 	popl %ecx
 	ret
+
+ENTRY(down_failed_interruptible)
+	pushl %eax
+	pushl %ecx
+	call SYMBOL_NAME(__down_interruptible)
+	popl %ecx
+	ret
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/Makefile /usr/src/linux/drivers/Makefile
--- debug/drivers/Makefile	Mon Dec  2 16:38:05 1996
+++ /usr/src/linux/drivers/Makefile	Mon Dec 16 16:36:35 1996
@@ -7,7 +7,7 @@
 #
 # Note 2! The CFLAGS definitions are now in the main makefile...
 
-SUB_DIRS     := block char net #streams
+SUB_DIRS     := block char net streams
 MOD_SUB_DIRS := $(SUB_DIRS)
 ALL_SUB_DIRS := $(SUB_DIRS) pci sbus scsi sound cdrom isdn
 
Binary files debug/drivers/char/gdbstub and /usr/src/linux/drivers/char/gdbstub differ
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/Makefile /usr/src/linux/drivers/streams/LiS/Makefile
--- debug/drivers/streams/LiS/Makefile	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/Makefile	Mon Dec 30 09:44:28 1996
@@ -0,0 +1,31 @@
+#
+# Makefile for the kernel STREAMS device drivers.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2: This makefile departs from the usual and customary Linux
+#         kernel makefile.  The streams subsystem has special requirements.
+#
+# Note 3! This file is entered from a make in a superior directory
+#         it is NOT intended to be run from the command line.
+
+
+all:	streams.a
+
+FORCE:
+
+streams.a: FORCE
+	set -e; make -C ./head/linux LIBDIR=../..;  \
+		make -C ./drivers/str/linux LIBDIR=../../.. 
+
+clean: FORCE
+	rm -f streams.a
+	set -e; make -C ./head/linux clean; \
+		make -C ./drivers/str/linux clean \
+		make -c ./util/linux clean
+
+tags:	files
+	ctags `cat files`
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/drivers/str/clone.c /usr/src/linux/drivers/streams/LiS/drivers/str/clone.c
--- debug/drivers/streams/LiS/drivers/str/clone.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/drivers/str/clone.c	Mon Dec 16 16:36:36 1996
@@ -0,0 +1,111 @@
+/************************************************************************
+*                          Clone Driver                                 *
+*************************************************************************
+*									*
+* Author:	David Grothe <dave@gcom.com>				*
+*									*
+* This driver's open routine divides the device number passed in into	*
+* the major and minor parts.  It treats the minor number as the major	*
+* number of the driver that the user really wants to open.  It then	*
+* calls that driver's open routine passing in the target driver's	*
+* major and minor zero.  It sets the clone option bit in this open.	*
+*									*
+* The queue passed to clone is given the attributes of the target	*
+* driver rather than of the clone driver.				*
+*									*
+* When this driver returns from its open routine the dev_t structure	*
+* passed to it will no doubt be modified.  The caller, perhaps clear	*
+* back in the I/O system, must take care to notice this and allocate	*
+* a new inode for this stream.						*
+*									*
+************************************************************************/
+
+#include <sys/stream.h>
+
+static struct module_info clone_minfo =
+{
+  0,				/* id */
+  "clone",			/* name */
+  0,				/* min packet size accepted */
+  0,				/* max packet size accepted */
+  0,				/* high water mark */
+  0				/* low water mark */
+};
+
+static int   clone_open  (queue_t *, dev_t*, int, int, cred_t *);
+static int   clone_close (queue_t *, int, cred_t *);
+
+/* qinit structures (rd and wr side) 
+ */
+static struct qinit clone_rinit =
+{
+  NULL,				/* put */       
+  NULL,				/* service  */  
+  clone_open,			/* open */      
+  clone_close,			/* close */     
+  NULL,				/* admin */     
+  &clone_minfo,			/* info */      
+  NULL				/* stat */      
+};
+
+static struct qinit clone_winit =
+{
+  NULL, 	                   /* put */       
+  NULL, 			/* service  */  
+  NULL, 			/* open */      
+  NULL, 			/* close */     
+  NULL, 			/* admin */     
+  &clone_minfo, 		/* info */      
+  NULL				/* stat */      
+};
+
+/* streamtab for the clone driver.
+ */
+struct streamtab clone_info =
+{
+  &clone_rinit,			/* read queue */
+  &clone_winit,			/* write queue */
+  NULL,				/* mux read queue  */
+  NULL				/* mux write queue */
+};
+
+
+static int
+clone_open (queue_t *q, dev_t *devp, int flag, int sflag, cred_t *credp)
+{
+    int		 major_dev ;
+    int		 rslt ;
+    streamtab_t	*st ;
+
+    if (sflag == CLONEOPEN) return(OPENFAIL) ;
+
+    /*
+     * Minor passed to us functions as major for the target driver
+     */
+    major_dev = minor (*devp);
+    st = lis_find_strdev(major_dev) ;
+    if (st == NULL) return(ENOENT) ;		/* no such driver */
+
+    *devp = makedevice(major_dev, 0) ;		/* construct new major */
+
+    if (st->st_rdinit->qi_qopen == NULL) return(OPENFAIL) ;
+    rslt = st->st_rdinit->qi_qopen (q, devp, flag, CLONEOPEN, credp) ;
+    if (rslt != 0) return(rslt) ;
+
+    lis_setq(q, st->st_rdinit, st->st_wrinit) ;	/* xfer queue params */
+
+    return(0) ;					/* success */
+
+} /* clone_open */
+
+
+static int
+clone_close (queue_t *q, int dummy, cred_t *credp)
+{
+    (void) q ;					/* compiler happiness */
+    (void) dummy ;
+    (void) credp ;
+
+    return(0) ;
+}
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/drivers/str/dlpidriver.c /usr/src/linux/drivers/streams/LiS/drivers/str/dlpidriver.c
--- debug/drivers/streams/LiS/drivers/str/dlpidriver.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/drivers/str/dlpidriver.c	Mon Dec 16 16:36:36 1996
@@ -0,0 +1,714 @@
+/*
+ * A template for a connectionless DLPI driver; e.g. Ethernet
+ */
+
+#include <linux/types.h>
+#include <linux/stream.h>
+#include <linux/stropts.h>
+#include <linux/cred.h>
+#include <linux/dlpi.h>
+#include <linux/param.h>
+#include <linux/errno.h>
+#include <linux/debug.h>
+#include <linux/cmn_err.h>
+#include <linux/ddi.h>
+#include "dlpidriver.h"
+
+struct fr 
+{
+    queue_t	*rq;
+    ulong_t	dlstate;
+    ushort_t	idtype;
+    ulong_t	id;
+};
+
+#define NO_ID	0
+#define BUF_ID	1
+#define TIME_ID	2
+
+#define ONESEC	1000000
+
+typedef enum retval 
+{
+    DONE, RETRY, ERR 
+}
+retval_t;
+
+STATIC int fropen(queue_t *, dev_t *, int, int, cred_t *);
+STATIC int frclose(queue_t *q, int cred_t *);
+STATIC int frrsrv(queue_t *);
+STATIC int frwput(queue_t *, mblk_t *);
+STATIC int frwsrv(queue_t *);
+
+STATIC retval_t fr_info(struct fr *);
+STATIC retval_t fr_bind(struct fr *, mblk_t *);
+STATIC retval_t fr_unbind(struct fr *, mblk_t *);
+STATIC retval_t fr_errorack(struct fr *, ulong_t, ulong_t, ulong_t);
+
+STATIC void fr_send(struct fr *, mblk_t *);
+STATIC void fr_wsched(struct fr *, int);
+STATIC void fr_wcont, struct fr *);
+STATIC void fr_free(char *);
+STATIC void fr_ioctl(queue_t *, mblk_t *);
+
+void frinit(void);
+void frintr(int);
+
+STATIC struct module_info fr_minfo = 
+{
+    0x7253, "fr", MINDATA, MAXDATA, 10*MAXDATA, MAXDATA
+};
+
+
+STATIC struct qinit fr_rinit = 
+{
+    NULL, frrsrv, fropen, frclose, NULL, &fr_minfo, NULL
+};
+
+STATIC struct qinit fr_winit = 
+{
+    frwput, frwsrv, NULL, NULL, NULL, &fr_minfo, NULL
+};
+
+struct streamtab frinfo = 
+{
+    &fr_rinit, &fr_winit, NULL, NULL
+};
+
+int frdevflag = 0;
+
+void frinit()
+{
+}
+
+
+STATIC int fropen(queue_t *q, dev_t *devp, int flag, int sflag, cred_t
+		  *crp)
+{
+    int i;
+    if (sflag == MODOPEN)
+	return EINVAL;
+    if (q->q_ptr != NULL)
+	return 0;
+    if (sflag == CLONEOPEN)
+    {
+	for (i = 0; i < MAXFR; i++)
+	    if (fr[i].rq == NULL)
+		break;
+	if (i > MAXFR)
+	    return ENXIO;
+	*devp = makedevice(getemajor(*devp), i);
+    }
+    else
+    {
+	if ((i = getminor(*devp)) >= MAXFR)
+	    return ENXIO;
+	
+    }
+    fr[i].rq = q;
+    fr[i].idtype = NO_ID;
+    fr[i].dlstate = DL_UNBOUND;
+    q->q_ptr = (caddr_t)&fr[i];
+    WR(q)->q_ptr = (caddr_t)&fr[i];
+    return 0;
+}
+
+STATIC int frclose(queue_t *q, int flag, cred_t *crp)
+{
+    struct fr *fr = (struct fr *)q->q_ptr;
+    if (fr->idtype==TIME_ID)
+	untimeout(fr->id);
+    else if (fr->idtype == BUF_ID)
+	unbuffcall(fr->id);
+    fr->dlstate = DL_UNBOUND;
+    fr->rq = NULL;
+    q->q_ptr = NULL;
+    WR(q)->q_ptr = NULL;
+    return 0;
+}
+
+STATIC int frwput(queue_t *q, mblk_t *mp)
+{
+    switch (mp->b_datap->db_type)
+    {
+    case M_FLUSH:
+	if (*mp->b_rptr & FLUSHW)
+	{
+	    flushq(q, FLUSHALL);
+	    *mp->b_rptr &= ~FLUSHW;
+	}
+	if (*mp->b_rptr & FLUSHR)
+	{
+	    flushq(RD(q), FLUSHALL);
+	    qreply(q, mp);
+	}
+	else freemsg(mp);
+	break;
+    case M_IOCTL:
+	fr_ioctl(q, mp);
+	break;
+    case M_PROTO:
+    case M_PCPROTO:
+	putq(q, mp);
+	break;
+    default:
+	freemsg(mp);
+	break;
+    }
+    return 0;
+}
+
+STATIC int frwsrv(queue_t *q)
+{
+    mblk_t *mp;
+    struct fr *fr;
+    int s;
+    ulong_t err, prim;
+    union DL_primitives *dlp;
+    fr = (struct fr *)q->q_ptr;
+    if (fr == NULL)
+	return 0;
+    while ((mp = getq(q)) != NULL)
+    {
+	ASSERT(mp->b_datap->db_type == M_PROTO || 
+	       mp->b_datap->db_type == M_PCPROTO);
+	err = 0;
+	dlp = (union DL_primitives *)mp->b_rptr;
+	prim = dlp->dl_primitive;
+	switch(prim)
+	{
+	case DL_UNITDATA_REQ:
+	    s = splstr();
+	    if (frsndbusy)
+		putbq(q, mp);
+	    else
+		fr_send(fr, mp);
+	    splx(s);
+	    return 0;
+	case DL_INFO_REQ:
+	    if (fr_info(fr) != DONE)
+		cmn_err(CE_WARN, "fr: can't respond to DL_INFO_REQ");
+	    
+	    freemsg(mp);
+	    break;
+	case DL_BIND_REQ:
+	    if (fr_bind(fr, mp) == RETRY)
+	    {
+		putbq(q, mp);
+		return 0;
+	    }
+	    break;
+	case DL_UNBIND_REQ:
+	    if (fr_unbind(fr, mp) == RETRY)
+	    {
+		putbq(q, mp);
+		return 0;
+	    }
+	    break;
+	case DL_ATTACH_REQ:
+	case DL_SETACH_REQ:
+	case DL_SUBS_BIND_REQ:
+	case DL_ENABMULTI_REQ:
+	case DL_DISABMULTI_REQ:
+	case DL_PROMISCON_REQ:
+	case DL_PROMISCOFF_REQ:
+	case DL_UDQOS_REQ:
+	case DL_CONNECT_REQ:
+	case DL_CONNECT_RES:
+	case DL_TOKEN_REQ:
+	case DL_DISCONNECT_REQ:
+	case DL_RESET_REQ:
+	case DL_RESET_RES:
+	case DL_DATA_ACK_REQ:
+	case DL_REPLY_REQ:
+	case DL_REPLY_UPDATE_REQ:
+	case DL_XID_REQ:
+	case DL_TEST_REQ:
+	    err = DL_NOTSUPPORTED;
+	    /* fall thru... */
+	default:
+	    if (err == 0) err = DL_BADPRIM;
+	    if (fr_errorack(fr, prim, err, 0) == RETRY)
+	    {
+		if (mp->b_datap->db_type < QPCTL)
+		{
+		    putbq(q, mp);
+		    return 0;
+		}
+		cmn_err(CE_WARN, "fr: can't generate DL_ERROR_ACK (%d)", prim);
+	    }
+	    freemsg(mp);
+	    break;
+	}
+    }
+    return 0;
+}
+
+STATIC int frrsrv(queue_t *q)
+{
+    mblk_t *mp;
+    while ((mp = getq(q)) != NULL)
+    {
+	ASSERT(mp->b_datap->db_type == M_PROTO);
+	if (canput(q->q_next)) 
+	{
+	    putnext(q, mp);
+	}
+	else
+	{
+	    putbq(q, mp);
+	    break;
+	}
+    }
+    return 0;
+}
+
+STATIC retval_t fr_info(struct fr *fr)
+{
+    dl_info_ack_t *ackp;
+    mblk_t *mp;
+    int i = DL_INFO_ACK_SIZE+TOTADDRSZ+MACSZ;
+    if ((mp = allocb(i, BPRI_HI))==NULL)
+	return ERR;
+    mp->b_datap->db_type = M_PCPROTO;
+    ackp = (dl_info_ack_t *)mp->b_wptr;
+    ackp->dl_primitive = DL_INFO_ACK;
+    ackp->dl_max_sdu = MAXDATA;
+    ackp->dl_min_sdu = MINDATA;
+    ackp->dl_addr_length = TOTADDRSZ;
+    ackp->dl_mac_type = DL_??;
+    ackp->dl_reserved = 0;
+    ackp->dl_current_state = fr->dlstate;
+    ackp->dl_sap_length = SAPSZ;
+    ackp->dl_service_mode = DL_CLDLS;
+    ackp->dl_qos_length = 0;
+    ackp->dl_qos_offset = 0;
+    ackp->dl_qos_range_length = 0;
+    ackp->dl_qos_range_offset = 0;
+    ackp->dl_provider_style = DL_STYLE1;
+    ackp->dl_version = DL_VERSION_2;
+    ackp->dl_brdcst_addr_length = MACSZ;
+    ackp->dl_growth = 0;
+    mp->b_wptr += DL_INFO_ACK_SIZE;
+    if (fr->dlstate == DL_IDLE)
+    {
+	ackp->dl_addr_offset = DL_INFO_ACK_SIZE;
+	???
+    }
+    else
+    {
+	???
+    }
+    ???;
+    putnext(fr->rq, mp);
+    return DONE;
+}
+
+STATIC retval_t fr_bind(struct fr *fr, mblk_t *mp)
+{
+    int i;
+    dl_bind_req_t *reqp;
+    dl_bind_ack_t *ackp;
+    mblk_t *bp;
+    ushort_t prot;
+    
+    if (fr->dlstate != DL_UNBOUND)
+    {
+	if (fr_errorack(fr, DL_BIND_REQ, DL_OUTSTATE, 0) == RETRY)
+	    return RETRY;
+	freemsg(mp);
+	return ERR;
+    }
+    reqp = (dl_bind_req_t *)mp->b_rptr;
+    if (reqp->dl_service_mode != DL_CLDLS)
+    {
+	if (fr_errorack(fr, DL_BIND_REQ, DL_UNSUPPORTED, 0) == RETRY)
+	    return RETRY;
+	freemsg(mp);
+	return ERR;
+    }
+    if (reqp->dl_xidtest_flg != 0)
+    {
+	if (fr_errorack(fr, DL_BIND_REQ, DL_NOAUTO, 0) == RETRY)
+	    return RETRY;
+	freemsg(mp);
+	return ERR;
+    }
+    prot = reqp->dl_sap;
+    for (i = 0; i < MAXFRAME; i++)
+	if (fr[i].prot == prot && fr[i].state == DL_IDLE)
+	{
+	    if (fr_errorack(fr, DL_BIND_REQ, DL_NOADDR, 0) == RETRY)
+		return RETRY;
+	    freemsg(mp);
+	    return ERR; 
+	}
+    if ((bp = allocb(DL_BIND_ACK_SIZE + TOTADDRSZ, BPRI_HI)) == NULL)
+    {
+	fr_wsched(fr, DL_BIND_ACK_SIZE + TOTADDRSZ);
+	return RETRY;
+    }
+    freemsg(mp);
+    bp->b_datap->db_type = M_PCPROTO;
+    ackp = (dl_bind_ack_t *)bp->b_wptr;
+    ackp->dl_primitive = DL_BIND_ACK;
+    ackp->dl_sap = prot;
+    ackp->dl_addr_length = TOTADDRSZ;
+    ackp->dl_addr_offset = DL_BIND_ACK_SIZE;
+    ackp->dl_max_conind = 0;
+    ackp->dl_xidtest_flg = 0;
+    bp->b_wptr += DL_BIND_ACK_SIZE;
+    for (i = 0; i < MACSZ; i++)
+	*bp->b_wptr++ = fr_addr[i];
+    *bp->b_wptr++ = (prot>>8)&0xff;
+    *bp->b_wptr++ = prot & 0xff;
+    fr->dlstate = DL_IDLE;
+    fr->prot = prot;
+    putnext(fr->rq, bp);
+    /* enable the receiver */
+    if (!frrcvbusy)
+        CMD_REG = RECV_ON; /* ??? */
+    return DONE;
+}
+
+STATIC retval_t fr_unbind(struct fr *fr, mblk_t *mp)
+{
+    mblk_t *bp;
+    dl_ok_ack_t *ackp;
+    if (fr->dlstate != DL_IDLE)
+    {
+	if (fr_errorack(fr, DL_UNBIND_REQ, DL_OUTSTATE, 0) == RETRY)
+	    return RETRY;
+	freemsg(mp);
+	return ERR;
+    }    
+    if ((bp = allocb(DL_OK_ACK_SIZE, BPRI_HI)) == NULL)
+    {
+	fr_wsched(fr, DL_OK_ACK_SIZE);
+	return RETRY;
+    }
+    if (putctl1(fr->rq->q_next, M_FLUSH, FLUSHRW) == 0)
+	cmn_err(CE_WARN, "fr: can't flush stream on unbind");
+    bp->b_datap->db_type = M_PCPROTO;
+    ackp = (dl_ok_ack_t *)bp->b_wptr;
+    ackp->dl_primitive = DL_OK_ACK;
+    ackp->dl_correct_primitive = DL_UNBIND_REQ;
+    bp->b_wptr += DL_OK_ACK_SIZE;
+    fr->dlstate = DL_UNBOUND;
+    fr->prot = 0;
+    putnext(fr->rq, bp);
+    return DONE;
+}
+
+
+STATIC void fr_send(struct fr *fr, mblk_t *mp)
+{
+    int i;
+    uchar_t *p, *dest;
+    dl_unitdata_req_t *reqp;
+    struct frhdr f;
+    mblk_t *bp;
+    long destlen;
+    reqp = (dl_unitdata_req_t *)mp->b_rptr;
+    p = mp->b_rptr + reqp->dl_dest_addr_offset;
+    dest = p;
+    destlen = reqp->dl_dest_addr_length;
+    if (fr->dlstate != DL_IDLE)
+    {
+	fr_uderr(fr, dest, destlen, DL_OUTSTATE, 0);
+	freemsg(mp);
+	return;
+    }
+    if (reqp->dl_dest_addr_length != TOTADDRSZ)
+    {
+	fr_uderr(fr, dest, destlen, DL_BADADDR, 0);
+	freemsg(mp);
+	return;
+    }
+    for (i= 0 ; i < MACSZ; i++)
+    {
+	f.dest[i] = *p++;
+	f.src[i] = fr_addr[i];
+    }
+    f.prot.s = *(ushort_t *)p;
+    bp = mp;
+    mp = mp->b_cont;
+    i = msgdsize(mp);
+    if ((i > MAXDATA) || (i < MINDATA))
+    {
+	freemsg(bp);
+	fr_uderr(fr, dest, destlen, DL_BADDATA, 0);
+	return;
+    }
+    freeb(bp);
+    if (sameaddr(f.dest, fr_addr))
+    {
+	fr_loop(mp, &f, fr->prot);
+	return;
+    }
+    /* Copy f and mp + plus all continuation blocks to board
+       memory, and send the packet */
+    frsendbusy = 1;
+    if (sameaddr(f.dest, bcast_addr))
+    {
+	fr_loop(mp, &f, fr->prot);
+	return;
+    }
+    freemsg(mp);
+}
+
+STATIC void fr_wsched(struct fr *fr, int size)
+{
+    fr->id = bufcall(size, BPRI_HI, fr_wcont, (long)fr);
+    if (fr->id == 0)
+    {
+	fr->id = timeout(fr_wcont, (caddr_t)fr, drv_usectohz(ONESEC));
+	fr->idtype = TIME_ID;
+    }
+    else fr->idtype = BUF_ID;
+}
+
+
+STATIC void fr_wcont(struct fr *fr)
+{
+    if (fr->rq != NULL)
+    {
+	fr->idtype = NO_ID;
+	qenable(WR(fr->rq));
+    }
+}
+
+STATIC retval_t fr_errorack(struct fr *fr, ulong_t prim, ulong_t err,
+			    ulong_t uerr)
+{
+    dl_error_ack_t *errp;
+    mblk_t *bp;
+    if ((bp = allocb(DL_ERROR_ACK_SIZE, BPRI_HI)) == NULL)
+    {
+	fr_wsched(fr, DL_ERROR_ACK_SIZE);
+	return RETRY;
+    }
+    bp->b_datap->db_type = M_PCPROTO;
+    errp = (dl_error_ack_t *)bp->b_wptr;
+    errp->dl_primitive = DL_ERROR_ACK;
+    errp->dl_error_primitive = prim;
+    errp->dl_errno = err;
+    errp->dl_unix_errno = uerr;
+    bp->b_wptr += DL_ERROR_ACK_SIZE;
+    putnext(fr->rq, bp);
+    return DONE;
+}
+
+STATIC void fr_uderr(struct fr *fr, uchar_t *dest, ulong_t destlen,
+		     ulong_t err, ulong_t uerr)
+{
+    dl_uderror_ind_t *errp;
+    mblk_t *bp;
+    int i;
+    
+    i = DL_UDERROR_IND_SIZE + destlen;
+    if ((bp = allocb(i, BPRI_HI)) == NULL)
+	return;
+    bp->b_datap->db_type = M_PROTO;
+    errp = (dl_uderror_ind_t *)bp->b_wptr;
+    errp->dl_primitive = DL_UDERROR_IND;
+    errp->dl_errno = err;
+    errp->dl_unix_errno = uerr;
+    errp->dl_dest_addr_length = destlen;
+    errp->dl_dest_addr_offset = DL_UDERROR_IND_SIZE;
+    bp->b_wptr += DL_UDERROR_IND_SIZE;
+    bcopy((caddr_t)dest, (caddr_t)bp->b_wptr, destlen);
+    bp->b_wptr += destlen;
+    putnext(fr->rq, bp);
+}
+
+void frint(int vec)
+{
+    dl_unitdata_ind_t *dp;
+    uchar_t *p, *protp;
+    int i, stat, size;
+    mblk_t *mp, *bp;
+    ushort_t prot;
+
+    if (DPMem->status != 0)
+    {
+	/* handle failures */
+	return;
+    }
+    stat = DPMem->ind;
+    switch(stat)
+    {
+    case SEND_DONE:
+	frsendbusy = 0;
+	for (i = frnext; i < MAXFRAME; i++)
+	    if (fr[i].dlstate == DL_IDLE && WR(fr[i].rq)->q_first)
+	    {
+		qenable(WR(fr[i].rq));
+		frnext = i + 1;
+		return;
+	    }
+    case RECV_PKT:
+	size = DL_UNITDATA_IND_SIZE + TOTADDRSZ + TOTADDRSZ;
+	if ((mp = allocb(size, BPRI_MED)) == NULL)
+	{
+	    frrcvlost++;
+	    return;
+	}
+	size = ??;
+	if ((bp = esballoc(DPMem->??, size, BPRI_MED, &frfrtn)) ==
+	    NULL)
+	{
+	    freeb(mp);
+	    frrcvlost++;
+	    return;
+	}
+	mp->b_datap->db_type = M_PROTO;
+	dp = (dl_unitdata_ind_t *)mp->b_wptr;
+	dp->dl_primitive = DL_UNITDATA_IND;
+	dp->dl_dest_addr_length = TOTADDRSZ;
+	dp->dl_dest_addr_offset = DL_UNITDATA_IND_SIZE;
+	dp->dl_src_addr_length = TOTADDRSZ;
+	dp->dl_src_addr_offset = DL_UNITDATA_IND_SIZE + TOTADDRSZ;
+	p = bp->b_rptr;
+	dp->dl_group_address = isgroupaddr(p);
+	mp->b_wptr += DL_UNITDATA_IND_SIZE;
+	for (i = 0; i < MACSZ; i++)
+	    *mp->b_wptr++ = *p++;
+	protp = mp->b_wptr;
+	mp->b_wptr += SAPSZ;
+	for (i = 0; i < MACSZ; i++)
+	    *mp->b_wptr++ = *p++;
+	prot = *p << 8;
+	*mp->b_wptr++ = *p;
+	*protp++ = *p++;
+	prot |= *p;
+	*mp->b_wptr++ = *p;
+	*protp = *p++;
+	bp->b_rptr = p;
+	mp->b_cont = bp;
+	for (i = 0; i < MAXFRAME; i++)
+	{
+	    if (fr[i].prot == prot && fr[i].dlstate == DL_IDLE)
+	    {
+		if (canput(fr[i].rq))
+		{
+		    putq(fr[i].rq, mp);
+		    frrcvbusy = 1;
+		    return;
+		}
+		else
+		{
+		    freemsg(mp);
+		    frrcvlost++;
+		}
+		break;
+	    }
+	}
+	if (i >= MAXFRAME)
+	    freemsg(mp);  /* no destination */
+	break;
+    default:
+	frspurint++;
+    }
+}
+
+
+STATIC boid fr_ioctl(queue_t *q, mblk_t *mp)
+{
+    int i;
+    uchar_t *p;
+    struct iocblk *iocp;
+    struct fr *fr;
+    
+    iocp = (struct iocblk *)mp->b_rptr;
+    fr = (struct fr *)q->q_ptr;
+    if (iocp->ioc_count == TRANSPARENT)
+	goto nak;
+    switch(iocp->ioc_cmd)
+    {
+    case SETADDR:
+	if (iocp->ioc_count != MACSZ)
+	    goto nak;
+	if (fr->dlstate != DL_UNBOUND)
+	{
+	    iocp->ioc_error = EBUSY;
+	    goto nak;
+	}
+	iocp->ioc_error = drv_priv(iocp->ioc_cr);
+	if (iocp->ioc_error != 0)
+	    goto nak;
+	p = (uchar_t *)FR_ADDR;
+	for (i = 0; i < MACSZ; i++)
+	{
+	    fr_addr[i] = *mp->b_cont->b_rptr++;
+	    *p++ = fr_addr[i];
+	}
+	mp->b_datap->db_type = M_IOCACK;
+	iocp->ioc_count = 0;
+	break;
+    default:
+    nak:
+	mp->b_datap->db_type = M_IOCNAK;
+    }
+    qreply(q, mp);
+}
+
+STATIC void fr_loop(mblk_t *mp, struct frhdr *fhp, ushort_t srcsap)
+{
+    /* Is this necessary at all? */
+}
+
+STATIC void fr_free(char *dummy)
+{
+    frrcvbusy = 0;
+}
+
+STATIC int sameaddr(uchar_t *a, uchar_t *b)
+{
+    int i;
+    for (i = 0; i < MACSZ; i++)
+	if (*a++ != *b++)
+	    return 0;
+    return 1;
+}
+
+STATIC int isgroupaddr(uchar_t *dest)
+{
+    return (*dest & 1);
+}
+
+
+
+      
+
+	    
+    
+	
+ 
+    
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    
+
+
+    
+
+
+
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/drivers/str/linux/Makefile /usr/src/linux/drivers/streams/LiS/drivers/str/linux/Makefile
--- debug/drivers/streams/LiS/drivers/str/linux/Makefile	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/drivers/str/linux/Makefile	Sat Dec 28 12:06:11 1996
@@ -0,0 +1,33 @@
+# these are from the Linux top-level Makefile so we could just compile
+#
+# Environment of LINUX means the intent is to link into Linux kernel
+#
+	ENV	= -DLINUX
+#
+# Environment of QNX means the intent is to run the code as a QNX driver.
+#
+#	ENV	= -DQNX
+#
+# Environment of USER means the intent is to run the code at user level 
+# for testing.
+#
+#	ENV	= -DUSER
+#
+
+	SRC	= ..
+	OPT	= -O2 -g
+
+DRVRS	=loop.o relay.o clone.o minimux.o runq.o printk.o
+
+#
+# LIBDIR is passed in via the makefile line.  It is the streams library
+# three directories up that was built by compiling the streams
+# code in LiS/head directory.  We add the drivers to it.
+#
+add_drivers:	all
+	ar rs $(LIBDIR)/streams.a $(DRVRS)
+
+clean:	FORCE
+	-rm -f *.o all
+
+include $(SRC)/mk.bdy
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/drivers/str/log.c /usr/src/linux/drivers/streams/LiS/drivers/str/log.c
--- debug/drivers/streams/LiS/drivers/str/log.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/drivers/str/log.c	Mon Dec 16 16:36:37 1996
@@ -0,0 +1,383 @@
+
+/* Streams logging module */
+
+#include <linux/types.h>
+#include <linux/time.h>
+#include <linux/signal.h>
+#include <linux/param.h>
+#include <linux/sysmacros.h>
+#include <linux/stream.h>
+#include <linux/stropts.h>
+#include <linux/user.h>
+#include <linux/errno.h>
+#include "log.h"
+
+#define MAXB 100
+
+static struct module_info log_minfo =
+{
+		0, "strlog", 0, INFPSZ, 0, 0
+};
+
+static int log_open (), log_close ();
+static int log_wput (), log_rput ();
+
+static struct qinit log_rinit =
+{
+		log_rput, NULL, log_open, log_close, NULL, &log_minfo, NULL
+};
+
+static struct qinit log_winit =
+{
+		log_wput, NULL, NULL, NULL, NULL, &log_minfo, NULL
+};
+
+struct streamtab log_info =
+{&log_rinit, &log_winit, NULL, NULL};
+
+#define NLOG 10
+static struct log {
+	char flags;
+	char nr;
+} log_log[NLOG];
+
+static int log_cnt = NLOG;
+
+
+static int
+log_open (queue_t * q, int dev, int flag, int sflag
+#ifdef DO_ADDERROR
+		,int *err
+#endif
+)
+{
+	struct log *log;
+
+#ifdef DO_STREAMDEBUG
+	logme ();
+#endif
+	if (q->q_ptr) {
+		if (0)
+			printf ("Log: already open?\n");
+		return 0;
+	}
+	for (dev = 0; dev < log_cnt; dev++) {
+		if (!(log_log[dev].flags & LOG_INUSE))
+			break;
+	}
+
+	if (dev >= log_cnt) {
+		printf ("log: all %d devices allocated\n", log_cnt);
+		return OPENFAIL;
+	}
+	log = &log_log[dev];
+	WR (q)->q_ptr = (char *) log;
+	q->q_ptr = (char *) log;
+
+	log->flags = LOG_INUSE | LOG_READ | LOG_WRITE;
+	log->nr = minor (dev);
+	if (1)
+		printf ("Log driver %d opened.\n", dev);
+
+	return 0;
+}
+
+
+#if 0
+void
+log_printtcp (struct log *log, mblk_t * mp, char wr)
+{
+	register struct ip *ip;
+	register uint_t hlen;
+	register struct tcphdr *oth;
+	register struct tcphdr *th;
+
+	register mblk_t *mq = dupmsg (mp);
+
+	if (wr)
+		wr = 'w';
+	else
+		wr = 'r';
+
+	mp = pullup (mq, 128);
+	if (mp == NULL) {
+		freemsg (mq);
+		printf ("Log%cN %d ", wr);
+		return;
+	}
+	ip = (struct ip *) mp->b_rptr;
+	hlen = ip->ip_hl;
+
+
+	if (ip->ip_p != IPPROTO_TCP
+			|| (ip->ip_off & htons (0x3fff)) || mq->b_wptr - mq->b_rptr < 40) {
+		freemsg (mp);
+		printf ("Log%cT %x", wr, ip->ip_p);
+		return;
+	}
+	th = (struct tcphdr *) & ((unchar *) ip)[hlen << 2];
+	if (wr == 'w') {
+		printf ("TCP %x.%x ", th->th_seq, dsize (mp) - th->th_off);
+	} else {
+		printf ("TCP %x ", th->th_ack);
+	}
+	freemsg (mp);
+}
+
+#endif
+
+void
+log_printmsg (struct log *log, const char *text, mblk_t * mp)
+{
+	int ms = splstr ();
+
+#ifdef DO_STREAMDEBUG
+	logme ();
+#endif
+	if (log != NULL) {
+#if 0
+		if (log - log_log != 0 && mp->b_datap->db_type == M_DATA)
+			return;
+#endif
+		printf ("Log %d: ", log - log_log);
+	}
+	printf ("%s", text);
+
+	{
+		mblk_t *mp1;
+		char *name;
+		int nblocks = 0;
+		static mblk_t *blocks[MAXB];
+
+		for (mp1 = mp; mp1 != NULL; mp1 = mp1->b_cont) {
+			blocks[nblocks++] = mp1;
+			switch (mp1->b_datap->db_type) {
+			case M_DATA:
+				name = "DATA";
+				break;
+			case M_PROTO:
+				name = "PROTO";
+				break;
+#ifdef M_SPROTO
+			case M_SPROTO:
+				name = "SPROTO";
+				break;
+#endif
+			case M_BREAK:
+				name = "BREAK";
+				break;
+			case M_SIG:
+				name = "SIG";
+				break;
+			case M_DELAY:
+				name = "DELAY";
+				break;
+			case M_CTL:
+				name = "CTL";
+				break;
+			case M_IOCTL:
+				name = "IOCTL";
+				break;
+			case M_SETOPTS:
+				name = "SETOPTS";
+				break;
+#ifdef M_ADMIN
+			case M_ADMIN:
+				name = "ADMIN";
+				break;
+#endif
+#ifdef M_EXPROTO
+			case M_EXPROTO:
+				name = "EXPROTO";
+				break;
+#endif
+#ifdef M_EXDATA
+			case M_EXDATA:
+				name = "EXDATA";
+				break;
+#endif
+#ifdef M_EXSPROTO
+			case M_EXSPROTO:
+				name = "EXSPROTO";
+				break;
+#endif
+#ifdef M_EXSIG
+			case M_EXSIG:
+				name = "EXSIG";
+				break;
+#endif
+#ifdef M_PCPROTO
+			case M_PCPROTO:
+				name = "PCPROTO";
+				break;
+#endif
+#ifdef M_PKT
+			case M_PKT:
+				name = "PKT";
+				break;
+#endif
+#ifdef M_PKTSTOP
+			case M_PKTSTOP:
+				name = "PKTSTOP";
+				break;
+#endif
+			case M_IOCACK:
+				name = "IOCACK";
+				break;
+			case M_IOCNAK:
+				name = "IOCNAK";
+				break;
+			case M_PCSIG:
+				name = "PCSIG";
+				break;
+			case M_FLUSH:
+				name = "FLUSH";
+				break;
+			case M_STOP:
+				name = "STOP";
+				break;
+			case M_START:
+				name = "START";
+				break;
+			case M_HANGUP:
+				name = "HANGUP";
+				break;
+			case M_ERROR:
+				name = "ERROR";
+				break;
+#ifdef _MSG_PROTO_OWN
+#ifdef MSG_PROTO
+			case MSG_PROTO:
+				name = "MSGPROTO";
+				break;
+#endif
+#endif
+			default:
+				printf (":%d:", mp1->b_datap->db_type);
+				name = "unknown"; /* ,mp->b_datap->db_type); */
+				break;
+			}
+			printf ("; %s: %x.%x.%d", name, mp1, mp1->b_datap, mp1->b_wptr - mp1->b_rptr);
+			if (nblocks == MAXB) {
+				printf ("\n*** Block 0x%x pointed to 0x%x", mp1, mp1->b_cont);
+				mp1->b_cont = NULL;
+			} else {
+				int j;
+
+				for (j = 0; j < nblocks; j++) {
+					if (mp1->b_cont == blocks[j]) {
+						printf ("\n*** Block 0x%x circled to 0x%x (%d)", mp1, mp1->b_cont, j);
+						mp1->b_cont = NULL;
+					}
+				}
+			}
+		}
+	}
+	printf ("\n");
+	{
+		int j;
+		mblk_t *mp1;
+		const char ctab[]= "0123456789abcdef";
+
+#define BLOCKSIZE 0x10
+		for (j = 0, mp1 = mp; mp1 != NULL; mp1 = mp1->b_cont, j++) {
+			int i;
+			unchar *dp;
+			unchar x;
+
+			for (i = 0, dp = (unchar *) mp1->b_rptr; dp < (unchar *) mp1->b_wptr; dp += BLOCKSIZE) {
+				int k;
+				int l = (unchar *) mp1->b_wptr - dp;
+
+				printf ("    ");
+				for (k = 0; k < BLOCKSIZE && k < l; k++)
+					printf ("%c%c ", ctab[dp[k] >> 4], ctab[dp[k] & 0x0F]);
+				for (; k < BLOCKSIZE; k++)
+					printf ("   ");
+				printf (" : ");
+				for (k = 0; k < BLOCKSIZE && k < l; k++)
+					if (dp[k] > 31 && dp[k] < 127)
+						printf ("%c", dp[k]);
+					else
+						printf (".");
+				if (k < l)
+					printf (" +\n");
+				else if (mp1->b_cont != NULL) {
+					for (; k < BLOCKSIZE; k++)
+						printf (" ");
+					printf (" -\n");
+				} else
+					printf ("\n");
+			}
+		}
+	}
+	splx (ms);
+}
+
+static int
+log_wput (queue_t * q, mblk_t * mp)
+{
+	register struct log *log;
+
+#ifdef DO_STREAMDEBUG
+	logme ();
+#endif
+	log = (struct log *) q->q_ptr;
+
+	if (log->flags & LOG_WRITE) {
+#if 0
+		if (*mp->b_rptr == 0x45)
+			log_printtcp (log, mp, 1);
+		else
+#endif
+			log_printmsg (log, "write", mp);
+		switch (mp->b_datap->db_type) {
+		default:{
+				break;
+			}
+		}
+	}
+	putnext (q, mp);
+	return 0;
+}
+
+static int
+log_rput (queue_t * q, mblk_t * mp)
+{
+	register struct log *log;
+
+#ifdef DO_STREAMDEBUG
+	logme ();
+#endif
+	log = (struct log *) q->q_ptr;
+
+	if (log->flags & LOG_READ) {
+#if 0
+		if (*mp->b_rptr == 0x45)
+			log_printtcp (log, mp, 0);
+		else
+#endif
+			log_printmsg (log, "read", mp);
+	}
+	putnext (q, mp);
+	return 0;
+}
+
+
+static int
+log_close (queue_t * q)
+{
+	struct log *log;
+
+#ifdef DO_STREAMDEBUG
+	logme ();
+#endif
+	log = (struct log *) q->q_ptr;
+
+	flushq (q, FLUSHALL);
+	flushq (WR (q), FLUSHALL);
+	if (1)
+		printf ("Log driver %d closed.\n", log->nr);
+	log->flags = 0;
+	return 0;
+}
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/drivers/str/loop.c /usr/src/linux/drivers/streams/LiS/drivers/str/loop.c
--- debug/drivers/streams/LiS/drivers/str/loop.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/drivers/str/loop.c	Wed Jan  1 14:13:00 1997
@@ -0,0 +1,439 @@
+/*                               -*- Mode: C -*- 
+ * loop.c --- Streams loopback driver, as of Sun manual 
+ * Author          : Graham Wheeler
+ * Created On      : Sat Oct  7 05:01:31 1995
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: loop.c,v 1.5 1996/01/24 19:44:35 dave Exp $
+ * Purpose         : provide loopback streams driver
+ * ----------------______________________________________________
+ *
+ *    Copyright (C) 1995  Graham Wheeler, Francisco J. Ballesteros,
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    gram@aztec.co.za, nemo@ordago.uc3m.es
+ */
+
+/*  -------------------------------------------------------------------  */
+
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/stream.h>
+#include <sys/stropts.h>
+
+
+/*  -------------------------------------------------------------------  */
+/*			  Module definition structs                      */
+
+/* Module info for the loopback driver
+ */
+static struct module_info loop_minfo =
+{
+  0,				/* id */
+  "loop",			/* name */
+  0,				/* min packet size accepted */
+  INFPSZ,			/* max packet size accepted */
+  10240L,			/* high water mark */
+  512L				/* low water mark */
+};
+
+/* These are the entry points to the driver: open, close, write side put and
+ * service procedures and read side service procedure.
+ */
+static int   loop_open  (queue_t *,dev_t*,int,int, cred_t *);
+static int   loop_close (queue_t *, int, cred_t *);
+static void  loop_wput (queue_t *, mblk_t *);
+static void  loop_wsrv  (queue_t *);
+static void  loop_rsrv  (queue_t *);
+
+/* qinit structures (rd and wr side) 
+ */
+static struct qinit loop_rinit =
+{
+  NULL,				/* put */       
+  loop_rsrv,			/* service  */  
+  loop_open,			/* open */      
+  loop_close,			/* close */     
+  NULL,				/* admin */     
+  &loop_minfo,			/* info */      
+  NULL				/* stat */      
+};
+
+static struct qinit loop_winit =
+{
+  loop_wput,                    /* put */       
+  loop_wsrv, 			/* service  */  
+  NULL, 			/* open */      
+  NULL, 			/* close */     
+  NULL, 			/* admin */     
+  &loop_minfo, 			/* info */      
+  NULL				/* stat */      
+};
+
+/* streamtab for the loopback driver.
+ */
+struct streamtab loop_info =
+{
+  &loop_rinit,			/* read queue */
+  &loop_winit,			/* write queue */
+  NULL,				/* mux read queue  */
+  NULL				/* mux write queue */
+};
+
+/*  -------------------------------------------------------------------  */
+/*			    Module implementation                        */
+
+#include <sys/LiS/loop.h>
+
+/*  -------------------------------------------------------------------  */
+
+#define NLOOP 8			/* number of clone devs supported */
+
+struct loop			/* info for each loopback device */
+{
+  queue_t *qptr;
+  queue_t *oqptr;
+  int	   use_putnext ;	/* instead of service queue */
+  int	   use_bufcall ;	/* instead of putnext */
+  int	   msglvl ;		/* # msgs to queue before sending upstream */
+  int	   msgcnt ;		/* # msgs in the queue */
+  int	   timr ;		/* time out amount while msgs queued */
+  int	   timr_hndl ;		/* for running timer */
+  int	   mark ;		/* "mark" the next message(s) from above */
+  int	   minor_nr ;		/* minor number of this instance */
+};
+
+/* Arry.  w/ opened devices info & number of openened devices
+ */
+static struct loop loop_loop[NLOOP];
+static int loop_cnt = NLOOP;
+
+/*  -------------------------------------------------------------------  */
+
+
+static int
+loop_open (queue_t *q, dev_t *devp, int flag, int sflag, cred_t *credp)
+{
+  struct loop *loop;
+  dev_t		dev ;
+
+  if (sflag == CLONEOPEN) {
+    for (dev = 1; dev < loop_cnt; dev++) {
+      if (loop_loop[dev].qptr == NULL)
+	break;
+    }
+  } else
+    dev = minor (*devp);
+
+  if (dev >= loop_cnt)
+    return OPENFAIL;
+
+  *devp = makedevice(major(*devp), dev) ;
+  if (q->q_ptr)
+    return 0;					/* success */
+
+  loop = &loop_loop[dev];
+  WR (q)->q_ptr = (char *) loop;
+  q->q_ptr = (char *) loop;
+  loop->qptr = WR (q);
+  loop->minor_nr = dev ;
+
+#ifdef STREAMS_DEBUG
+  printk("Opened %x\n",dev);
+#endif
+
+  return 0;					/* success */
+}
+
+/*  -------------------------------------------------------------------  */
+
+int	loop_timeout(caddr_t arg)
+{
+    struct loop		*loop = (struct loop *) arg ;
+
+    if (loop->qptr != NULL)
+    {
+	enableok(WR(loop->qptr)) ;	/* allow qenable to work */
+	qenable(WR(loop->qptr)) ;
+    }
+    return(0);
+} /* loop_timeout */
+
+/*  -------------------------------------------------------------------  */
+/*
+ * loop_bufcall
+ *
+ * Called from the STREAMS bufcall mechanism.
+ *
+ * The argument is a pointer to a queue to enable.
+ */
+void loop_bufcall(long q_ptr)
+{
+    enableok((queue_t *) q_ptr) ;	/* allow qenable to work */
+    qenable((queue_t *) q_ptr) ;
+
+} /* loop_bufcall */
+
+/*  -------------------------------------------------------------------  */
+
+static void
+loop_wput (queue_t *q, mblk_t *mp)
+{
+  struct loop *loop;
+  int		rtn_count = 0 ;
+
+  loop = (struct loop *) q->q_ptr;
+
+  switch (mp->b_datap->db_type) {
+  case M_IOCTL:{
+    struct iocblk *iocb;
+    int error;
+
+    iocb = (struct iocblk *) mp->b_rptr;
+
+    switch (iocb->ioc_cmd) {
+    case LOOP_SET:{
+      int to;
+
+      if (iocb->ioc_count != sizeof (int)) {
+	printk ("Expected ioctl len %d, got %d\n", sizeof (int), iocb->ioc_count);
+
+	error = EINVAL;
+	goto iocnak;
+      }
+      to = *(int *) mp->b_cont->b_rptr;
+
+      if (to >= loop_cnt || to < 0 ||
+	  !loop_loop[to].qptr) {
+	error = ENXIO;
+	goto iocnak;
+      }
+      if (loop->oqptr || loop_loop[to].oqptr) {
+	error = EBUSY;
+	goto iocnak;
+      }
+      loop->oqptr = RD (loop_loop[to].qptr);
+      loop_loop[to].oqptr = RD (q);
+      break;
+    }
+
+    case LOOP_PUTNXT:
+        loop->use_putnext = 1 ;		/* instead of service queue */
+	break ;
+
+    case LOOP_MSGLVL:
+	loop->msglvl = *(int *) mp->b_cont->b_rptr;
+	break ;
+
+    case LOOP_TIMR:
+	loop->timr = *(int *) mp->b_cont->b_rptr;
+	break ;
+
+    case LOOP_MARK:
+	loop->mark++ ;				/* mark next message */
+	break ;
+
+    case LOOP_GET_DEV:				/* get minor number */
+	{
+	    int		*devp ;
+
+	    if (iocb->ioc_count != sizeof (int))
+	    {
+		printk ("Expected ioctl len %d, got %d\n",
+			 sizeof (int), iocb->ioc_count);
+
+		error = EINVAL;
+		goto iocnak;
+	    }
+
+	    devp = (int *) mp->b_cont->b_rptr ;
+	    *devp = loop->minor_nr ;		/* return minor device nr */
+	    rtn_count = sizeof(int) ;
+	}
+	break ;
+
+    case LOOP_BUFCALL:
+	loop->use_bufcall++ ;
+	break ;
+
+    default:
+      printk ("Expected ioctl %x, got %x\n", LOOP_SET, iocb->ioc_cmd);
+      error = EINVAL;
+    iocnak:{
+	mp->b_datap->db_type = M_IOCNAK;
+	iocb->ioc_error = error;
+	qreply (q, mp);
+      }
+      return ;
+    }				/* end of switch on ioc_cmd */
+
+    mp->b_datap->db_type = M_IOCACK;
+    iocb->ioc_count = rtn_count;
+    qreply (q, mp);
+
+    break;
+  }
+  case M_FLUSH:{
+    if (*mp->b_rptr & FLUSHW)
+      flushq (q, FLUSHDATA);
+    if (*mp->b_rptr & FLUSHR) {
+      flushq (RD (q), FLUSHDATA);
+      *mp->b_rptr &= ~FLUSHW;
+      qreply (q, mp);
+    } else
+      freemsg (mp);
+    break;
+  }
+  default:
+    if (loop->oqptr == NULL) {
+      putctl1 (RD (q)->q_next, M_ERROR, ENXIO);
+      freemsg (mp);
+      break;
+    }
+    if (loop->mark)
+    {
+	loop->mark-- ;
+	mp->b_flag |= MSGMARK ;
+    }
+
+    if (loop->use_putnext)
+	putnext (loop->oqptr, mp);
+    else
+    if (loop->use_bufcall)
+    {
+	noenable(q) ;			/* prevent queue enable */
+	putq (q, mp);
+	bufcall(0, 0, loop_bufcall, (long) q) ;
+    }
+    else
+    {
+	loop->msgcnt++ ;		/* count enqueued message */
+	if (loop->msglvl > 0)
+	    noenable(q) ;		/* prevent queue enable */
+
+	putq (q, mp);
+	if (loop->msgcnt > loop->msglvl)
+	    qenable(q) ;
+	else
+	if (loop->timr != 0 && loop->timr_hndl == 0)
+	    loop->timr_hndl = timeout(loop_timeout, (caddr_t) loop, loop->timr) ;
+    }
+    break;
+  
+  }
+}
+
+/*  -------------------------------------------------------------------  */
+
+static void
+loop_wsrv (queue_t *q)
+{
+  mblk_t *mp;
+  register struct loop *loop;
+
+  loop = (struct loop *) q->q_ptr;
+
+  if (   loop->use_bufcall == 0
+      && loop->timr_hndl == 0
+      && loop->msgcnt <= loop->msglvl) return ;
+
+  if (loop->timr_hndl != 0)
+  {
+      untimeout(loop->timr_hndl) ;
+      loop->timr_hndl = 0 ;
+  }
+
+  while ((mp = getq (q)) != NULL)
+  {
+    if (mp->b_datap->db_type <= QPCTL &&
+	!canput (loop->oqptr->q_next))
+    {
+      putbq (q, mp);
+      if (loop->use_bufcall)
+	bufcall(0, 0, loop_bufcall, (long) q) ;
+      break;
+    }
+
+    if (loop->use_bufcall)
+	loop->use_bufcall-- ;
+
+    putnext (loop->oqptr, mp);
+    if (--loop->msgcnt <= loop->msglvl) break ;
+  }
+}
+
+/*  -------------------------------------------------------------------  */
+
+static void
+loop_rsrv (queue_t *q)
+{
+  struct loop *loop;
+
+  loop = (struct loop *) q->q_ptr;
+  if (loop->oqptr == NULL)
+    return;
+
+  qenable (WR (loop->oqptr));
+}
+
+/*  -------------------------------------------------------------------  */
+
+static int
+loop_close (queue_t *q, int dummy, cred_t *credp)
+{
+  struct loop *loop;
+
+  loop = (struct loop *) q->q_ptr;
+  loop->qptr = NULL;
+
+  if (loop->timr_hndl != 0)
+  {
+      untimeout(loop->timr_hndl) ;
+      loop->timr_hndl = 0 ;
+  }
+
+  if (loop->oqptr) {
+    ((struct loop *) loop->oqptr->q_ptr)->qptr = NULL;
+    ((struct loop *) loop->oqptr->q_ptr)->oqptr = NULL;
+    putctl (loop->oqptr->q_next, M_HANGUP);
+    loop->oqptr = NULL;
+  }
+  flushq (q, FLUSHALL);
+  flushq (WR (q), FLUSHALL);
+
+  loop->use_putnext = 0 ;
+  loop->msglvl = 0 ;
+  loop->msgcnt = 0 ;
+  loop->timr = 0 ;
+  loop->mark = 0 ;
+  return(0);
+}
+
+void	loop_register()
+{
+    register_strdev(	0,		/* major (allocate for us) */
+			&loop_info,	/* streamtab entry */
+			NLOOP,		/* number of minors */
+			"loop"		/* name */
+		   ) ;
+}
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/drivers/str/minimux.c /usr/src/linux/drivers/streams/LiS/drivers/str/minimux.c
--- debug/drivers/streams/LiS/drivers/str/minimux.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/drivers/str/minimux.c	Mon Dec 16 16:36:37 1996
@@ -0,0 +1,680 @@
+/************************************************************************
+*                      Miniature Multiplexor                            *
+*************************************************************************
+*									*
+* This  driver is a small multiplexor whose purpose is to facilitate	*
+* testing of the I_LINK and I_UNLINK code in STREAMS.			*
+*									*
+* Author:	David Grothe <dave@gcom.com>				*
+*									*
+************************************************************************/
+
+#include <sys/stream.h>
+#include <sys/cmn_err.h>
+#include <sys/LiS/minimux.h>
+
+
+/************************************************************************
+*                             Macros                                    *
+************************************************************************/
+
+#ifndef canputnext
+#define	canputnext(q)		canput((q)->q_next)
+#endif
+
+
+
+/************************************************************************
+*                          Table Structure                              *
+*************************************************************************
+*									*
+* As such, this multiplexor connects an upper stream with a lower	*
+* stream such that messages arriving in a downstream direction at	*
+* upper stream "A" are routed to lower stream "B".  Upstream messages	*
+* arriving at "B" will be routed to "A" by default but all this		*
+* can be changed via ioctls so as to make the topologies interesting	*
+* and complicated (for testing, of course).				*
+*									*
+* list		We thread all entries together.				*
+*									*
+* outq		The STREAMS queue that flows out of the multiplexor.	*
+*		If this is a lower entry then this will be the lower	*
+*		write queue.  If it is an upper entry then this will	*
+*		be the upper read queue.				*
+*									*
+* othermux	Pointer to the mux table entry for the other stream	*
+*		to which this stream is connected.			*
+*									*
+* ctl_strm	This field is filled in for lowers.  It points to the	*
+*		mux table entry for the control stream on which the	*
+*		I_LINK arrived.						*
+*									*
+* muxid		The l_index carried in the I_LINK for lower entries.	*
+*									*
+* minor_dev	Minor device number for upper entries.			*
+*									*
+************************************************************************/
+typedef struct mux_tbl
+{
+    struct mux_tbl	*list ;
+    queue_t		*outq ;
+    struct mux_tbl	*othermux ;
+    struct mux_tbl	*ctl_strm ;
+    int			 muxid ;
+    int			 minor_dev ;
+
+} mux_tbl_t ;
+
+
+/************************************************************************
+*                              Storage                                  *
+************************************************************************/
+
+mux_tbl_t	*mux_head ;		/* head of mux tbl entry thread */
+
+#define	MAXMUX		100		/* max number of minors open */
+int		 mux_minors[MAXMUX] ;	/* index by minor, in-use flags */
+
+/************************************************************************
+*                         Streamtab Structure                           *
+*************************************************************************
+*									*
+* The following is the streamtab structure for the multiplexor.		*
+*									*
+************************************************************************/
+static struct module_info mux_minfo =
+{
+  0,				/* id */
+  "mini-mux",			/* name */
+  0,				/* min packet size accepted */
+  INFPSZ,			/* max packet size accepted */
+  10240L,			/* high water mark */
+  512L				/* low water mark */
+};
+
+/*
+ * Driver entry points -- upper
+ */
+static int   mux_open  (queue_t *,dev_t*,int,int, cred_t *);
+static int   mux_close (queue_t *, int, cred_t *);
+static void  mux_wput  (queue_t *, mblk_t *);
+static void  mux_wsrv  (queue_t *);
+static void  mux_rsrv  (queue_t *);
+/*
+ * Driver entry points -- lower
+ */
+static void  mux_lrput (queue_t *, mblk_t *);
+static void  mux_lwsrv (queue_t *);
+static void  mux_lrsrv (queue_t *);
+
+/*
+ * qinit structures (rd and wr side, upper) 
+ */
+static struct qinit mux_rinit =
+{
+  NULL,				/* put */       
+  mux_rsrv,			/* service  */  
+  mux_open,			/* open */      
+  mux_close,			/* close */     
+  NULL,				/* admin */     
+  &mux_minfo,			/* info */      
+  NULL				/* stat */      
+};
+
+static struct qinit mux_winit =
+{
+  mux_wput,                    /* put */       
+  NULL, 			/* service  */  
+  NULL, 			/* open */      
+  NULL, 			/* close */     
+  NULL, 			/* admin */     
+  &mux_minfo, 			/* info */      
+  NULL				/* stat */      
+};
+
+/*
+ * qinit structures (rd and wr side, lower) 
+ */
+static struct module_info mux_lminfo =
+{
+  0,				/* id */
+  "mini-mux-lwr",		/* name */
+  0,				/* min packet size accepted */
+  INFPSZ,			/* max packet size accepted */
+  10240L,			/* high water mark */
+  512L				/* low water mark */
+};
+
+static struct qinit mux_lrinit =
+{
+  mux_lrput,			/* put */       
+  NULL,				/* service  */  
+  NULL,				/* open */      
+  NULL,				/* close */     
+  NULL,				/* admin */     
+  &mux_lminfo,			/* info */      
+  NULL				/* stat */      
+};
+
+static struct qinit mux_lwinit =
+{
+  NULL,   	                /* put */       
+  mux_lwsrv, 			/* service  */  
+  NULL, 			/* open */      
+  NULL, 			/* close */     
+  NULL, 			/* admin */     
+  &mux_lminfo, 			/* info */      
+  NULL				/* stat */      
+};
+
+/* streamtab for the loopback driver.
+ */
+struct streamtab mux_info =
+{
+  &mux_rinit,			/* read queue */
+  &mux_winit,			/* write queue */
+  &mux_lrinit,			/* mux read queue  */
+  &mux_lwinit			/* mux write queue */
+};
+
+/************************************************************************
+*                               new_mux                                 *
+*************************************************************************
+*									*
+* Allocate a new mux structure and link it into the master list.	*
+*									*
+************************************************************************/
+static mux_tbl_t *
+new_mux(void)
+{
+    mux_tbl_t	*muxp ;
+
+    muxp = (mux_tbl_t *) ALLOC(sizeof(*muxp)) ;
+    if (muxp == NULL)
+	return(NULL) ;
+
+    memset(muxp, 0, sizeof(*muxp)) ;
+    muxp->list		= mux_head ;
+    mux_head		= muxp ;
+
+    return(muxp) ;
+
+} /* new_mux */
+
+/************************************************************************
+*                          mux_open                                     *
+*************************************************************************
+*									*
+* Open routine for the multiplexor.					*
+*									*
+************************************************************************/
+static int
+mux_open (queue_t *q, dev_t *devp, int flag, int sflag, cred_t *credp)
+{
+    mux_tbl_t	*muxp;
+    dev_t	 dev ;
+
+    if (sflag == CLONEOPEN)
+    {
+	for (dev = 1; dev < MAXMUX; dev++)
+	{
+	    if (mux_minors[dev] == 0)
+	    {
+		mux_minors[dev] = 1 ;
+		break;
+	    }
+	}
+    }
+    else
+	dev = minor (*devp);
+
+    if (dev >= MAXMUX)
+	return (OPENFAIL);
+
+    *devp = makedevice(major(*devp), dev) ;
+
+    if (q->q_ptr != NULL)			/* already open */
+	return(0);				/* success (2nd open) */
+
+    muxp = new_mux() ;
+    if (muxp == NULL)
+	return(ENOMEM) ;
+
+    muxp->outq		= RD(q) ;		/* upstream read queue */
+    muxp->minor_dev	= dev ;
+    RD(q)->q_ptr	= muxp ;
+    WR(q)->q_ptr	= muxp ;
+
+    return(0);					/* success */
+
+} /* mux_open */
+
+/************************************************************************
+*                             mux_ioctl                                 *
+*************************************************************************
+*									*
+* Handle ioctl from upstream.						*
+*									*
+* For I_LINK the linkage is set up between the lower queue and the	*
+* queue on which the ioctl arrives.  These two queues then relay	*
+* messages upstream and downstream to each other.			*
+*									*
+************************************************************************/
+void	mux_ioctl(mux_tbl_t *muxp, mblk_t *mp)
+{
+    struct iocblk	*iocb;
+    struct linkblk	*lk ;
+    int			 error;
+    int			 rtn_count = 0 ;
+    int			 uplink = 0 ;
+
+    iocb = (struct iocblk *) mp->b_rptr;
+
+    switch (iocb->ioc_cmd)
+    {
+    case I_LINK:
+    case I_PLINK:
+	{
+	    mux_tbl_t	*lwr ;
+
+	    if (mp->b_cont == NULL)		/* no linkblk */
+	    {
+		error = EINVAL;
+		goto iocnak ;
+	    }
+
+	    lk = (struct linkblk *) mp->b_cont->b_rptr ;
+	    lwr = new_mux() ;
+	    if (lwr == NULL)
+	    {
+		error = ENOMEM ;
+		goto iocnak ;
+	    }
+
+	    lwr->ctl_strm	 = muxp ;	    /* remember control strm */
+	    lwr->othermux	 = muxp ;	    /* lower & upper connected */
+	    muxp->othermux	 = lwr ;
+	    lwr->muxid		 = lk->l_index ;    /* muxid of lower */
+	    lwr->outq		 = lk->l_qbot ;	    /* lower write queue */
+	    RD(lwr->outq)->q_ptr = lwr ;	    /* hook queues to tbl */
+	    WR(lwr->outq)->q_ptr = lwr ;
+	    qenable(RD(lwr->outq)) ;		    /* run service procedure */
+	    cmn_err(CE_CONT, "mux_ioctl: I_LINK dev %u to muxid %u\n",
+			     muxp->minor_dev, lk->l_index) ;
+	}
+	break ;
+
+    case I_UNLINK:
+    case I_PUNLINK:
+	{
+	    mux_tbl_t	*lwr ;
+	    mux_tbl_t	*prev ;
+
+	    if (mp->b_cont == NULL)		/* no linkblk */
+	    {
+		error = EINVAL;
+		goto iocnak ;
+	    }
+
+	    /*
+	     * Find entry with given muxid.  Assume that muxids are
+	     * unique only within a given control stream.
+	     */
+	    lk = (struct linkblk *) mp->b_cont->b_rptr ;
+	    prev = NULL ;
+	    for (lwr = mux_head; lwr != NULL; lwr = lwr->list)
+	    {
+		if (   lwr->ctl_strm == muxp		/* this is ctl strm */
+		    && lwr->muxid == lk->l_index	/* and this muxid */
+		   )
+		{
+		    break ;				/* that's the entry */
+		}
+
+		prev = lwr ;
+	    }
+
+	    if (lwr == NULL)			/* not found */
+	    {
+		cmn_err(CE_CONT, "mux_ioctl: I_UNLINK muxid %u: unknown muxid\n",
+				lk->l_index) ;
+		error = EINVAL ;
+		goto iocnak ;
+	    }
+
+	    cmn_err(CE_CONT, "mux_ioctl: I_UNLINK minor=%u -> muxid=%u\n",
+			     muxp->minor_dev, lk->l_index) ;
+	    if (prev == NULL)			/* 1st in list */
+		mux_head = lwr->list ;		/* link around it */
+	    else				/* middle of list */
+		prev->list = lwr->list ;	/* link around it */
+
+	    if (lwr->othermux != NULL && lwr->othermux->othermux == lwr)
+		lwr->othermux->othermux = NULL ;/* detach from lower */
+
+	    if (muxp->othermux == lwr)
+		muxp->othermux	 = NULL ;	/* detach from lower */
+
+	    RD(lwr->outq)->q_ptr = NULL ;	/* clobber q ptr */
+	    WR(lwr->outq)->q_ptr = NULL ;
+	    FREE(lwr) ;				/* free structure */
+	}
+	break ;
+
+    case MINIMUX_UP:				/* point lower to upper */
+	uplink = 1 ;	
+    case MINIMUX_DOWN:				/* point upper to lower */
+	{
+	    mux_tbl_t	*lwr ;
+	    int		 l_index ;
+
+	    if (iocb->ioc_count != sizeof(int))
+	    {
+		error = EINVAL ;
+		goto iocnak ;
+	    }
+
+	    l_index = *( (int *) mp->b_cont->b_rptr ) ;
+	    for (lwr = mux_head; lwr != NULL; lwr = lwr->list)
+	    {
+		if (lwr->ctl_strm == muxp && lwr->muxid == l_index) break ;
+	    }
+
+	    if (lwr == NULL)			/* not found */
+	    {
+		cmn_err(CE_CONT,
+			"mux_ioctl: MINIMUX_DOWN muxid %u: unknown muxid\n",
+				l_index) ;
+		error = EINVAL ;
+		goto iocnak ;
+	    }
+
+	    if (uplink)				/* point lwr to upper */
+		lwr->othermux = muxp ;		/* lwr point up at us */
+	    else				/* point upper to lower */
+		muxp->othermux = lwr ;		/* we point down to lower */
+	    					/* this lower does not    */
+	    					/* necessarily point back */
+	    					/* up to us.		  */
+	}
+	break ;
+
+    default:
+        error = EINVAL;
+    iocnak:
+	mp->b_datap->db_type = M_IOCNAK;
+	iocb->ioc_error = error;
+	iocb->ioc_count = rtn_count;
+	putnext (muxp->outq, mp);		/* send back upstream */
+	return ;
+    }				/* end of switch on ioc_cmd */
+
+    mp->b_datap->db_type = M_IOCACK;
+    iocb->ioc_count = rtn_count;
+    putnext (muxp->outq, mp);
+
+} /* mux_ioctl */
+
+/************************************************************************
+*                             mux_wput                                  *
+*************************************************************************
+*									*
+* Upper wput routine.							*
+*									*
+************************************************************************/
+static void
+mux_wput (queue_t *q, mblk_t *mp)
+{
+    queue_t	*fwdq ;
+    mux_tbl_t	*muxp ;
+
+    if (q->q_ptr == NULL)
+    {
+	freemsg(mp) ;
+	return ;
+    }
+
+    muxp = q->q_ptr ;
+    if (muxp->othermux != NULL)		/* linked to downstream queue */
+	fwdq = muxp->othermux->outq ;	/* forward downstream */
+    else				/* no downstream linkage */
+	fwdq = muxp->outq ;		/* forwared back upstream */
+
+    switch (mp->b_datap->db_type)
+    {
+    case M_DATA:
+    case M_PROTO:
+    case M_PCPROTO:
+	if (canputnext(fwdq))		/* check flow control */
+	    putnext(fwdq, mp) ;
+	else
+	    putq(fwdq, mp) ;
+	break ;
+
+    case M_IOCTL:
+	mux_ioctl(muxp, mp) ;
+	break ;
+
+    case M_FLUSH:			/* flush upper queue */
+	if (*mp->b_rptr & FLUSHW)
+	    flushq (q, FLUSHDATA);
+
+	if (muxp->othermux != NULL && muxp->othermux->outq != NULL)
+	{				/* if connected, pass downstream */
+	    flushq (muxp->othermux->outq, FLUSHDATA);	/* lwr write q */
+	    putnext(muxp->othermux->outq, mp);
+	}
+	else				/* not connected */
+	if (*mp->b_rptr & FLUSHR)
+	{
+	    flushq (RD(q), FLUSHDATA);
+	    *mp->b_rptr &= ~FLUSHW;
+	    qreply (q, mp);		/* reply as lowest driver */
+	}
+	else
+	    freemsg (mp);
+
+	break;
+    }
+
+} /* mux_wput  */
+
+
+/************************************************************************
+*                        mux_messenger_service                          *
+*************************************************************************
+*									*
+* Service a queue by attempting to forward messages subject to flow	*
+* control constraints.							*
+*									*
+************************************************************************/
+static void
+mux_messenger_service(queue_t *q)
+{
+    mux_tbl_t	*muxp ;
+    mblk_t	*mp;
+
+    muxp = (mux_tbl_t *) q->q_ptr;
+
+    while ((mp = getq(q)) != NULL)
+    {
+	if (   mp->b_datap->db_type <= QPCTL
+	    && !canputnext(q)
+	   )
+	{
+	  putbq(q, mp);
+	  break;
+	}
+
+	putnext(q, mp);
+    }
+
+} /* mux_messenger_service */
+
+/************************************************************************
+*                              mux_wsrv                                 *
+*************************************************************************
+*									*
+* Upper write service routine.	Unused.					*
+*									*
+************************************************************************/
+static void
+mux_wsrv (queue_t *q)
+{
+} /* mux_wsrv */
+
+
+/************************************************************************
+*                             mux_rsrv                                  *
+*************************************************************************
+*									*
+* Upper read service procedure.						*
+*									*
+************************************************************************/
+static void
+mux_rsrv (queue_t *q)
+{
+    mux_messenger_service(q) ;
+
+} /* mux_rsrv  */
+
+
+/************************************************************************
+*                             mux_close                                 *
+*************************************************************************
+*									*
+* Close routine.							*
+*									*
+************************************************************************/
+static int
+mux_close (queue_t *q, int dummy, cred_t *credp)
+{
+    mux_tbl_t	*muxp ;
+    mux_tbl_t	*prev ;
+
+    if (q->q_ptr == NULL) return(0) ;
+
+    prev = NULL ;
+    for (muxp = mux_head; muxp != NULL; muxp = muxp->list)
+    {
+	if (muxp == (mux_tbl_t *) q->q_ptr) break ;	/* found it */
+	prev = muxp ;
+    }
+
+    if (muxp == NULL) return(0) ;			/* not found */
+
+    cmn_err(CE_CONT, "mux_close: minor=%d", muxp->minor_dev) ;
+    if (muxp->othermux != NULL)
+	cmn_err(CE_CONT, " -> muxid=%d\n", muxp->othermux->muxid) ;
+    else
+	cmn_err(CE_CONT, " no lower\n") ;
+
+    if (prev == NULL)			/* 1st in list */
+	mux_head = muxp->list ;		/* link around it */
+    else				/* middle of list */
+	prev->list = muxp->list ;	/* link around it */
+
+    if (muxp->othermux != NULL && muxp->othermux->othermux == muxp)
+	muxp->othermux->othermux = NULL ;/* detach from upper */
+					 /* maybe orphans the lower */
+
+    RD(muxp->outq)->q_ptr = NULL ;	/* clobber q ptr (cheap insurance) */
+    WR(muxp->outq)->q_ptr = NULL ;
+    q->q_ptr		  = NULL ;
+    mux_minors[muxp->minor_dev] = 0 ;	/* make minor available */
+
+    FREE(muxp) ;			/* free structure */
+
+} /* mux_close */
+
+/************************************************************************
+*                           mux_lrput                                   *
+*************************************************************************
+*									*
+* Lower read put procedure.  Receives messages from driver below.	*
+*									*
+************************************************************************/
+static void
+mux_lrput (queue_t *q, mblk_t *mp)
+{
+    queue_t	*fwdq ;
+    mux_tbl_t	*muxp ;
+
+    if (q->q_ptr == NULL)
+    {
+	freemsg(mp) ;
+	return ;
+    }
+
+    muxp = q->q_ptr ;
+    if (muxp->othermux != NULL)		/* linked to upstream queue */
+	fwdq = muxp->othermux->outq ;	/* forward upstream */
+    else				/* no upstream linkage */
+	fwdq = muxp->outq ;		/* forwared back downstream */
+
+    switch (mp->b_datap->db_type)
+    {
+    case M_DATA:
+    case M_PROTO:
+    case M_PCPROTO:
+	if (canputnext(fwdq))		/* check flow control */
+	    putnext(fwdq, mp) ;
+	else
+	    putq(fwdq, mp) ;
+	break ;
+
+    case M_IOCTL:
+	freemsg(mp) ;			/* ioctl from below */
+	break ;
+
+    case M_FLUSH:			/* flush lower queue */
+	if (*mp->b_rptr & FLUSHR)
+	    flushq (q, FLUSHDATA);
+
+	if (muxp->othermux != NULL && muxp->othermux->outq != NULL)
+	{				/* if connected, pass upstream */
+	    flushq (muxp->othermux->outq, FLUSHDATA);	/* upper rd queue */
+	    putnext(muxp->othermux->outq, mp);
+	}
+	else				/* not connected */
+	if (*mp->b_rptr & FLUSHW)
+	{
+	    flushq (WR(q), FLUSHDATA);
+	    *mp->b_rptr &= ~FLUSHR;
+	    qreply (q, mp);		/* reply as highest driver */
+	}
+	else
+	    freemsg (mp);
+
+	break;
+    }
+
+} /* mux_lrput  */
+
+/************************************************************************
+*                              mux_lwsrv                                *
+*************************************************************************
+*									*
+* Lower write service routine.						*
+*									*
+************************************************************************/
+static void
+mux_lwsrv (queue_t *q)
+{
+    mux_messenger_service(q) ;
+
+} /* mux_lwsrv */
+
+
+/************************************************************************
+*                             mux_lrsrv                                 *
+*************************************************************************
+*									*
+* Lower read service procedure.  Unused.				*
+*									*
+************************************************************************/
+static void
+mux_lrsrv (queue_t *q)
+{
+} /* mux_lrsrv  */
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/drivers/str/mk.bdy /usr/src/linux/drivers/streams/LiS/drivers/str/mk.bdy
--- debug/drivers/streams/LiS/drivers/str/mk.bdy	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/drivers/str/mk.bdy	Sat Dec 28 12:06:11 1996
@@ -0,0 +1,93 @@
+#
+# common makefile for all environments
+#
+# ENV has been set by the file that includes this file
+#
+ARCH = i386
+AS	=as
+LD	=ld
+TOPDIR= /usr/src/LiS
+TOPDIR= $(Groot)/rsys/linux/LiS
+TOPDIR= $(SRC)/../..
+HOSTCC	=cc -I$(TOPDIR)/include -I/usr/src/linux
+CC	=cc -DLiS -D__KERNEL__ $(ENV) \
+	     -I$(TOPDIR)/include $(LINUX_INCL) $(OPT)
+CPP	=$(CC) -E -DLINUX -DUSER -DSYS_SCO -DQNX
+MAKE	=make
+CPP	=$(CC) -E
+AR	=ar
+RM      =/bin/rm -f
+NM	=nm
+STRIP	=strip
+TMP	=/tmp
+
+#
+# DRVRS defined by the makefile that includes this makefile
+#
+
+all:	$(SRC)/dep $(DRVRS)
+	touch all
+
+$(SRC)/dep:	$(SRC)/loop.d $(SRC)/relay.d $(SRC)/clone.d $(SRC)/minimux.d \
+		$(SRC)/printk.d
+	touch $(SRC)/dep
+
+
+$(SRC)/loop.d:	$(SRC)/loop.c
+	 $(CPP) -M $(SRC)/loop.c >$(SRC)/loop.d
+include $(SRC)/loop.d
+loop.o:	
+	$(CC) -c -o $(TMP)/$@	$(SRC)/loop.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+
+$(SRC)/relay.d:	$(SRC)/relay.c
+	 $(CPP) -M $(SRC)/relay.c >$(SRC)/relay.d
+include $(SRC)/relay.d
+relay.o:
+	$(CC) -c -o $(TMP)/$@	$(SRC)/relay.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+
+$(SRC)/clone.d:	$(SRC)/clone.c
+	 $(CPP) -M $(SRC)/clone.c >$(SRC)/clone.d
+include $(SRC)/clone.d
+clone.o:
+	$(CC) -c -o $(TMP)/$@	$(SRC)/clone.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+
+
+$(SRC)/minimux.d:	$(SRC)/minimux.c
+	 $(CPP) -M $(SRC)/minimux.c >$(SRC)/minimux.d
+include $(SRC)/minimux.d
+minimux.o:
+	$(CC) -c -o $(TMP)/$@	$(SRC)/minimux.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+
+#$(SRC)/dlpidriver.d:	$(SRC)/dlpidriver.c
+#	 $(CPP) -M $(SRC)/dlpidriver.c >$(SRC)/dlpidriver.d
+#include $(SRC)/dlpidriver.d
+#dlpidriver.o:
+#	$(CC) -c -o $(TMP)/$@	$(SRC)/dlpidriver.c
+#	cp $(TMP)/$@ .
+#	-$(RM) $(TMP)/$@
+
+$(SRC)/runq.d:	$(SRC)/runq.c
+	 $(CPP) -M $(SRC)/runq.c >$(SRC)/runq.d
+include $(SRC)/runq.d
+runq.o:	
+	$(CC) -c -o $(TMP)/$@	$(SRC)/runq.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+
+$(SRC)/printk.d:	$(SRC)/printk.c
+	 $(CPP) -M $(SRC)/printk.c >$(SRC)/printk.d
+include $(SRC)/printk.d
+printk.o:	
+	$(CC) -c -o $(TMP)/$@	$(SRC)/printk.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+
+clean:	$(RM) *.o *.a all
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/drivers/str/module-skeleton.c /usr/src/linux/drivers/streams/LiS/drivers/str/module-skeleton.c
--- debug/drivers/streams/LiS/drivers/str/module-skeleton.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/drivers/str/module-skeleton.c	Mon Dec 16 16:36:37 1996
@@ -0,0 +1,42 @@
+
+#ifdef LINUX
+
+static int svi_major;
+char kernel_version
+= UTS_RELEASE;
+
+int init_module( void )
+{
+        svi_major = lis_register_strdev (0, &sviinfo, 0, "svi");
+        if      (svi_major < 0)
+                return -EIO;
+        sviinit ();
+        return  0;
+}
+
+void cleanup_module( void )
+{
+        lis_unregister_strdev (svi_major, &sviinfo, 0);
+}
+
+void * bzero(void * s,size_t count)
+{
+        char *xs = (char *) s;
+
+        while (count--)
+                *xs++ = '\0';
+
+        return s;
+}
+
+char * bcopy(const char * src, char * dest, int count)
+{
+        char *tmp = dest;
+
+        while (count--)
+                *tmp++ = *src++;
+
+        return dest;
+}
+#endif /* LINUX */
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/drivers/str/printk.c /usr/src/linux/drivers/streams/LiS/drivers/str/printk.c
--- debug/drivers/streams/LiS/drivers/str/printk.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/drivers/str/printk.c	Mon Dec 16 16:36:37 1996
@@ -0,0 +1,121 @@
+/************************************************************************
+*                          Printk Driver                                *
+*************************************************************************
+*									*
+* Author:	David Grothe <dave@gcom.com>				*
+*									*
+* This driver, /dev/printk, allows user level programs to write to	*
+* the kernel's log.  When a user program writes to /dev/printk it	*
+* turns into a kernel printk() call.  The purpose of this driver is	*
+* to allow user level test programs of STREAMS to get their messages	*
+* in sequence with the debug messages originating from the kernel.	*
+*									*
+************************************************************************/
+
+#include <sys/stream.h>
+
+static struct module_info printk_minfo =
+{
+  0,				/* id */
+  "printk",			/* name */
+  0,				/* min packet size accepted */
+  0,				/* max packet size accepted */
+  0,				/* high water mark */
+  0				/* low water mark */
+};
+
+static int   printk_open  (queue_t *, dev_t*, int, int, cred_t *);
+static int   printk_close (queue_t *, int, cred_t *);
+static void  printk_wput (queue_t *, mblk_t *);
+
+/* qinit structures (rd and wr side) 
+ */
+static struct qinit printk_rinit =
+{
+  NULL,				/* put */       
+  NULL,				/* service  */  
+  printk_open,			/* open */      
+  printk_close,			/* close */     
+  NULL,				/* admin */     
+  &printk_minfo,		/* info */      
+  NULL				/* stat */      
+};
+
+static struct qinit printk_winit =
+{
+  printk_wput, 	                /* put */       
+  NULL, 			/* service  */  
+  NULL, 			/* open */      
+  NULL, 			/* close */     
+  NULL, 			/* admin */     
+  &printk_minfo, 		/* info */      
+  NULL				/* stat */      
+};
+
+/* streamtab for the printk driver.
+ */
+struct streamtab printk_info =
+{
+  &printk_rinit,		/* read queue */
+  &printk_winit,		/* write queue */
+  NULL,				/* mux read queue  */
+  NULL				/* mux write queue */
+};
+
+
+/*
+ * Open routine grants all opens
+ */
+static int
+printk_open (queue_t *q, dev_t *devp, int flag, int sflag, cred_t *credp)
+{
+    (void) q ;					/* compiler happiness */
+    (void) devp ;				/* compiler happiness */
+    (void) flag ;				/* compiler happiness */
+    (void) sflag ;				/* compiler happiness */
+    (void) credp ;				/* compiler happiness */
+
+    return(0) ;					/* success */
+
+} /* printk_open */
+
+
+static int
+printk_close (queue_t *q, int dummy, cred_t *credp)
+{
+    (void) q ;					/* compiler happiness */
+    (void) dummy ;
+    (void) credp ;
+
+    return(0) ;
+}
+
+static void 
+printk_wput (queue_t *q, mblk_t *msg)
+{
+    mblk_t	*mp ;
+    char	*p ;
+    char	 c ;
+
+    (void) q;				/* compiler happiness */
+
+    if (msg->b_datap->db_type != M_DATA)
+    {
+	freemsg(msg) ;
+	return ;
+    }
+
+    for (mp = msg; mp != NULL; mp = mp->b_cont)
+    {
+	if (mp->b_rptr >= mp->b_wptr) continue ;
+
+	p = mp->b_wptr - 1 ;			/* to last chr of msg */
+	c = *p ;				/* fetch last chr */
+	*p = 0 ;				/* last chr to NUL */
+	printk("%s%c", mp->b_rptr, c) ;		/* write msg */
+    }
+
+    freemsg(msg) ;				/* done with msg */
+
+} /* printk_wput  */
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/drivers/str/relay.c /usr/src/linux/drivers/streams/LiS/drivers/str/relay.c
--- debug/drivers/streams/LiS/drivers/str/relay.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/drivers/str/relay.c	Wed Jan  1 14:13:00 1997
@@ -0,0 +1,198 @@
+/*                               -*- Mode: C -*- 
+ * relay.c --- A simple relay pushable module
+ * Author          : Dave Grothe
+ * Created On      : Dec 30, 1995
+ * Last Modified By: Dave Grothe
+ * RCS Id          : $Id: relay.c,v 1.1 1996/01/07 20:49:08 dave Exp $
+ * Purpose         : relay messages just to test pushable modules
+ * ----------------______________________________________________
+ *
+ *    Copyright (C) 1995  David Grothe <dave@gcom.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+/*  -------------------------------------------------------------------  */
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/stream.h>
+
+/*  -------------------------------------------------------------------  */
+/*			  Module definition structs                      */
+
+/* Module info for the relay module
+ */
+static struct module_info relay_minfo =
+{
+  0,				/* id */
+  "relay",			/* name */
+  0,				/* min packet size accepted */
+  INFPSZ,			/* max packet size accepted */
+  10240L,			/* high water mark */
+  512L				/* low water mark */
+};
+
+static struct module_info relay2_minfo =
+{
+  0,				/* id */
+  "relay2",			/* name */
+  0,				/* min packet size accepted */
+  INFPSZ,			/* max packet size accepted */
+  10240L,			/* high water mark */
+  512L				/* low water mark */
+};
+
+/* These are the entry points to the driver: open, close, write side put and
+ * service procedures and read side service procedure.
+ */
+static int   relay_open  (queue_t *,dev_t*,int,int, cred_t *);
+static int   relay_close (queue_t *, int, cred_t *);
+static void  relay_wput  (queue_t *, mblk_t *);
+static void  relay_rput  (queue_t *, mblk_t *);
+static void  relay_wsrv  (queue_t *);
+static void  relay_rsrv  (queue_t *);
+
+/* qinit structures (rd and wr side) 
+ */
+static struct qinit relay_rinit =
+{
+  relay_rput,			/* put */       
+  NULL,				/* service  */  
+  relay_open,			/* open */      
+  relay_close,			/* close */     
+  NULL,				/* admin */     
+  &relay_minfo,			/* info */      
+  NULL				/* stat */      
+};
+
+static struct qinit relay_winit =
+{
+  relay_wput,                    /* put */       
+  NULL, 			/* service  */  
+  NULL, 			/* open */      
+  NULL, 			/* close */     
+  NULL, 			/* admin */     
+  &relay_minfo, 			/* info */      
+  NULL				/* stat */      
+};
+
+/* streamtab for the loopback driver.
+ */
+struct streamtab relay_info =
+{
+  &relay_rinit,			/* read queue */
+  &relay_winit,			/* write queue */
+  NULL,				/* mux read queue  */
+  NULL				/* mux write queue */
+};
+
+static struct qinit relay2_rinit =
+{
+  relay_rput,			/* put */       
+  NULL,				/* service  */  
+  relay_open,			/* open */      
+  relay_close,			/* close */     
+  NULL,				/* admin */     
+  &relay2_minfo,		/* info */      
+  NULL				/* stat */      
+};
+
+static struct qinit relay2_winit =
+{
+  relay_wput,                   /* put */       
+  NULL, 			/* service  */  
+  NULL, 			/* open */      
+  NULL, 			/* close */     
+  NULL, 			/* admin */     
+  &relay2_minfo, 		/* info */      
+  NULL				/* stat */      
+};
+
+/* streamtab for the loopback driver.
+ */
+struct streamtab relay2_info =
+{
+  &relay2_rinit,		/* read queue */
+  &relay2_winit,		/* write queue */
+  NULL,				/* mux read queue  */
+  NULL				/* mux write queue */
+};
+/*  -------------------------------------------------------------------  */
+/*			    Module implementation                        */
+/*  -------------------------------------------------------------------  */
+
+/*  -------------------------------------------------------------------  */
+/*				relay_open				 */
+/*  -------------------------------------------------------------------  */
+static int
+relay_open (queue_t *q, dev_t *devp, int flag, int sflag, cred_t *credp)
+{
+  if (sflag == CLONEOPEN)
+      return(EINVAL) ;
+
+  return 0;					/* success */
+
+}
+
+/*  -------------------------------------------------------------------  */
+/*				relay_wput				 */
+/*  -------------------------------------------------------------------  */
+
+static void
+relay_wput (queue_t *q, mblk_t *mp)
+{
+    putnext(q, mp) ;			/* relay downstream */
+}
+
+/*  -------------------------------------------------------------------  */
+/*				relay_rput				 */
+/*  -------------------------------------------------------------------  */
+
+static void
+relay_rput (queue_t *q, mblk_t *mp)
+{
+    putnext(q, mp) ;			/* relay upstream */
+}
+
+/*  -------------------------------------------------------------------  */
+/*				relay_wsrv				 */
+/*  -------------------------------------------------------------------  */
+
+static void
+relay_wsrv (queue_t *q)
+{
+    /* not used */
+}
+
+/*  -------------------------------------------------------------------  */
+/*				relay_rsrv				 */
+/*  -------------------------------------------------------------------  */
+
+static void
+relay_rsrv (queue_t *q)
+{
+    /* not used */
+}
+
+/*  -------------------------------------------------------------------  */
+/*				relay_close				 */
+/*  -------------------------------------------------------------------  */
+
+static int
+relay_close (queue_t *q, int dummy, cred_t *credp)
+{
+}
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/drivers/str/runq.c /usr/src/linux/drivers/streams/LiS/drivers/str/runq.c
--- debug/drivers/streams/LiS/drivers/str/runq.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/drivers/str/runq.c	Wed Jan  1 14:13:00 1997
@@ -0,0 +1,144 @@
+/************************************************************************
+*                          Run Queues Driver                            *
+*************************************************************************
+*									*
+* Author:	David Grothe <dave@gcom.com>				*
+*									*
+* This driver is a symbiont to the STREAMS package.  It's only valid	*
+* entries are open and close.  When open is called it never returns	*
+* and sits in a loop waiting for wakeups that will cause the STREAMS	*
+* queues to be run.							*
+*									*
+* This creates a kernel daemon process that is responsible for running	*
+* the STREAMS service queues.  This allows all STREAMS queue processing	*
+* to be "nice'd" relative to other system activities.			*
+*									*
+************************************************************************/
+
+#include <linux/sched.h>
+#include <asm/signal.h>
+#include <sys/stream.h>
+
+static struct module_info runq_minfo =
+{
+  0,				/* id */
+  "runq",			/* name */
+  0,				/* min packet size accepted */
+  0,				/* max packet size accepted */
+  0,				/* high water mark */
+  0				/* low water mark */
+};
+
+static int   runq_open  (queue_t *, dev_t*, int, int, cred_t *);
+static int   runq_close (queue_t *, int, cred_t *);
+
+/* qinit structures (rd and wr side) 
+ */
+static struct qinit runq_rinit =
+{
+  NULL,				/* put */       
+  NULL,				/* service  */  
+  runq_open,			/* open */      
+  runq_close,			/* close */     
+  NULL,				/* admin */     
+  &runq_minfo,			/* info */      
+  NULL				/* stat */      
+};
+
+static struct qinit runq_winit =
+{
+  NULL, 	                /* put */       
+  NULL, 			/* service  */  
+  NULL, 			/* open */      
+  NULL, 			/* close */     
+  NULL, 			/* admin */     
+  &runq_minfo, 			/* info */      
+  NULL				/* stat */      
+};
+
+/* streamtab for the runq driver.
+ */
+struct streamtab runq_info =
+{
+  &runq_rinit,			/* read queue */
+  &runq_winit,			/* write queue */
+  NULL,				/* mux read queue  */
+  NULL				/* mux write queue */
+};
+
+int				runq_open_flag ; /* open has been called */
+int				runq_sched ;	/* q's are scheduled */
+struct semaphore		runq_sem ;
+
+extern void			lis_run_queues(void) ;
+extern int			lis_queues_running ;
+
+/*
+ * This routine is called from many places in the streams code
+ * to set the flag to schedule queues to be run.
+ */
+void	lis_setqsched()
+{
+    if (lis_queues_running == 0 && runq_sched == 0)
+    {					/* no, then wake up qrun process */
+	runq_sched = 1 ;		/* queues waiting to be run */
+	lis_up(&runq_sem) ;		/* V() the semaphore */
+	if (runq_sem.count > 1)
+	    printk("lis_setqsched: runq_sem.count=%u runq_sem.waking=%u\n",
+			runq_sem.count, runq_sem.waking) ;
+    }
+
+} /* lis_setqsched */
+
+/*
+ * This routine does not return unless the process is killed.
+ */
+static int
+runq_open (queue_t *q, dev_t *devp, int flag, int sflag, cred_t *credp)
+{
+    int		ret = 0 ;
+    sigset_t	sig_blocked = ~( 1 << (SIGKILL-1) )  ;
+    sigset_t	old_sigs = current->blocked ;
+
+    if (runq_open_flag)
+	return(EBUSY) ;
+
+    if (sflag == CLONEOPEN) return(OPENFAIL) ;
+
+    runq_open_flag = 1 ;		/* disallow further opens */
+    SEM_INIT(&runq_sem, 0) ;		/* initialize semaphore */
+    current->blocked = sig_blocked ;
+    for (;;)
+    {
+	if (runq_sem.count > 1)
+	    printk("runq_open: runq_sem.count=%u runq_sem.waking=%u\n",
+			runq_sem.count, runq_sem.waking) ;
+
+	lis_run_queues() ;		/* run the STREAMS queues */
+	if (   (lis_down(&runq_sem) < 0)	/* interrupted */
+	    && (current->signal & ~current->blocked)	/* killed */
+	   )
+	{
+	    ret = -EINTR ;		/* "fail" open */
+	    break ;
+	}
+    }
+
+    SEM_DESTROY(&runq_sem) ;		/* de-init semaphore */
+    current->blocked = old_sigs ;	/* restore signals */
+    runq_open_flag = 0 ;		/* allow opens again */
+    return(ret) ;			/* return "whatever" (Bob Dole quote) */
+
+} /* runq_open */
+
+
+static int
+runq_close (queue_t *q, int dummy, cred_t *credp)
+{
+    (void) q ;					/* compiler happiness */
+    (void) dummy ;
+    (void) credp ;
+
+    return(0) ;
+}
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/drivers/str/user/makefile /usr/src/linux/drivers/streams/LiS/drivers/str/user/makefile
--- debug/drivers/streams/LiS/drivers/str/user/makefile	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/drivers/str/user/makefile	Sat Dec 28 12:06:11 1996
@@ -0,0 +1,22 @@
+# these are from the Linux top-level Makefile so we could just compile
+#
+# Environment of LINUX means the intent is to link into Linux kernel
+#
+#	ENV	= -DLINUX
+#
+# Environment of QNX means the intent is to run the code as a QNX driver.
+#
+#	ENV	= -DQNX
+#
+# Environment of USER means the intent is to run the code at user level 
+# for testing.
+#
+	ENV	= -DUSER
+#
+	SRC	= ..
+	OPT	= -g
+	LINUX_INCL = -I$(TOPDIR)/linux-kernel/include
+
+DRVRS	=loop.o relay.o clone.o minimux.o printk.o
+
+include $(SRC)/mk.bdy
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/files.src /usr/src/linux/drivers/streams/LiS/files.src
--- debug/drivers/streams/LiS/files.src	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/files.src	Mon Dec 16 16:36:37 1996
@@ -0,0 +1,101 @@
+./drivers/str/clone.c
+./drivers/str/dlpidriver.c
+./drivers/str/log.c
+./drivers/str/loop.c
+./drivers/str/minimux.c
+./drivers/str/module-skeleton.c
+./drivers/str/relay.c
+./drivers/str/mk.bdy
+./drivers/str/user/makefile
+./drivers/str/linux/Makefile
+./head/Makefile.standalone
+./head/buffcall.c
+./head/cmn_err.c
+./head/dki.c
+./head/errmsg.c
+./head/events.c
+./head/head.c
+./head/init.c
+./head/linux-mdep.c
+./head/linux/config.h
+./head/linux/makenodes.c
+./head/linux/modconf.c
+./head/linux/port.c
+./head/linux/Makefile
+./head/linux/config
+./head/mdep.c
+./head/mod.c
+./head/msg.c
+./head/msgutl.c
+./head/poll.c
+./head/port-mdep.c
+./head/qnx-mdep.c
+./head/queue.c
+./head/safe.c
+./head/stats.c
+./head/strconf.c
+./head/stream.c
+./head/strmdbg.c
+./head/syscalls.c
+./head/syscalls_libc.c
+./head/test.c
+./head/wait.c
+./head/tags
+./head/sputbuf.c
+./head/slog.c
+./head/box
+./include/sys/LiS/buffcall.h
+./include/sys/LiS/dlpidriver.h
+./include/sys/LiS/dos-mdep.h
+./include/sys/LiS/errmsg.h
+./include/sys/LiS/events.h
+./include/sys/LiS/fifo.h
+./include/sys/LiS/head.h
+./include/sys/LiS/linux-mdep.h
+./include/sys/LiS/log.h
+./include/sys/LiS/loop.h
+./include/sys/LiS/minimux.h
+./include/sys/LiS/mod.h
+./include/sys/LiS/msg.h
+./include/sys/LiS/msgutl.h
+./include/sys/LiS/poll.h
+./include/sys/LiS/port-mdep.h
+./include/sys/LiS/qnx-mdep.h
+./include/sys/LiS/queue.h
+./include/sys/LiS/sco-mdep.h
+./include/sys/LiS/share.h
+./include/sys/LiS/stats.h
+./include/sys/LiS/streamsdrv.h
+./include/sys/LiS/strlog.h
+./include/sys/LiS/strmdbg.h
+./include/sys/LiS/sys54-mdep.h
+./include/sys/LiS/user-cmn.h
+./include/sys/LiS/user-mdep.h
+./include/sys/LiS/wait.h
+./include/sys/cmn_err.h
+./include/sys/cred.h
+./include/sys/ddi.h
+./include/sys/debug.h
+./include/sys/dki.h
+./include/sys/dlpi.h
+./include/sys/major.h
+./include/sys/npi.h
+./include/sys/poll.h
+./include/sys/strconfig.h
+./include/sys/stream.h
+./include/sys/strmsg.h
+./include/sys/stropts.h
+./include/sys/strport.h
+./include/sys/kmem.h
+./include/sys/tihdr.h
+./include/sys/cdi.h
+./LSM
+./scope
+./Makefile
+./ADVICES
+./LICENSE
+./LICENSE.README
+./NOTES
+./README.INSTALL
+./VOLUNTEERS
+./files.src
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/get_makefile /usr/src/linux/drivers/streams/LiS/get_makefile
--- debug/drivers/streams/LiS/get_makefile	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/get_makefile	Mon Dec 16 16:36:37 1996
@@ -0,0 +1 @@
+cp /rsys/linux/LiS/makefile .
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/Makefile /usr/src/linux/drivers/streams/LiS/head/Makefile
--- debug/drivers/streams/LiS/head/Makefile	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/Makefile	Mon Dec 16 16:36:37 1996
@@ -0,0 +1,306 @@
+############################ -*- Mode: Makefile -*- ###########################
+## Makefile --- makefile for LiS STREAM head
+## Author          : Francisco J. Ballesteros Camara
+## Created On      : Mon Oct 17 11:41:20 1994
+## Last Modified By: Francisco J. Ballesteros
+## Last Modified On: Fri Oct 13 15:37:31 1995
+## Update Count    : 7
+## Status          : Unknown, Use with caution!
+###############################################################################
+
+#
+# This makefile is include from the makefile in the subdirectory
+# below this directory for the particular target environment.
+#
+# The subdirectories are:
+#
+#	./linux		Linux kernel version
+#	./user		User level testing version
+#	./qnx		QNX kernel version
+#
+# Prior to including this file, these makefiles define one or another
+# of the following compile-time switches:
+#
+# Environment of LINUX means the intent is to link into Linux kernel
+#
+#	ENV	= -DLINUX
+#
+# Environment of QNX means the intent is to run the code as a QNX driver.
+#
+#	ENV	= -DQNX
+#
+# Environment of USER means the intent is to run the code at user level 
+# for testing.
+#
+#	ENV	= -DUSER
+
+
+# these are from the Linux top-level Makefile so we could just compile
+ARCH = i386
+AS	=as
+LD	=ld
+#TOPDIR= /home/jumilla/fcamara/private/s/
+TOPDIR= $(SRC)/../
+LINUX_INCL = -I$(TOPDIR)/linux-kernel/include
+LINUX_INCL = 
+HOSTCC	=cc -I$(TOPDIR)/include -I/usr/src/linux
+CC	=cc -DLiS -D__KERNEL__ $(ENV) \
+	 -I$(SRC) -I$(TOPDIR)/include $(LINUX_INCL) \
+	 $(CCOPT)
+
+MAKE	=make
+CPP	=$(CC) -E -DLINUX -DUSER -DSYS_SCO -DQNX
+AR	=ar
+RM      =/bin/rm -f
+NM	=nm
+STRIP	=strip
+TMP	=/tmp
+
+#
+# LIBDIR is defined on the command line by the invoking makefile
+#
+LIB  =$(LIBDIR)/streams.o
+LIB  =$(LIBDIR)/streams.a
+
+#
+# Note:  The file init.c gets compiled by being include in linux-mdep.c
+#
+OBJS =head.o dki.o msg.o mod.o buffcall.o mdep.o errmsg.o events.o \
+	msgutl.o poll.o queue.o \
+        safe.o stats.o stream.o strmdbg.o wait.o cmn_err.o port.o \
+	slog.o sputbuf.o syscalls.o
+
+SRCS =	$(SRC)/msg.c		\
+	$(SRC)/mod.c		\
+	$(SRC)/buffcall.c	\
+	$(SRC)/cmn_err.c	\
+	$(SRC)/mdep.c		\
+	$(SRC)/errmsg.c		\
+	$(SRC)/events.c		\
+	$(SRC)/msgutl.c		\
+	$(SRC)/poll.c		\
+	$(SRC)/queue.c		\
+	$(SRC)/safe.c		\
+	$(SRC)/stats.c		\
+	$(SRC)/stream.c		\
+	$(SRC)/strmdbg.c	\
+	$(SRC)/wait.c		\
+	$(SRC)/head.c		\
+	$(SRC)/dki.c		\
+	$(SRC)/init.c		\
+	$(SRC)/slog.c		\
+	$(SRC)/sputbuf.c	\
+	$(SRC)/syscalls.c	\
+	port.c			# local to build directory
+
+DEPS =	$(SRC)/msg.d		\
+	$(SRC)/mod.d		\
+	$(SRC)/buffcall.d	\
+	$(SRC)/cmn_err.d	\
+	$(SRC)/mdep.d		\
+	$(SRC)/errmsg.d		\
+	$(SRC)/events.d		\
+	$(SRC)/msgutl.d		\
+	$(SRC)/poll.d		\
+	$(SRC)/queue.d		\
+	$(SRC)/safe.d		\
+	$(SRC)/stats.d		\
+	$(SRC)/stream.d		\
+	$(SRC)/strmdbg.d	\
+	$(SRC)/wait.d		\
+	$(SRC)/head.d		\
+	$(SRC)/dki.d		\
+	$(SRC)/init.d		\
+	$(SRC)/syscalls.d
+
+strms: $(LIB) strconf $(SRC)/tags
+
+$(LIB): $(OBJS)
+	-rm -f $@
+	ar -r $@ $(OBJS)
+	sync
+
+clean: 
+	-$(RM) $(LIB) $(OBJS) $(DEPS)
+
+$(SRC)/tags:	$(SRCS) \
+    		$(TOPDIR)/include/sys/*.h \
+    		$(TOPDIR)/include/sys/LiS/*.h
+	cd $(SRC); ctags -t *.c \
+    		../include/sys/*.h \
+    		../include/sys/LiS/*.h
+
+#
+# Dependency file making rules
+#
+deps:	$(DEPS)
+
+$(SRC)/msg.d:	$(SRC)/msg.c
+	 $(CPP) -M $(SRC)/msg.c >$(SRC)/msg.d
+$(SRC)/mod.d:	$(SRC)/mod.c
+	 $(CPP) -M $(SRC)/mod.c >$(SRC)/mod.d
+$(SRC)/buffcall.d:	$(SRC)/buffcall.c
+	 $(CPP) -M $(SRC)/buffcall.c >$(SRC)/buffcall.d
+$(SRC)/cmn_err.d:	$(SRC)/cmn_err.c
+	 $(CPP) -M $(SRC)/cmn_err.c >$(SRC)/cmn_err.d
+$(SRC)/mdep.d:	$(SRC)/mdep.c $(SRC)/linux-mdep.c \
+		$(SRC)/port-mdep.c $(SRC)/qnx-mdep.c $(SRC)/user-mdep.c
+	 $(CPP) -M $(SRC)/mdep.c >$(SRC)/mdep.d
+$(SRC)/errmsg.d:	$(SRC)/errmsg.c
+	 $(CPP) -M $(SRC)/errmsg.c >$(SRC)/errmsg.d
+$(SRC)/events.d:	$(SRC)/events.c
+	 $(CPP) -M $(SRC)/events.c >$(SRC)/events.d
+$(SRC)/msgutl.d:	$(SRC)/msgutl.c
+	 $(CPP) -M $(SRC)/msgutl.c >$(SRC)/msgutl.d
+$(SRC)/poll.d:	$(SRC)/poll.c
+	 $(CPP) -M $(SRC)/poll.c >$(SRC)/poll.d
+$(SRC)/queue.d:	$(SRC)/queue.c
+	 $(CPP) -M $(SRC)/queue.c >$(SRC)/queue.d
+$(SRC)/safe.d:	$(SRC)/safe.c
+	 $(CPP) -M $(SRC)/safe.c >$(SRC)/safe.d
+$(SRC)/sputbuf.d:	$(SRC)/sputbuf.c
+	 $(CPP) -M $(SRC)/sputbuf.c >$(SRC)/sputbuf.d
+$(SRC)/stats.d:	$(SRC)/stats.c
+	 $(CPP) -M $(SRC)/stats.c >$(SRC)/stats.d
+$(SRC)/stream.d:	$(SRC)/stream.c
+	 $(CPP) -M $(SRC)/stream.c >$(SRC)/stream.d
+$(SRC)/strmdbg.d:	$(SRC)/strmdbg.c
+	 $(CPP) -M $(SRC)/strmdbg.c >$(SRC)/strmdbg.d
+$(SRC)/syscalls.d:	$(SRC)/syscalls.c
+	 $(CPP) -M $(SRC)/syscalls.c >$(SRC)/syscalls.d
+$(SRC)/wait.d:	$(SRC)/wait.c
+	 $(CPP) -M $(SRC)/wait.c >$(SRC)/wait.d
+$(SRC)/head.d:	$(SRC)/head.c
+	 $(CPP) -M $(SRC)/head.c >$(SRC)/head.d
+$(SRC)/dki.d:	$(SRC)/dki.c
+	 $(CPP) -M $(SRC)/dki.c >$(SRC)/dki.d
+$(SRC)/init.d:	$(SRC)/init.c
+	 $(CPP) -M $(SRC)/init.c >$(SRC)/init.d
+port.d:	port.c
+	 $(CPP) -M port.c >port.d
+
+
+#
+# Dependency files
+#
+include $(SRC)/msg.d
+include $(SRC)/mod.d
+include $(SRC)/buffcall.d
+include $(SRC)/cmn_err.d
+include $(SRC)/mdep.d
+include $(SRC)/errmsg.d
+include $(SRC)/events.d
+include $(SRC)/msgutl.d
+include $(SRC)/poll.d
+include $(SRC)/queue.d
+include $(SRC)/safe.d
+include $(SRC)/sputbuf.d
+include $(SRC)/stats.d
+include $(SRC)/stream.d
+include $(SRC)/strmdbg.d
+include $(SRC)/syscalls.d
+include $(SRC)/wait.d
+include $(SRC)/head.d
+include $(SRC)/dki.d
+include $(SRC)/init.d
+#include port.d
+
+
+#
+# Object file making rules
+#
+
+msg.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/msg.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+mod.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/mod.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+buffcall.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/buffcall.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+cmn_err.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/cmn_err.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+mdep.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/mdep.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+errmsg.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/errmsg.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+events.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/events.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+msgutl.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/msgutl.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+poll.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/poll.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+queue.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/queue.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+safe.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/safe.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+stats.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/stats.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+stream.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/stream.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+strmdbg.o:
+	$(CC) -c -o $(TMP)/$@ $(DEBUG_MASK) $(SRC)/strmdbg.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+slog.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/slog.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+sputbuf.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/sputbuf.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+syscalls.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/syscalls.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+wait.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/wait.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+head.o:
+	$(CC) -c -o $(TMP)/$@ $(DEBUG_MASK) $(SRC)/head.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+head.E:
+	$(CC) -E $(DEBUG_MASK) $(SRC)/head.c >head.E
+dki.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/dki.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+dki.E:
+	$(CC) -E $(SRC)/dki.c >dki.E
+port.o:
+	$(CC) -c port.c
+
+strconf:	$(SRC)/strconf.c
+	$(CC)	-o $(TMP)/$@ $(SRC)/strconf.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+
+queue.E:
+	$(CC) -E $(SRC)/queue.c >queue.E
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/Makefile.standalone /usr/src/linux/drivers/streams/LiS/head/Makefile.standalone
--- debug/drivers/streams/LiS/head/Makefile.standalone	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/Makefile.standalone	Mon Dec 30 09:34:00 1996
@@ -0,0 +1,302 @@
+############################ -*- Mode: Makefile -*- ###########################
+## Makefile --- makefile for LiS STREAM head
+## Author          : Francisco J. Ballesteros Camara
+## Created On      : Mon Oct 17 11:41:20 1994
+## Last Modified By: Francisco J. Ballesteros
+## Last Modified On: Fri Oct 13 15:37:31 1995
+## Update Count    : 7
+## Status          : Unknown, Use with caution!
+###############################################################################
+
+#
+# This makefile is include from the makefile in the subdirectory
+# below this directory for the particular target environment.
+#
+# The subdirectories are:
+#
+#	./linux		Linux kernel version
+#	./user		User level testing version
+#	./qnx		QNX kernel version
+#
+# Prior to including this file, these makefiles define one or another
+# of the following compile-time switches:
+#
+# Environment of LINUX means the intent is to link into Linux kernel
+#
+#	ENV	= -DLINUX
+#
+# Environment of QNX means the intent is to run the code as a QNX driver.
+#
+#	ENV	= -DQNX
+#
+# Environment of USER means the intent is to run the code at user level 
+# for testing.
+#
+#	ENV	= -DUSER
+
+
+# these are from the Linux top-level Makefile so we could just compile
+ARCH = i386
+AS	=as
+LD	=ld
+#TOPDIR= /home/jumilla/fcamara/private/s/
+TOPDIR= $(SRC)/../
+LINUX_INCL = -I$(TOPDIR)/linux-kernel/include
+LINUX_INCL = 
+KERNEL_VERSION	= -DVERSION_2 -DDMG_SEM
+HOSTCC	=cc -I$(TOPDIR)/include -I/usr/src/linux
+CC	=cc -DLiS -D__KERNEL__ $(KERNEL_VERSION) $(ENV) \
+	 -I$(SRC) -I$(TOPDIR)/include $(LINUX_INCL) \
+	 $(CCOPT)
+
+MAKE	=make
+CPP	=$(CC) -E -DLINUX -DUSER -DSYS_SCO -DQNX
+AR	=ar
+RM      =/bin/rm -f
+NM	=nm
+STRIP	=strip
+TMP	=/tmp
+
+#
+# LIBDIR is defined on the command line by the invoking makefile
+#
+LIB  =$(LIBDIR)/streams.o
+LIB  =$(LIBDIR)/streams.a
+
+#
+# Note:  The file init.c gets compiled by being include in linux-mdep.c
+#
+OBJS =head.o dki.o msg.o mod.o buffcall.o mdep.o errmsg.o events.o \
+	msgutl.o queue.o \
+        safe.o stats.o stream.o strmdbg.o wait.o cmn_err.o port.o \
+	slog.o sputbuf.o syscalls.o
+
+SRCS =	$(SRC)/msg.c		\
+	$(SRC)/mod.c		\
+	$(SRC)/buffcall.c	\
+	$(SRC)/cmn_err.c	\
+	$(SRC)/mdep.c		\
+	$(SRC)/errmsg.c		\
+	$(SRC)/events.c		\
+	$(SRC)/msgutl.c		\
+	$(SRC)/poll.c		\
+	$(SRC)/queue.c		\
+	$(SRC)/safe.c		\
+	$(SRC)/stats.c		\
+	$(SRC)/stream.c		\
+	$(SRC)/strmdbg.c	\
+	$(SRC)/wait.c		\
+	$(SRC)/head.c		\
+	$(SRC)/dki.c		\
+	$(SRC)/init.c		\
+	$(SRC)/slog.c		\
+	$(SRC)/sputbuf.c	\
+	$(SRC)/syscalls.c	\
+	port.c			# local to build directory
+
+DEPS =	$(SRC)/msg.d		\
+	$(SRC)/mod.d		\
+	$(SRC)/buffcall.d	\
+	$(SRC)/cmn_err.d	\
+	$(SRC)/mdep.d		\
+	$(SRC)/errmsg.d		\
+	$(SRC)/events.d		\
+	$(SRC)/msgutl.d		\
+	$(SRC)/poll.d		\
+	$(SRC)/queue.d		\
+	$(SRC)/safe.d		\
+	$(SRC)/stats.d		\
+	$(SRC)/stream.d		\
+	$(SRC)/strmdbg.d	\
+	$(SRC)/wait.d		\
+	$(SRC)/head.d		\
+	$(SRC)/dki.d		\
+	$(SRC)/init.d		\
+	$(SRC)/syscalls.d
+
+strms: $(LIB) $(SRC)/tags
+
+$(LIB): $(OBJS)
+	-rm -f $@
+	ar -r $@ $(OBJS)
+	sync
+
+clean: 
+	-$(RM) $(LIB) $(OBJS) $(DEPS)
+
+$(SRC)/tags:	$(SRCS) \
+    		$(TOPDIR)/include/sys/*.h \
+    		$(TOPDIR)/include/sys/LiS/*.h
+	cd $(SRC); ctags -t *.c \
+    		../include/sys/*.h \
+    		../include/sys/LiS/*.h
+
+#
+# Dependency file making rules
+#
+deps:	$(DEPS)
+
+$(SRC)/msg.d:	$(SRC)/msg.c
+	 $(CPP) -M $(SRC)/msg.c >$(SRC)/msg.d
+$(SRC)/mod.d:	$(SRC)/mod.c
+	 $(CPP) -M $(SRC)/mod.c >$(SRC)/mod.d
+$(SRC)/buffcall.d:	$(SRC)/buffcall.c
+	 $(CPP) -M $(SRC)/buffcall.c >$(SRC)/buffcall.d
+$(SRC)/cmn_err.d:	$(SRC)/cmn_err.c
+	 $(CPP) -M $(SRC)/cmn_err.c >$(SRC)/cmn_err.d
+$(SRC)/mdep.d:	$(SRC)/mdep.c $(SRC)/linux-mdep.c \
+		$(SRC)/port-mdep.c $(SRC)/qnx-mdep.c $(SRC)/user-mdep.c
+	 $(CPP) -M $(SRC)/mdep.c >$(SRC)/mdep.d
+$(SRC)/errmsg.d:	$(SRC)/errmsg.c
+	 $(CPP) -M $(SRC)/errmsg.c >$(SRC)/errmsg.d
+$(SRC)/events.d:	$(SRC)/events.c
+	 $(CPP) -M $(SRC)/events.c >$(SRC)/events.d
+$(SRC)/msgutl.d:	$(SRC)/msgutl.c
+	 $(CPP) -M $(SRC)/msgutl.c >$(SRC)/msgutl.d
+$(SRC)/poll.d:	$(SRC)/poll.c
+	 $(CPP) -M $(SRC)/poll.c >$(SRC)/poll.d
+$(SRC)/queue.d:	$(SRC)/queue.c
+	 $(CPP) -M $(SRC)/queue.c >$(SRC)/queue.d
+$(SRC)/safe.d:	$(SRC)/safe.c
+	 $(CPP) -M $(SRC)/safe.c >$(SRC)/safe.d
+$(SRC)/sputbuf.d:	$(SRC)/sputbuf.c
+	 $(CPP) -M $(SRC)/sputbuf.c >$(SRC)/sputbuf.d
+$(SRC)/stats.d:	$(SRC)/stats.c
+	 $(CPP) -M $(SRC)/stats.c >$(SRC)/stats.d
+$(SRC)/stream.d:	$(SRC)/stream.c
+	 $(CPP) -M $(SRC)/stream.c >$(SRC)/stream.d
+$(SRC)/strmdbg.d:	$(SRC)/strmdbg.c
+	 $(CPP) -M $(SRC)/strmdbg.c >$(SRC)/strmdbg.d
+$(SRC)/syscalls.d:	$(SRC)/syscalls.c
+	 $(CPP) -M $(SRC)/syscalls.c >$(SRC)/syscalls.d
+$(SRC)/wait.d:	$(SRC)/wait.c
+	 $(CPP) -M $(SRC)/wait.c >$(SRC)/wait.d
+$(SRC)/head.d:	$(SRC)/head.c
+	 $(CPP) -M $(SRC)/head.c >$(SRC)/head.d
+$(SRC)/dki.d:	$(SRC)/dki.c
+	 $(CPP) -M $(SRC)/dki.c >$(SRC)/dki.d
+$(SRC)/init.d:	$(SRC)/init.c
+	 $(CPP) -M $(SRC)/init.c >$(SRC)/init.d
+port.d:	port.c
+	 $(CPP) -M port.c >port.d
+
+
+#
+# Dependency files
+#
+include $(SRC)/msg.d
+include $(SRC)/mod.d
+include $(SRC)/buffcall.d
+include $(SRC)/cmn_err.d
+include $(SRC)/mdep.d
+include $(SRC)/errmsg.d
+include $(SRC)/events.d
+include $(SRC)/msgutl.d
+include $(SRC)/poll.d
+include $(SRC)/queue.d
+include $(SRC)/safe.d
+include $(SRC)/sputbuf.d
+include $(SRC)/stats.d
+include $(SRC)/stream.d
+include $(SRC)/strmdbg.d
+include $(SRC)/syscalls.d
+include $(SRC)/wait.d
+include $(SRC)/head.d
+include $(SRC)/dki.d
+include $(SRC)/init.d
+#include port.d
+
+
+#
+# Object file making rules
+#
+
+msg.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/msg.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+mod.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/mod.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+buffcall.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/buffcall.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+cmn_err.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/cmn_err.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+mdep.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/mdep.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+errmsg.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/errmsg.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+events.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/events.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+msgutl.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/msgutl.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+poll.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/poll.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+queue.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/queue.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+safe.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/safe.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+stats.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/stats.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+stream.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/stream.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+strmdbg.o:
+	$(CC) -c -o $(TMP)/$@ $(DEBUG_MASK) $(SRC)/strmdbg.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+slog.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/slog.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+sputbuf.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/sputbuf.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+syscalls.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/syscalls.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+wait.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/wait.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+head.o:
+	$(CC) -c -o $(TMP)/$@ $(DEBUG_MASK) $(SRC)/head.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+head.E:
+	$(CC) -E $(DEBUG_MASK) $(SRC)/head.c >head.E
+dki.o:
+	$(CC) -c -o $(TMP)/$@ $(SRC)/dki.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+dki.E:
+	$(CC) -E $(SRC)/dki.c >dki.E
+port.o:
+	$(CC) -c port.c
+
+queue.E:
+	$(CC) -E $(SRC)/queue.c >queue.E
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/box /usr/src/linux/drivers/streams/LiS/head/box
--- debug/drivers/streams/LiS/head/box	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/box	Mon Dec 16 16:36:37 1996
@@ -0,0 +1,6 @@
+/************************************************************************
+*                                                                       *
+*************************************************************************
+*									*
+*									*
+************************************************************************/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/buffcall.c /usr/src/linux/drivers/streams/LiS/head/buffcall.c
--- debug/drivers/streams/LiS/head/buffcall.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/buffcall.c	Wed Jan  1 14:13:01 1997
@@ -0,0 +1,374 @@
+/*                               -*- Mode: C -*- 
+ * buffcall.c --- buffcall management
+ * Author          : Francisco J. Ballesteros & Graham Wheeler
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: David Grothe
+ * Last Modified On: Fri Dec 27 09:48:15 CST 1996
+ * RCS Id          : $Id: buffcall.c,v 1.3 1996/01/17 18:57:03 dave Exp $
+ * ----------------______________________________________________
+ *
+ *    Copyright (C) 1995  Graham Wheeler, Francisco J. Ballesteros,
+ *                        Denis Froschauer
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    gram@aztec.co.za, nemo@ordago.uc3m.es, 100741.1151@compuserve.com
+ *    dave@gcom.com
+ */
+
+
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#include <sys/strport.h>
+#include <sys/strconfig.h>	/* config definitions */
+#include <sys/LiS/share.h>	/* streams shared defs*/
+#include <sys/LiS/buffcall.h>	/* interface */
+#include <sys/LiS/wait.h>	/* interface */
+#include <sys/LiS/stats.h>
+
+/*  -------------------------------------------------------------------  */
+/*				   Symbols                               */
+
+#define ESB_SIZE	-1	/* special size for bufcall entries when a
+				 * bcinfo has this size it's really an entry
+				 * for esballoc */
+
+
+/*  -------------------------------------------------------------------  */
+/*				  Glob. Vars                             */
+
+volatile bclist_t	 lis_bchash[N_BCHASH] ;	/* the bufcall table */
+volatile bcinfo_t       *lis_bcfreel ;	/* the free list */
+
+volatile int		 lis_bc_cnt ;	/* total bufcalls running */
+volatile char		 lis_strbcflag;	/* the bufcall functions must be run */
+volatile static char	 lis_strbctimer;/* bufcall timer is running */
+struct timer_list	 lis_bctl ;	/* timer structure for bufcall */
+
+void	lis_dobufcall(void) ;
+
+/*  -------------------------------------------------------------------  */
+/*			   Local functions & macros                      */
+
+/*
+ * Timeout function.  Set the global flag that indicates that it is
+ * time to do bufcalls and set the queue schedule flag.  When LiS
+ * runs the queues it will notice the bufcall flag and do the bufcalls.
+ */
+static void bc_timeout(unsigned long not_used)
+{
+    (void) not_used ;
+    lis_strbcflag = 1 ;
+    lis_setqsched();
+
+} /* bc_timeout */
+
+
+/* link a new bcinfo struct, init it w/ given parms and return its address
+ */
+static int bc_link( int size, void (*function)(long), long arg )
+{
+    bcinfo_t		*bcinfo;
+    bclist_t		*list ;
+    int			 psw;
+    int			 id ;
+    static int		 id_num ;
+
+    /*
+     * First try to get a saved-up free structure from the list
+     * of free buffcall structures.  Failing that, allocate one.
+     * Failing that, return -1.
+     */
+    SPLSTR(psw);
+    bcinfo = (bcinfo_t *) lis_bcfreel;
+    if (bcinfo != NULL)
+	lis_bcfreel = bcinfo->next;
+
+    if ((id = ++id_num) == 0)
+	id = ++id_num ;			/* id must be non-zero */
+
+    SPLX(psw) ;
+
+    if (bcinfo == NULL)
+	bcinfo = ALLOCF(sizeof(*bcinfo), " buffcall struct") ;
+
+    if (bcinfo == NULL)
+    {
+	LisUpFailCount(BUFCALLS) ;		/* stats array */
+	LisDownCount(BUFCALLS) ;		/* stats array */
+	return(0) ;				/* table full */
+    }
+
+    /*
+     * Fill in the structure field values.  Do this before linking
+     * the structure into the buffcall waiting list.
+     */
+    bcinfo->size	= size;
+    bcinfo->usr_f	= function;
+    bcinfo->usr_arg	= arg;
+    bcinfo->id		= id ;
+    bcinfo->next	= NULL ;
+
+    /*
+     * Link the new structure onto the end of the buffcall list.
+     * Ensure we are uninterrupted while doing this.
+     */
+    list = (bclist_t *) &lis_bchash[id & BCHASH_MSK] ;
+    SPLSTR(psw);
+    bcinfo->prev = list->last ;		/* current to old last element */
+    list->last   = bcinfo ;		/* list to new entry */
+    if (list->first == NULL)		/* maybe only entry */
+	list->first = bcinfo ;
+    list->n_elts++ ;			/* count elements in hash list */
+    lis_bc_cnt++ ;			/* total bufcalls running */
+
+    if (lis_strbctimer == 0)		/* timer not running */
+    {
+	lis_strbctimer = 1 ;		/* set flag and start timer */
+	SPLX(psw) ;
+	lis_tmout(&lis_bctl, bc_timeout, 0, BUFCALL_N_TICKS) ;
+    }
+    else
+	SPLX(psw) ;
+
+    return(id);				/* return bufcall id */
+
+}/*bc_link*/
+
+/*  -------------------------------------------------------------------  */
+
+/* unlink a bcinfo struct. 
+ *
+ * Interrupts must be disabled prior to calling this routine.
+ */
+static void bc_ulink(bcinfo_t *bcinfo)
+{
+    bclist_t	*list ;
+
+    if (bcinfo == NULL) return ;		/* no element to delink */
+
+    list = (bclist_t *) &lis_bchash[bcinfo->id & BCHASH_MSK] ;
+
+    if (bcinfo->prev != NULL)
+	bcinfo->prev->next = bcinfo->next ;	/* link around */
+    
+    if (bcinfo->next != NULL)
+	bcinfo->next->prev = bcinfo->prev ;	/* link around */
+	
+    if (list->first == bcinfo)			/* at head of list */
+	list->first = bcinfo->next ;		/* NULL if last in list */
+
+    if (list->last == bcinfo)			/* at end of list */
+	list->last = bcinfo->prev ;		/* NULL if first in list */
+
+    list->n_elts-- ;
+    lis_bc_cnt-- ;				/* total bufcalls running */
+    bcinfo->usr_f = NULL;			/* for safety */
+
+    lis_bcfreel = bcinfo ;
+    bcinfo->next = (bcinfo_t *) lis_bcfreel ;
+
+}/*bc_ulink*/
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+/* lis_bufcall - schedule recovery from alloc failure
+ *
+ */
+int 
+lis_bufcall(unsigned size, int priority, void (*function)(long), long arg)
+{
+    LisUpCount(BUFCALLS) ;			/* stats array */
+    (void)priority;
+    if (!function)
+    {
+	LisUpFailCount(BUFCALLS) ;		/* stats array */
+	LisDownCount(BUFCALLS) ;		/* stats array */
+	return(0);
+    }
+
+    return(bc_link(size,function,arg));
+
+}/*lis_bufcall*/
+
+
+/*  -------------------------------------------------------------------  */
+/* esbbcall - like bufcall, but for lis_esballoc. The function
+ *	will be called when there is a `good chance' that the
+ *	lis_esballoc will succeed.
+ */
+int 
+lis_esbbcall(int priority, void (*function)(long), long arg)
+{
+    LisUpCount(BUFCALLS) ;			/* stats array */
+    (void)priority;
+    if (!function)
+    {
+	LisUpFailCount(BUFCALLS) ;		/* stats array */
+	LisDownCount(BUFCALLS) ;		/* stats array */
+	return(0);
+    }
+
+    return(bc_link(ESB_SIZE,function,arg));
+
+}/*lis_esbbcall*/
+
+/*  -------------------------------------------------------------------  */
+/* unbufcall - cancels a bufcall/esbbcall
+ *
+ */
+void
+lis_unbufcall(int bcid)
+{
+    bcinfo_t	*bcinfo ;
+    bclist_t	*list ;
+    int		 psw;
+
+    /*
+     * Unfortunately, the table has to be searched with interrupts
+     * disabled to prevent the list from moving while we are
+     * searching it.  We have to keep interrupts off until we have
+     * removed the entry from the list in case of a second call on
+     * unbufcall for the same element.
+     *
+     * The good news is that we have "hashed" the table fairly
+     * broadly so we really cut down on the iteration count here.
+     */
+    list = (bclist_t *) &lis_bchash[bcid & BCHASH_MSK] ;
+    SPLSTR(psw);				/* delink from bcall list */
+
+    for (bcinfo = list->first; bcinfo != NULL; bcinfo = bcinfo->next)
+    {
+	if (bcinfo->id == bcid)
+	    break ;
+    }
+
+    if (bcinfo == NULL)
+    {
+	SPLX(psw) ;
+	return ;		/* not in list */
+    }
+
+    bc_ulink(bcinfo);				/* remove from list */
+    SPLX(psw) ;
+
+    LisDownCount(BUFCALLS) ;			/* stats array */
+
+}/*lis_unbufcall*/
+
+/*  -------------------------------------------------------------------  */
+/* process a bufcall: remove it from the list call the event handler free up
+ * space associated with used item else put event on back of list 
+ *
+ * Leave the timer running flag set until we process all the bufcalls.
+ * Any new ones will get noticed at the end of the routine and we will
+ * restart the timer if need be.
+ */
+void
+lis_dobufcall(void)
+{
+    int			 cnt;
+    int			 i ;
+    int			 psw;
+    bclist_t		*list ;
+    struct bcinfo	*bc;
+    void	       (*fcn)(long);
+    long		 arg ;
+
+    for (i = 0; lis_bc_cnt != 0 && i < N_BCHASH; i++)
+    {
+	list = (bclist_t *) &lis_bchash[i] ;
+
+	/*
+	 * Drive this loop with the count of the number of elements,
+	 * not a linked-list walk.  The list may change as we process
+	 * it.  New entries go on the end.  We remove entries from
+	 * the front.  In that way we will process the older entries.
+	 */
+	for (cnt = list->n_elts; cnt > 0; cnt--)
+	{
+	    SPLSTR(psw);		/* intrs off while delink from list */
+	    bc = list->first ;
+	    if (bc == NULL)		/* should not be the case */
+		continue ;		/* but skip anyway */
+
+	    fcn = bc->usr_f ;
+	    arg = bc->usr_arg ;
+	    bc_ulink(bc);		/* remove from list */
+	    SPLX(psw) ;
+
+	    if (fcn != NULL)		/* cheap insurance */
+		(*fcn)(arg) ;		/* call user function */
+
+	    LisDownCount(BUFCALLS) ;	/* stats array */
+	}
+    }
+
+    lis_strbcflag = 0 ;			/* don't do bufcalls yet */
+    lis_strbctimer = 0 ;		/* timer not running */
+    SPLSTR(psw);
+    if (lis_bc_cnt != 0 && lis_strbctimer == 0)
+    {					/* more bufcalls to do */
+	lis_strbctimer = 1 ;
+	SPLX(psw) ;
+	lis_tmout(&lis_bctl, bc_timeout, 0, BUFCALL_N_TICKS) ;
+    }
+    else
+	SPLX(psw) ;
+}
+
+/*  -------------------------------------------------------------------  */
+/* init the bufcall table
+ */
+void
+lis_init_bufcall(void)
+{
+    int			 i ;
+    int			 psw;
+    bclist_t		*list ;
+
+    /*
+     * With interrupts off so the list can't be disturbed, delink all
+     * elements from the bufcall lists.
+     */
+    SPLSTR(psw);
+    for (i = 0; i < N_BCHASH; i++)
+    {
+	list = (bclist_t *) &lis_bchash[i] ;
+	while (list->first != NULL)
+	{
+	    bc_ulink(list->first);		/* remove from list */
+	    LisDownCount(BUFCALLS) ;		/* stats array */
+	}
+
+	list->n_elts = 0 ;
+    }
+
+    lis_bc_cnt = 0 ;				/* total bufcalls running */
+
+    SPLX(psw) ;
+    lis_strbcflag = 0 ;
+    lis_strbctimer = 0 ;
+}
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/cmn_err.c /usr/src/linux/drivers/streams/LiS/head/cmn_err.c
--- debug/drivers/streams/LiS/head/cmn_err.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/cmn_err.c	Mon Dec 16 16:36:37 1996
@@ -0,0 +1,62 @@
+/************************************************************************
+*                           cmn_err                                     *
+*************************************************************************
+*									*
+* This is the UNIX common-error message routine.			*
+*									*
+* For now we will simply turn this into a printk().  Later we can	*
+* add some putbuf code.							*
+*									*
+* Author:	David Grothe	<dave@gcom.com>				*
+*									*
+************************************************************************/
+
+#include <sys/strport.h>
+#include <sys/cmn_err.h>
+#include <stdarg.h>
+#include <string.h>
+
+lis_print_trace_t      lis_print_trace;
+
+void	cmn_err(int err_lvl, char *fmt, ...)
+{
+    char	 buf[2048];
+    extern int	 vsprintf (char *, const char *, va_list);
+    va_list	 args;
+    char	*p ;
+
+    switch (err_lvl)
+    {
+    case CE_CONT:		/* continue printing */
+	buf[0] = 0 ;
+	break ;
+    case CE_NOTE:		/* NOTICE */
+	strcpy(buf, "\nNOTICE: ") ;
+	break ;
+    case CE_WARN:		/* WARNING */
+	strcpy(buf, "\nWARNING: ") ;
+	break ;
+    case CE_PANIC:		/* PANIC */
+	strcpy(buf, "\nPANIC: ") ;
+	break ;
+    default:
+	sprintf(buf, "\ncmn_err:  Called with invalid arguments (0x%lx, 0x%lx)\n",
+		(long) err_lvl, (long) fmt) ;
+	if ( lis_print_trace )
+	    (*lis_print_trace) (buf);
+	return ;
+    }
+
+    for (p = buf; *p; p++) ;
+
+    va_start (args, fmt);
+    vsprintf (p, fmt, args);
+    va_end (args);
+
+    if (err_lvl==CE_PANIC)
+	PANIC(buf);
+    else
+	if ( lis_print_trace )
+	    (*lis_print_trace) (buf);
+
+} /* cmn_err */
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/dki.c /usr/src/linux/drivers/streams/LiS/head/dki.c
--- debug/drivers/streams/LiS/head/dki.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/dki.c	Wed Jan  1 14:13:02 1997
@@ -0,0 +1,128 @@
+/************************************************************************
+*                      SVR4 Driver-Kernel Interface                     *
+*************************************************************************
+*									*
+* These routines implement an SVR4 compatible DKI.			*
+*									*
+* Author:	David Grothe <dave@gcom.com>				*
+*									*
+************************************************************************/
+
+#include <sys/stream.h>
+
+/************************************************************************
+*                       SVR4 Compatible timeout                         *
+*************************************************************************
+*									*
+* This implementation of SVR4 compatible timeout functions uses the	*
+* Linux timeout mechanism as the internals.				*
+*									*
+* The technique is to allocate memory that contains a Linux timer	*
+* structure and an SVR4-like handle.  We build up a list of these	*
+* structures in a linked-list headed by 'lis_tlist_head'.  We never	*
+* use handle zero, so that value becomes a marker for an available	*
+* entry.  We recycle the list elements as they expire or get untimeout-	*
+* ed.									*
+*									*
+************************************************************************/
+
+typedef struct tlist
+{
+    struct tlist	*next ;		/* thread of these */
+    struct timer_list	 tl ;		/* Linux timer structure */
+    int			 handle ;	/* SVR4-style handle */
+
+} tlist_t ;
+
+tlist_t		*lis_tlist_head ;	/* this list is no particular order */
+int		 lis_tlist_handle ;	/* next handle to use */
+
+/*
+ * "timeout" is #defined to be this function in dki.h.
+ */
+int	lis_timeout_fcn(timo_fcn_t *timo_fcn, caddr_t arg, long ticks,
+		    char *file_name, int line_nr)
+{
+    tlist_t	*tp ;
+    tlist_t	*found ;
+    int		 psw ;
+    int		 handle ;
+    int		 unique ;
+
+    unique = 0 ;
+    found = NULL ;
+    while (!unique)
+    {
+	SPLSTR(psw) ;				/* protect handle assgnmnt */
+	handle = ++lis_tlist_handle ;		/* next handle */
+	if (handle == 0)			/* prevent use of handle 0 */
+	    handle = ++lis_tlist_handle ;	/* next handle */
+	SPLX(psw) ;
+
+	unique = 1 ;				/* hopefully unique handle */
+	for (tp = lis_tlist_head; tp != NULL; tp = tp->next)
+	{						/* find one not-in use */
+	    if (tp->handle == handle) unique = 0 ;	/* handle not unique */
+	    SPLSTR(psw) ;				/* protect finding entry */
+	    if (   found == NULL
+		&& (   tp->handle == 0
+		    || (tp->tl.next == NULL && tp->tl.prev == NULL)
+		   )
+	       )
+	   {
+		tp->handle  = 0xFFFF ;		/* protect from "find" */
+		tp->tl.next = tp->tl.prev = &tp->tl ;
+		found = tp ;
+	   }
+	   SPLX(psw) ;
+	}					/* traverse entire list */
+    }
+
+    if (found == NULL)				/* must allocate a new one */
+    {
+	tp = (tlist_t *) LISALLOC(sizeof(*tp),file_name, line_nr) ;
+	if (tp == NULL) return(0) ;		/* no memory for timer */
+
+	SPLSTR(psw) ;				/* protect list insertion */
+	tp->next = lis_tlist_head ;
+	lis_tlist_head = tp ;
+	SPLX(psw) ;
+    }
+    else
+    {
+	tp = found ;				/* use found timer */
+	lis_mark_mem(tp, file_name, line_nr) ;
+    }
+
+    tp->handle = handle ;
+    lis_tmout(&tp->tl, (tmout_fcn_t *) timo_fcn, (long) arg, ticks) ;
+						/* use Linux */
+
+    return(tp->handle) ;			/* return handle */
+
+} /* lis_timeout_fcn */
+
+int	untimeout(int id)
+{
+    tlist_t	*tp ;
+    int		 psw ;
+
+    for (tp = lis_tlist_head; tp != NULL; tp = tp->next)
+    {						/* find one not-in use */
+	if (tp->handle == id)			/* is this our timer?  */
+	{
+	    SPLSTR(psw) ;			/* protect untimout */
+	    lis_mark_mem(tp, "unused", MEM_TIMER) ;
+	    if (tp->tl.next != NULL || tp->tl.prev != NULL)
+		lis_untmout(&tp->tl) ;		/* stop it */
+
+	    tp->handle = 0 ;			/* make available */
+	    SPLX(psw) ;
+	    break ;				/* done */
+	}
+    }
+
+    return(0);					/* no rtn value specified */
+
+} /* untimeout */
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/errmsg.c /usr/src/linux/drivers/streams/LiS/head/errmsg.c
--- debug/drivers/streams/LiS/head/errmsg.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/errmsg.c	Mon Dec 16 16:36:37 1996
@@ -0,0 +1,105 @@
+/*                               -*- Mode: C -*- 
+ * errmsg.h --- streams error messages
+ * Author          : Francisco J. Ballesteros
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: Francisco J. Ballesteros
+ * Last Modified On: Tue Sep 26 15:18:21 1995
+ * Update Count    : 3
+ * RCS Id          : $Id: errmsg.c,v 1.2 1995/12/27 01:02:20 dave Exp $
+ * Usage           : see below :)
+ * Required        : see below :)
+ * Status          : ($State: Exp $) complete, untested, compiled
+ * Prefix(es)      : lis
+ * Requeriments    : 
+ * Purpose         : provide streams errmsg
+ *                 : 
+ * ----------------______________________________________________
+ *
+ *    Copyright (C) 1995  Francisco J. Ballesteros, Denis Froschauer
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    nemo@ordago.uc3m.es, 100741.1151@compuserve.com
+ */
+
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#include <sys/strport.h>
+#include <stdarg.h>
+#include <sys/strconfig.h>	/* config definitions */
+#include <sys/LiS/share.h>	/* generid defs */
+#include <sys/LiS/errmsg.h>	/* module interface */
+
+/*  -------------------------------------------------------------------  */
+/*				    Types                                */
+
+/*  -------------------------------------------------------------------  */
+/*				 Glob. Vars.                             */
+
+/*  -------------------------------------------------------------------  */
+/*			       Local functions                           */
+
+
+/* This will just panic
+ */
+static void
+lis_do_panic(char *msg)
+{
+    PANIC(msg);
+}/*lis_do_panic*/
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+
+/* This function will report a msg w/ the error condition and take appropriate
+ * actions depending on the error level. 
+ * actions will be:
+ * LIS_PANIC: issue a panic msg and panic the kernel
+ * LIS_ERROR: issue an error.
+ * LIS_WARN:  issue a warning msg.
+ * LIS_DEBUG: issue a debug msg.
+ * msg will be formatted like in: 
+ *      "some_msg_prefix (your_function_name): fmt_msg\n"
+ */
+
+void
+lis_error( int lvl, const char *fname, const char * fmt, ...)
+{
+	char buf[1024];
+	char *fmtmsg;
+	extern int vsprintf (char *, const char *, va_list);
+	va_list args;
+	sprintf(buf,"LiS %s (%s):",lis_errmsg(lvl),(fname?fname:"unknown"));
+	for(fmtmsg=buf; *fmtmsg; fmtmsg++)
+	    ;
+	va_start (args, fmt);
+	vsprintf (fmtmsg, fmt, args);
+	va_end (args);
+	if (lvl==LIS_PANIC)
+	    lis_do_panic(buf);
+	else
+	    PRINTK("%s\n",buf);
+}/*lis_error*/
+
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/events.c /usr/src/linux/drivers/streams/LiS/head/events.c
--- debug/drivers/streams/LiS/head/events.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/events.c	Wed Jan  1 14:13:02 1997
@@ -0,0 +1,203 @@
+/*                               -*- Mode: C -*- 
+ * events.c --- streams events
+ * Author          : Francisco J. Ballesteros
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: events.c,v 1.3 1996/01/10 16:48:04 dave Exp $
+ * Purpose         : provide streams events
+ *                 : 
+ * ----------------______________________________________________
+ *
+ *    Copyright (C) 1995   Francisco J. Ballesteros, Denis Froschauer
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to
+ *    nemo@ordago.uc3m.es, 100541.1151@compuserve.com
+ */
+
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#include <sys/strport.h>
+#include <sys/strconfig.h>	/* config definitions */
+#include <sys/LiS/share.h>	/* streams shared defs*/
+#include <sys/LiS/events.h>		/* module interface */
+
+/*  -------------------------------------------------------------------  */
+/*			   Local functions & macros                      */
+
+/*  -------------------------------------------------------------------  */
+/*				  Glob. Vars                             */
+
+struct strevent *lis_sefreelist; /* list of free stream events */
+struct strevent *lis_secachep;   /* reserve store of free stream events */
+
+#if 0
+/* see long comment in header --nemo*/
+struct strinfo lis_strinfo[]; /* keeps track of allocated events	*/
+#endif
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+/* The event list is implemented with a pointer to an event node.
+ * the list will have a dummy node at head where next & prev will be used
+ * as pointers to first and last of the list.  The list is linked circularly,
+ * such that the next of the last element points to the first element.
+ * The list is sorted by pid.
+ * Every events for the same pid are in the same strevent node.
+ * When last event is removed the node will be freed.
+ *
+ * It would be better to use a hash w/ ovf lists table. --nemo.
+ */
+
+
+/* get events for pid in list
+ */
+short
+lis_get_elist_ent( strevent_t *list, pid_t pid )
+{
+    strevent_t *ev = NULL;
+
+    /* should think what kind of search is faster: fwd, bck, sorted,...*/
+    if (list == NULL) return(0) ;
+
+    for(ev = list->se_next ; ev != list && ev->se_pid < pid; ev=ev->se_next )
+	;
+    if (ev != list && ev->se_pid == pid)
+	return(ev->se_evs);
+    else
+	return(0);
+}/*lis_get_elist_ent*/
+
+/*  -------------------------------------------------------------------  */
+
+/* add event to list
+ */
+int
+lis_add_to_elist( strevent_t **list, pid_t pid, short events )
+{
+    strevent_t *ev = NULL;
+
+    if (*list != NULL)
+    {
+	for (ev=(*list)->se_next;
+	     ev != *list && ev->se_pid < pid;
+	     ev=ev->se_next
+	    );    
+    }
+
+    if (ev == NULL || ev == *list)		/* no slot for pid in list */
+    {
+	if ((ev = (strevent_t*)ALLOCF(sizeof(strevent_t),"event "))==NULL)
+	    return(-ENOMEM);
+
+	if (!*list)			/* create dummy head node */
+	{
+	    strevent_t *hd;
+	    if ((hd = (strevent_t*)ALLOCF(sizeof(strevent_t),"event-head ")
+					 )==NULL)
+	    {
+		FREE(ev);
+		return(-ENOMEM);
+	    }
+	    (*list=hd)->se_pid=0;
+	    hd->se_next=hd->se_prev=hd;		/* empty list */
+	}
+
+	/* link node last in the list */
+	ev->se_prev=(*list)->se_prev;
+	(*list)->se_prev->se_next=ev;
+	((*list)->se_prev=ev)->se_next=*list;
+
+	ev->se_pid=pid;
+	ev->se_evs=0;
+    }
+    else if (ev->se_pid!=pid){	/* link node in the middle of the list */
+	strevent_t *new;
+	if ((new = (strevent_t*)ALLOCF(sizeof(strevent_t),"event "))==NULL){
+	    return(-ENOMEM);
+	}
+	new->se_prev=ev->se_prev;
+	new->se_next=ev;
+	ev->se_prev->se_next=new;
+	ev->se_prev=new;
+	ev = new ;				/* use new element */
+	ev->se_pid=pid;
+	ev->se_evs=0;
+    }
+    ev->se_evs|=events;
+    return(0);
+}/*lis_add_to_elist*/
+
+/*  -------------------------------------------------------------------  */
+
+/* del event from list
+ * rets non-zero if not-found
+ */
+int
+lis_del_from_elist( strevent_t **list, pid_t pid, short events )
+{
+    strevent_t *ev = NULL;     
+
+    if (*list != NULL)
+    {
+	for (ev=(*list)->se_next;
+	     ev != *list && ev->se_pid < pid;
+	     ev=ev->se_next
+	    );    
+    }
+
+    if (ev == NULL || ev == *list || ev->se_pid != pid )
+	return(1);
+
+    if ( (ev->se_evs &= ~events) == 0 ){	/* unlink */
+	if (ev->se_next)			/* should always be true */
+	    ev->se_next->se_prev=ev->se_prev;
+	if (ev->se_prev)			/* should always be true */
+	    ev->se_prev->se_next=ev->se_next;
+	FREE(ev);
+    }
+    return(0);
+}/*lis_del_from_elist*/
+
+/*  -------------------------------------------------------------------  */
+/* Free the entire elist
+ */
+void
+lis_free_elist( strevent_t **list )
+{
+    strevent_t  *ev;     
+    strevent_t	*nxt ;
+
+    for (ev = *list; ev != NULL; )
+    {
+	nxt = ev->se_next ;
+	FREE(ev) ;
+	ev = nxt ;
+	if (ev == *list) break ;		/* all done */
+    }
+
+    *list = NULL ;
+
+}/*lis_free_elist*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/head.c /usr/src/linux/drivers/streams/LiS/head/head.c
--- debug/drivers/streams/LiS/head/head.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/head.c	Wed Jan  1 14:13:02 1997
@@ -0,0 +1,4523 @@
+/*                               -*- Mode: C -*- 
+ * head.c --- LiS stream head processing
+ * Author          : Graham Wheeler, Francisco J. Ballesteros
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: David Grothe <dave@gcom.com>
+ * RCS Id          : $Id: head.c,v 1.25 1996/01/29 18:12:19 dave Exp $
+ * Purpose         : stream head processing stuff
+ * ----------------______________________________________________
+ *
+ *
+ *    Copyright (C) 1995  Graham Wheeler, Francisco J. Ballesteros,
+ *                        Denis Froschauer
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    gram@aztec.co.za, nemo@ordago.uc3m.es, 100741.1151@compuserve.com
+ */
+
+
+/* BEWARE: should check:
+ * tty stuff
+ */
+
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+
+/* LiS implementation modules used */
+
+#include <sys/stream.h>
+#include <sys/poll.h>
+#include <sys/LiS/errmsg.h>
+#include <string.h>
+
+
+/*  -------------------------------------------------------------------  */
+/*				   Symbols                               */
+
+/* min. size for head allocated msgs
+ */
+#define MIN_USR_MSG	64
+
+/*  -------------------------------------------------------------------  */
+/*				  Glob. Vars                             */
+
+/* Scheduling  & scan list
+ */
+struct queue	*lis_qhead; /* first scheduled queue	*/
+struct queue	*lis_qtail; /* last scheduled queue		*/
+struct queue	*lis_scanqhead;	/* head of STREAMS scan queue	*/
+struct queue	*lis_scanqtail;	/* tail of STREAMS scan queue	*/
+int		 lis_queues_running ;	/* queues are being run now */
+
+int		 lis_nstrpush;	/* maximum # of pushed modules */
+int		 lis_strhold;	/* if not zero str hold feature's activated*/
+unsigned long    lis_strthresh;	/* configurable STREAMS memory limit */
+unsigned long    lis_iocseq;	/* ioctl id */
+stdata_t	*lis_stdata_head ;	/* list of stdata structures */
+long		 lis_stdata_cnt ;	/* counts stdata structs in use */
+long		 lis_open_cnt ;	/* count opens */
+long		 lis_close_cnt ;/* count closes */
+
+extern long	 lis_max_mem ;		/* maximum to allocate */
+extern long	 lis_max_msg_mem ;	/* maximum to allocate */
+
+/*  -------------------------------------------------------------------  */
+/*			   Streams Queue Structures                      */
+/*
+ * The stream head itself acts as a streams driver (sort-of).  So
+ * it needs to have qinit structures just like other drivers.
+ *
+ * TBD:  We need a better way to set low and high water marks.
+ * TBD:  Also packet sizes.
+ */
+extern void	lis_strrput(queue_t *q, mblk_t *mp) ;
+extern void	lis_strwsrv(queue_t *q) ;
+
+struct module_info	strmhd_rdminfo =
+		{0			/* mi_idnum */
+		,"str_rput"		/* mi_idname */
+		,LIS_MINPSZ		/* mi_minpsz */
+		,LIS_MAXPSZ		/* mi_maxpsz */
+		,0xFFFF			/* mi_hiwat */
+		,0xF000			/* mi_lowat */
+		} ;
+
+struct module_info	strmhd_wrminfo =
+		{0			/* mi_idnum */
+		,"str_wput"		/* mi_idname */
+		,LIS_MINPSZ		/* mi_minpsz */
+		,LIS_MAXPSZ		/* mi_maxpsz */
+		,0xFFFF			/* mi_hiwat */
+		,0xF000			/* mi_lowat */
+		} ;
+
+struct qinit	strmhd_rdinit =
+		{lis_strrput		/* qi_putp */
+		,NULL			/* qi_srvp */
+		,NULL			/* qi_qopen */
+		,NULL			/* qi_qclose */
+		,NULL			/* qi_qadmin */
+		,&strmhd_rdminfo	/* qi_minfo */
+		,NULL			/* qi_mstat */
+		} ;
+
+struct qinit	strmhd_wrinit =
+		{NULL			/* qi_putp */
+		,&lis_strwsrv		/* qi_srvp */
+		,NULL			/* qi_qopen */
+		,NULL			/* qi_qclose */
+		,NULL			/* qi_qadmin */
+		,&strmhd_wrminfo	/* qi_minfo */
+		,NULL			/* qi_mstat */
+		} ;
+
+/*  -------------------------------------------------------------------  */
+/*			   Local functions & macros                      */
+
+/*  -------------------------------------------------------------------  */
+
+extern void lis_runqueues(void);
+static void lis_qdetach(queue_t *q, int do_close, int flag, cred_t *creds) ;
+extern int  lis_wakeup_close(caddr_t arg) ;
+static int  lis_strdoioctl(struct file *f, stdata_t *hd,
+			    strioctl_t *ioc, cred_t *creds,
+			    int do_copyin) ;
+static int  lis_doclose(struct inode *i,struct file *f,
+			struct stdata *head, cred_t *creds) ;
+static void free_stdata( struct stdata *hd ) ;
+static void lis_deallocate_polllist( stdata_t *hd ) ;
+
+/*  -------------------------------------------------------------------  */
+/*                          lis_bzero					 */
+void	lis_bzero(void *ptr, int cnt)
+{
+    char	*p = (char *) ptr ;
+
+    while (cnt-- > 0) *p++ = 0 ;
+}
+
+
+/*  -------------------------------------------------------------------  */
+/*                              str_mux_cycle				 */
+
+#if 0
+	This whole mux-cycle business, as I see it, is completely
+	artificial.  In order to construct a cycle you would have
+	to do something like the following:
+
+	    ioctl(fd2, I_LINK, fd3) ;		2-->3
+	    ioctl(fd1, I_LINK, fd2) ;		1-->2-->3
+	    ioctl(fd3, I_LINK, fd1) ;		3-->1-->2-->3 (cycle)
+
+	However, you can''t do this because the third ioctl will
+	fail.  fd3 has its STPLEX flag set so the ioctl is disallowed.
+
+	--DMG
+
+/* returns non-zero if the given link leads to cyclic graph
+ */
+static int str_mux_cycle(stdata_t *from, stdata_t *to)
+{
+    (void)from;
+    (void)to;
+    return(0);			/* no graph detection */
+}
+#endif
+
+/*  -------------------------------------------------------------------  */
+/* 
+ * Link the muxed stream under hd.  Return the l_index value.
+ * 
+ */
+static int
+str_link_mux( stdata_t *hd, stdata_t *muxed, int cmd)
+{
+    muxed->sd_mux.mx_cmd   = cmd ;	/* save cmd used to link */
+    muxed->sd_mux.mx_index = ++hd->sd_l_index ;
+    muxed->sd_mux.mx_next  = hd->sd_mux.mx_hd ;
+
+    hd->sd_mux.mx_hd = muxed ;
+
+    return(muxed->sd_mux.mx_index) ;
+
+}/*str_link_mux*/
+
+
+/*  -------------------------------------------------------------------  */
+/* 
+ * This routine unlinks the given multiplexor from the given
+ * stream head.  It returns >= 0 for success, < 0 for failure.
+ *
+ * Any mux's below hd whose reference count is currently 1 will
+ * be closed.  For any such mux's we recursively unlink any mux's
+ * below those.
+ *
+ * We do not close hd.  We decrement its ref cnt if the command
+ * is I_PUNLINK.
+ */
+static  int
+lis_i_unlink(struct inode	*i,
+	     struct file	*f,
+	     stdata_t		*hd,
+	     int		 l_index,
+	     int		 cmd,
+	     cred_t		*creds)
+{
+    stdata_t		 *hp ;
+    stdata_t		 *prev;
+    stdata_t		 *next;
+    strioctl_t		  ioc;
+    linkblk_t		  lnk;
+    int			  err ;
+    int			  rtn = 0 ;
+
+    for (hp = hd->sd_mux.mx_hd, prev = NULL, next = NULL; 
+	 hp != NULL; 
+	 hp = next)
+    {
+	next = hp->sd_mux.mx_next ;		/* link to next stream */
+
+	if (l_index >= 0 && hp->sd_mux.mx_index != l_index)
+	{
+	    prev = hp ;
+	    continue ;				/* skip this one */
+	}
+
+	if (cmd == I_UNLINK && hp->sd_mux.mx_cmd == I_PLINK)
+	{
+	    prev = hp ;
+	    continue ;				/* skip this one */
+	}
+
+	/*
+	 * Get permission from driver before unlinking
+	 */
+	lnk.l_qtop   = hd->sd_wq;
+	lnk.l_qbot   = hp->sd_wq;
+	lnk.l_index  = hp->sd_mux.mx_index ;
+
+			    /* note I_UNLINK vs I_PLINK eliminated above */
+	if (hp->sd_mux.mx_cmd == I_LINK)
+	    ioc.ic_cmd = I_UNLINK ;		/* linked w/I_LINK */
+	else
+	    ioc.ic_cmd = I_PUNLINK;		/* linked w/I_PLINK */
+
+	ioc.ic_timout= LIS_LNTIME;
+	ioc.ic_len   = sizeof(linkblk_t);
+	ioc.ic_dp    = (char*)&lnk;
+	if (   (err = lis_strdoioctl(f,hd,&ioc,creds,0)) < 0
+	    && cmd == I_UNLINK			/* ignore errs for I_PUNLINK */
+	   )
+	{
+	    rtn = err ;				/* will return error */
+	    if (l_index < 0)			/* OK, skip this one */
+	    {					/* lose the memory?? */
+		prev = hp ;
+		continue ;
+	    }
+
+	    return(rtn);			/* can't unlink */
+	}
+
+	if (hd->sd_mux.mx_hd == hp)		/* delinking elt at hd */
+	    hd->sd_mux.mx_hd = hp->sd_mux.mx_next ;
+	else					/* delinking elt down in list */
+	    prev->sd_mux.mx_next = hp->sd_mux.mx_next ;
+
+	hp->sd_mux.mx_next = NULL ;		/* clobber link */
+
+	if ( LIS_DEBUG_IOCTL || LIS_DEBUG_LINK )
+	{
+	  printk(
+	      "strioctl: I_UNLINK: ctl stream %s%s muxid=%d\n",
+		    lis_strm_name(hd), lis_maj_min_name(hd),
+		    lnk.l_index) ;
+	  printk(
+	      "                    l_qtop=\"%s\" l_qbot=\"%s%s\"->\"%s\"\n",
+		    lis_queue_name(lnk.l_qtop),
+		    lis_strm_name(hp), lis_maj_min_name(hp),
+		    lis_queue_name(hp->sd_wq->q_next)) ;
+	}
+
+						/* restore queues */
+	lis_setq(RD(hp->sd_wq), &strmhd_rdinit, &strmhd_wrinit);
+	WR(hp->sd_wq)->q_ptr	= hp ;		/* point q back to strm hd */
+	RD(hp->sd_wq)->q_ptr	= hp ;		/* assume mux used these ptrs */
+
+	if (   hp->sd_mux.mx_cmd == I_PLINK	/* was linked w/I_PLINK */
+	    && hd->sd_refcnt > 0		/* safety first */
+	   )
+       {
+	    hd->sd_refcnt--;			/* decr ref count of head */
+	    hd->sd_linkcnt-- ;			/* one less link for head */
+       }
+
+	hp->sd_linkcnt-- ;			/* one less I_LINK */
+	F_CLR(hp->sd_flag,STPLEX);		/* no longer multiplexed */
+	if (hp->sd_refcnt == 1)			/* about to close */
+	{
+	    /*
+	     * Close the lower stream.  The close routine may recurse
+	     * on lis_i_unlink() if the lower stream is itself the
+	     * control stream of a multiplexor.
+	     */
+	    lis_doclose(i, f, hp, creds) ;		/* close lower mux */
+	}
+	else
+	if (hp->sd_refcnt > 1)			/* be safe */
+	    hp->sd_refcnt-- ;			/* decr ref cnt */
+
+	if (l_index >= 0) break ;		/* done */
+    }
+
+    return(rtn) ;
+
+} /* lis_i_unlink */
+
+/*  -------------------------------------------------------------------  */
+/* lis_i_link
+ *
+ * Called from strioctl to perform the I_LINK (I_PLINK) function.
+ *
+ * Note about I_PLINK:  This causes the refcnt of the top stream
+ * to be incremented so that a close of that stream will not cause
+ * the stream to be deallocated and the multiplexor dismantled.
+ * However, if the stream does get closed then the stdata structure
+ * will be laying around in memory with refcnt==1 and nothing holding
+ * onto it.  It will be their until the next reboot.  Hopefully,
+ * this multiplexor can take care of itself until then.
+ */
+int	lis_i_link(struct inode	*i,
+		   struct file	*f,
+		   stdata_t	*hd,
+		   int		 muxfd,
+		   int		 cmd,
+		   cred_t	*creds)
+{
+    stdata_t		*muxed;
+    linkblk_t		 lnk;
+    strioctl_t		 ioc;
+    int			 err ;
+
+#define	RTN(v)		{lis_unlock_wopen(hd); return(v); }
+
+    err = lis_lock_wopen(hd);
+    if (err < 0) RTN(err) ;
+
+    if ( (muxed = lis_fd2str(muxfd)) == NULL )
+	RTN(-EINVAL);
+
+    lnk.l_qtop = hd->sd_wq;
+    lnk.l_qbot = muxed->sd_wq;
+    lnk.l_index= str_link_mux(hd, muxed, cmd);
+
+    if ( LIS_DEBUG_IOCTL || LIS_DEBUG_LINK )
+    {
+	printk("strioctl: I_LINK: ctl stream %s%s l_index=%d\n",
+		lis_strm_name(hd), lis_maj_min_name(hd),
+		lnk.l_index) ;
+	printk("                  l_qtop=\"%s\" l_qbot=\"%s%s\"->\"%s\"\n",
+		lis_queue_name(lnk.l_qtop),
+		lis_strm_name(muxed), lis_maj_min_name(muxed),
+		lis_queue_name(muxed->sd_wq->q_next)
+		) ;
+    }
+
+    lis_setq(LIS_RD(muxed->sd_wq),
+	     hd->sd_strtab->st_muxrinit, hd->sd_strtab->st_muxwinit);
+
+    ioc.ic_cmd	 = I_LINK;
+    ioc.ic_timout= LIS_LNTIME;
+    ioc.ic_len	 = sizeof(linkblk_t);
+    ioc.ic_dp	 = (char*)&lnk;
+    if ((err = lis_strdoioctl(f,hd,&ioc,creds,0)) < 0)
+    {
+	lis_setq(LIS_RD(muxed->sd_wq),		/* put back old queues */
+	     hd->sd_strtab->st_rdinit, hd->sd_strtab->st_wrinit);
+
+	lis_i_unlink(i, f, hd, lnk.l_index,
+		     cmd == I_LINK ? I_UNLINK : I_PUNLINK, creds);
+	RTN(err);
+    }
+
+    F_SET(muxed->sd_flag,STPLEX);
+    muxed->sd_refcnt++;			/* so a close won't deallocate */
+    muxed->sd_linkcnt++ ;		/* one more I_LINK */
+
+    if (muxed->sd_mux.mx_cmd==I_PLINK)	/* linked w/I_PLINK */
+    {
+	hd->sd_refcnt++;		/* so a close won't deallocate */
+	hd->sd_linkcnt++ ;		/* count that as a link */
+    }
+
+    lis_unlock_wopen(hd); 		/*wake procs in head*/
+    return(lnk.l_index);
+
+#undef RTN
+
+} /* lis_i_link */
+
+
+/*  -------------------------------------------------------------------  */
+/* detach queues from stream and free the stream
+ */
+static void lis_dismantle(stdata_t *hd, cred_t *creds)
+{
+    queue_t	*q ;
+
+    if (hd->sd_wq != NULL)			/* still have strm head queue */
+    {
+	q = LIS_RD(hd->sd_wq) ;
+	LisDownCounter(MSGQDSTRHD, lis_qsize(q)) ;
+	lis_qdetach(q, 0, 0, creds);
+	hd->sd_wq = NULL ;
+    }
+
+    free_stdata( hd ) ;				/* free the stdata structure */
+}
+
+
+/*  -------------------------------------------------------------------  */
+
+/* set read options
+ */
+static int
+set_readopt(int *flags, int rmode)
+{
+    long oflags=*flags;
+
+    switch(rmode & RMODEMASK){
+    case RNORM:
+    case RMSGD:
+    case RMSGN:
+	*flags &= ~RMODEMASK ;			/* clear mode bits */
+	*flags |= (rmode & RMODEMASK) ;		/* set mode */
+	break;
+    default:
+	*flags=oflags;				/* restore original */
+	return(-EINVAL);
+    }
+
+    switch(rmode & RPROTMASK){
+    case RPROTNORM:
+    case RPROTDAT:
+    case RPROTDIS:
+	*flags &= ~RPROTMASK ;			/* clear proto bits */
+	*flags |= (rmode & RPROTMASK) ;		/* set read proto mask */
+	break;
+    case 0:					/* not being set */
+	break;
+    default:
+	*flags=oflags;				/* restore original */
+	return(-EINVAL);
+    }
+
+    return(0);
+}
+
+/* These will let you know if you should block on rd/wr as dictated by the
+ * stream head and file flags. They should be called when the process should
+ * block due to no free space or no msg avail.
+ * Return non-zero if you shouldn't block and zero if you should do block 
+ */
+#define should_notblock_rd(hd,fp) (F_ISSET(fp->f_flags,O_NONBLOCK))
+
+#define should_notblock_wr(hd,fp)					\
+    (F_ISSET(fp->f_flags,O_NONBLOCK) && !F_ISSET(hd->sd_flag,OLDNDELAY))
+
+/*  -------------------------------------------------------------------  */
+
+/* Will add q to the scan list.  This happens as a result of the
+ * scanq timer expiring.
+ *
+ * One minor problem:  If the kernel is going to run the streams
+ * queues before returning from the timer interrupt then we are OK.
+ * If, however, it is up to us to run ourselves then we have two
+ * choices:
+ *	1) wait until some user process enters the kernel on streams business
+ *	2) run the queues here on top of the clock interrupt
+ * I don't like either choice.  It would be best of the kernel ran
+ * the streams queues from strategic places such as just before returning
+ * from interrupt processing and just before returning to user level.
+ *
+ * NOTE: STREAMS queues are run by waking up a process so that everything
+ *       is orderly. -- DMG
+ */
+static int 				/* 'int' to stop compiler squawking */
+add_to_scanl( caddr_t arg )
+{
+  int		 psw;
+  stdata_t	*hd = (stdata_t *) arg ;
+  queue_t	*q ;
+
+  /* We'll use a naive FIFO, this should be revisited
+   */
+  q = hd->sd_wq ;			/* stream head write queue */
+  hd->sd_scantimer = 0 ;		/* note that timer is not running */
+  SPLSTR(psw);
+  if (F_ISSET(q->q_flag,QSCAN)) {
+    SPLX(psw);
+    return(0);
+  }
+  if (lis_scanqtail) 
+    lis_scanqtail->q_scnxt = q;
+  else
+    lis_scanqhead = q;
+  q->q_scnxt=NULL;
+  lis_scanqtail=q;
+  F_SET(q->q_flag,QSCAN);
+  SPLX(psw);
+  return(0) ;
+
+}/*add_to_scanl*/
+
+static void
+start_scanl_timer(stdata_t *hd)
+{
+    if (hd->sd_scantimer == 0)
+	hd->sd_scantimer = lis_timeout_fcn(add_to_scanl,
+					   (caddr_t) hd,
+					   SECS_TO(LIS_RTIME),
+					   "scan-list", MEM_TIMER
+					   );  
+
+} /* start_scanl_timer */
+
+
+/*  -------------------------------------------------------------------  */
+/* Returns a pointer to the stream head in the i-node after allocating it.
+ * The head is locked upon return.
+ * The head structure can be reused on a second open call as soon
+ * as the inode is pointed to it (well, sort of).  This is really
+ * more multi-processor thinking at work here, but it is safe nevertheless.
+ */
+static stdata_t *
+alloc_stdata( struct inode *i)
+{
+    struct stdata *head ;
+    int		   err ;
+
+    head = (stdata_t*) ALLOCF(sizeof(stdata_t),"stream-head ");
+    if (head != NULL)			/* successful allocation */
+    {					/* initialize the structure */
+	lis_bzero(head, sizeof(*head)) ;	/* clear to zero */
+	head->magic=STDATA_MAGIC;
+	SEM_INIT(&head->sd_wopen, 1) ;	/* initialize open semaphore */
+	err = lis_lock_wopen(head);	/* P() it */
+	if (err < 0)			/* VERY busted */
+	{
+	    printk("aloc_stdata: error locking newly allocated queue\n") ;
+	    head->magic ^= 1 ;		/* clobbers the magic number */
+	    FREE(head) ;		/* free queue */
+	    return(NULL) ;		/* failed allocation */
+	}
+
+	INO_STR(i)     = head ;		/* now point inode to it */
+
+	SEM_INIT(&head->sd_wioc, 1) ;
+	SEM_INIT(&head->sd_wread, 0) ;		/* explicit init for emphasis */
+	SEM_INIT(&head->sd_wwrite, 0) ;		/* explicit init for emphasis */
+	SEM_INIT(&head->sd_wiocing, 0) ;	/* explicit init for emphasis */
+	SEM_INIT(&head->sd_closing, 0) ;	/* explicit init for emphasis */
+
+	head->sd_closetime	= LIS_CLTIME;
+
+	/*
+	 * Link sdtata structure into master list
+	 */
+	lis_stdata_cnt++ ;			/* count stdata structs */
+	if (lis_stdata_head == NULL)
+	{
+	    head->sd_next   = head ;
+	    head->sd_prev   = head ;
+	    lis_stdata_head = head ;
+	}
+	else
+	{
+	    head->sd_next = lis_stdata_head ;
+	    head->sd_prev = lis_stdata_head->sd_prev ;
+	    lis_stdata_head->sd_prev->sd_next = head ;
+	    lis_stdata_head->sd_prev = head ;
+	}
+    }
+
+    return(head) ;
+
+}/*alloc_stdata*/
+
+/*  -------------------------------------------------------------------  */
+/* Releases the stream head in the i-node
+ */
+static void
+free_stdata( struct stdata *hd )
+{
+
+    /* must assert here that every pointer in the stdata struct which
+     * may hold dynamic memory is NULL.
+     */
+    if (hd == NULL || hd->magic != STDATA_MAGIC) return ;
+
+    SEM_DESTROY(&hd->sd_wopen) ;	/* de-initialize the semaphores */
+    SEM_DESTROY(&hd->sd_wioc) ;
+    SEM_DESTROY(&hd->sd_wread) ;
+    SEM_DESTROY(&hd->sd_wwrite) ;
+    SEM_DESTROY(&hd->sd_wiocing) ;
+    SEM_DESTROY(&hd->sd_closing) ;
+
+    if (hd->sd_wmsg != NULL)
+    {
+	freemsg(hd->sd_wmsg) ;
+	hd->sd_wmsg = NULL ;
+    }
+
+    if (hd->sd_iocblk != NULL)
+    {
+	freemsg(hd->sd_iocblk) ;
+	hd->sd_iocblk = NULL ;
+    }
+
+    if (hd->sd_siglist != NULL)
+	lis_free_elist(&hd->sd_siglist);
+
+    lis_deallocate_polllist(hd) ;
+
+    if (hd->sd_filetbl != NULL)
+	FREE(hd->sd_filetbl) ;		/* free file table */
+
+    if (lis_stdata_head != NULL)
+    {
+	if (lis_stdata_head == hd)		/* deleting head element */
+	    lis_stdata_head = hd->sd_next ;	/* move down one */
+
+	if (lis_stdata_head == hd)		/* only element */
+	    lis_stdata_head = NULL ;		/* no more streams */
+	else					/* link around "hd" */
+	{
+	    hd->sd_prev->sd_next = hd->sd_next ;
+	    hd->sd_next->sd_prev = hd->sd_prev ;
+	}
+    }
+
+    hd->magic ^= 1 ;			/* clobbers the magic number */
+    FREE(hd) ;				/* give it back */
+    lis_stdata_cnt-- ;			/* count stdata structs */
+
+}/*free_stdata*/
+
+
+/*  -------------------------------------------------------------------  */
+
+/* Will check that inode & device are a proper STREAMS device
+ *
+ * Note:  This whole thing used to be a macro but the linker did
+ *        something strange to the code that caused it not to
+ *        work properly.  Making it into a procedure is an attempt
+ *        to do an end-run around this problem. - DMG
+ */
+#define CHECK_INO(i,n)	{						\
+			    int		rslt ;				\
+									\
+			    if ((rslt = lis_check_ino(i,n)) < 0)	\
+				return(rslt) ;				\
+			}
+
+int	lis_global_major ;
+int lis_check_ino(struct inode *i, char *msg)
+{
+    int		maj ;
+
+    if (!i)
+    { 					
+	lis_error(LIS_ERROR,msg,"called w/ null inode"); 	
+	return(-EBADF); 			
+    }						
+
+    if (!S_ISCHR(i->i_mode)) 			
+	return(-ENODEV);			
+
+    maj = STR_MAJOR(i->i_rdev) ;
+    lis_global_major = maj ;
+    if (!LIS_DEVOK(maj))	
+	return(-ENOTTY) ;
+
+    return(0) ;
+
+} /* lis_check_ino */
+
+/*  -------------------------------------------------------------------  */
+
+/* copyin the buffer shown in usr strbuf struct sb, into *m.
+ * As it's now it just copies the whole usr bufs to single blks.
+ */
+static  int
+copyin_msgpart( struct file *f, stdata_t *hd, mblk_t **m, char *sb )
+{
+    strbuf_t kbuf;
+    int err;
+
+    *m = NULL ;					/* NULL msg ptr by default */
+    if ((err=lis_check_umem(f,VERIFY_READ,sb,sizeof(strbuf_t)))<0)
+	return(err);
+
+    lis_copyin(f,&kbuf,sb,sizeof(strbuf_t));    	/* fetch the strbuf */
+
+    if (kbuf.len < 0 || kbuf.buf == NULL)	/* don't include this msg part */
+	return(0) ;				/* not an error */
+
+    if (   kbuf.len < (int)hd->sd_wq->q_next->q_minpsz
+	|| (   hd->sd_wq->q_next->q_maxpsz != INFPSZ
+	    && kbuf.len > (int)hd->sd_wq->q_next->q_maxpsz 
+	   )
+       )
+	return(-ERANGE);
+
+    if ( (*m=(mblk_t*)allocb(max(MIN_USR_MSG,kbuf.len),BPRI_LO))==NULL)
+	return(-ENOMEM);
+
+    if (kbuf.len>0) {
+	if ((err=lis_check_umem(f,VERIFY_READ,kbuf.buf,kbuf.len))<0)
+	    return(err);
+	lis_copyin(f,(*m)->b_wptr,kbuf.buf,kbuf.len);
+	(*m)->b_wptr+=kbuf.len;
+    }
+    return(0);
+}/*copyin_msgpart*/
+
+/*  -------------------------------------------------------------------  */
+/* copyin ctl & dat intro M_PROTO+M_DATA msg
+ */
+static int
+copyin_msg(struct file *f, stdata_t *hd,
+		mblk_t **m, strbuf_t *uctl, strbuf_t *udat)
+{
+    int err;
+    mblk_t *aux = NULL;
+
+    if (m == NULL) return(-EINVAL) ;
+
+    if ( uctl != NULL )
+    {
+	if ((err=copyin_msgpart(f,hd,m,(char*)uctl))<0)
+	    return(err);
+
+	if (*m != NULL)
+	    lis_btype(*m) = M_PROTO;
+    }
+    else
+	*m = NULL ;				/* no ctl msg part */
+
+    if ( udat != NULL )
+    {
+	if ((err=copyin_msgpart(f,hd,&aux,(char*)udat))<0)
+	{
+	    if (*m != NULL)
+		lis_freeb(*m);
+
+	    return(err);
+	}
+    }
+
+    if (*m == NULL && aux == NULL)		/* no message to send */
+	return(0) ;
+
+    if (*m != NULL && aux != NULL)		/* have 2 msgs to send */
+	lis_linkb(*m,aux);			/* link them */
+    else
+    if (*m == NULL)				/* have no ctl msg */
+	*m = aux ;				/* rtn just data msg */
+
+    return(0);
+	
+}/*copyin_msg*/
+
+/*  -------------------------------------------------------------------  */
+
+/* copyout part of msg.
+ * It will assume it's ctl and return MORECTL/MOREDATA if more data is left.
+ * msg won't be touched if !doit 
+ * this function doesn't free any block, just adjust b_[rw]ptr's
+ * is_ctl is true for the ctl part / false for the data part.
+ *
+ * 'm' can be NULL which means do not copy anything, but update
+ * the user's strbuf.
+ */
+static int
+copyout_msgpart( struct file *f, mblk_t *m,
+		    strbuf_t *sb, strbuf_t *usb, int is_ctl, int doit)
+{
+    int err;
+    int chunk ;
+    int mlen = 0 ;		/* # of bytes for ctl or dta part */
+    int maxlen = sb->maxlen;	/* how much the user wants */
+    int gotsome= 0 ;
+    int mtype ;
+
+    if (doit)			/* usb points to user space */
+    {				/* ensure writeable */
+	if (usb && (err=lis_check_umem(f,VERIFY_WRITE,usb,sizeof(strbuf_t)))<0)
+	  return(err);
+	if (maxlen >= 0 && (err=lis_check_umem(f,VERIFY_WRITE,sb->buf,maxlen))<0)
+	  return(err);
+    }
+    else			/* usb is in kernel space */
+    {				/* but sb->buf is in user space */
+	if (maxlen >= 0 && (err=lis_check_umem(f,VERIFY_WRITE,sb->buf,maxlen))<0)
+	  return(err);
+    }
+
+    for (sb->len=0;
+	 m != NULL && maxlen>0;
+	 maxlen-=chunk, sb->len+=chunk, m=m->b_cont)
+    {
+	chunk = 0 ;
+	mtype = lis_btype(m) ;
+	if (mlen == 0)					/* size not yet set */
+	{
+	    if (   (!is_ctl && mtype == M_DATA)		/* hit data msg */
+		|| ( is_ctl && mtype != M_DATA))	/* hit ctl msg */
+	    {
+		mlen = lis_xmsgsize(m);			/* set length */
+	    }
+
+	    if (mlen == 0) continue ;			/* hmmmm.... */
+	}
+
+	if (is_ctl && mtype == M_DATA)			/* hit data msg */
+	    break ;					/* quit */
+
+	if (!is_ctl && mtype != M_DATA)			/* non-data msg */
+	    continue ;					/* keep looking */
+
+	gotsome = 1 ;
+	chunk=min(maxlen,lis_mblksize(m));
+	lis_copyout(f,m->b_rptr,sb->buf,chunk);
+	if (doit)
+	  lis_adjmsg(m,chunk);
+    }					/*for blk*/
+
+    err = 0 ;				/* return value */
+    if (gotsome)			/* got some bytes from msg */
+    {
+	if (sb->len < mlen)		/* less than what was in msg */
+	    err = (is_ctl?MORECTL:MOREDATA);
+    }
+    else
+	sb->len = -1 ;			/* no blocks of that type */
+
+    if (doit)
+    {
+	if (usb != NULL)
+	    lis_copyout(f,sb,usb,sizeof(strbuf_t));
+    }
+    else
+	*usb = *sb ;			/* update kernels rtn structure */
+
+    return(err);
+
+}/*copyout_msgpart*/
+
+/*  -------------------------------------------------------------------  */
+/* copyout msg to usr buffers given by ctl & dta.
+ * m should be a proto+data msg.
+ * this function doesn't free any block, just adjust b_[rw]ptr's
+ * msg won't be touched if !doit 
+ */
+static int
+copyout_msg( struct file *f, mblk_t *m, strbuf_t *kctl, strbuf_t *kdta,
+	     strbuf_t *uctl, strbuf_t *udta, int doit)
+{
+    int errctl,errdta;
+    if ((errctl=copyout_msgpart(f,m,kctl,uctl,1,doit))<0)
+	return(errctl);
+    else if ((errdta=copyout_msgpart(f,m,kdta,udta,0,doit))<0)
+	return(errdta);
+    return(errctl|errdta);
+}/*copyout_msg*/
+
+/*  -------------------------------------------------------------------  */
+
+/* Do we have streams resources?
+ */
+   
+static int
+stravail(struct file *fp)
+{
+    (void) fp ;
+    return(1) ;
+}
+
+/*  -------------------------------------------------------------------  */
+/*Returns non-zero if we should hold msg on write at the stream head.
+ */
+#define strholding(sd)	(lis_strhold && F_ISSET((sd)->sd_flag,STRHOLD))
+
+/*  -------------------------------------------------------------------  */
+
+
+/*  -------------------------------------------------------------------  */
+/* qdetach - unlink queue from stream, close driver/module, and free queue
+ */
+static void 
+lis_qdetach(queue_t *q, int do_close, int flag, cred_t *creds)
+{
+    int		psw ;
+    int		i ;
+    const char	*name = NULL;
+    queue_t	*downstrm_wrq ;
+    queue_t	*downstrm_rdq ;
+    queue_t	*upstrm_rdq ;
+    queue_t	*upstrm_wrq ;
+
+    if (q == NULL) return;
+    q = LIS_RD(q) ;			/* operate on the read queue */
+    if (q == NULL) return;
+    lis_runqueues();
+
+    for (i = 1; i <= 2; i++, q = LIS_WR(q))		/* do twice */
+    {
+	if (LIS_DEBUG_CLOSE) name = lis_queue_name(q) ;
+
+	if (do_close && q->q_qinfo->qi_qclose != NULL)
+	{
+	    if (name)
+		printk("lis_qdetach: queue \"%s\": calling close routine\n", name);
+
+	    (*q->q_qinfo->qi_qclose)(q, (q->q_next ? 0 : flag), creds);
+	}
+    }
+
+    /*
+     * 'q' is the write queue
+     */
+    SPLSTR(psw) ;
+
+    if (F_ISSET(q->q_flag,QSCAN)) {
+      /* remove from the scan list
+       */
+	queue_t *p_scan = lis_scanqhead;
+	queue_t *p_prev = NULL;
+
+	if (name)
+	    printk("lis_qdetach: queue \"%s\": removing from scan list\n", name);
+
+	while (p_scan != NULL)
+	{
+	    if (p_scan == q || p_scan == LIS_WR (q))
+	    {					/* p_scan points to our queue */
+	      if (p_prev != NULL)		/* trailing ptr valid?  */
+		  p_prev->q_scnxt = p_scan->q_scnxt ;	/* link around q */
+	      else				/* prev still is q_head */
+		  lis_scanqhead = p_scan->q_scnxt ;	/* link hd around q */
+						/* NULL if last elt in list */
+	      if (lis_scanqtail == p_scan)	/* last elt in list? */
+		  lis_scanqtail = p_prev ;	/* back up tail ptr */
+						/* NULL if only elt in list */
+	      /* do not move prev ptr */
+	    }
+	    else				/* not our element */
+		p_prev = p_scan;		/* keep trailing ptr */
+
+	    p_scan = p_scan->q_scnxt ;		/* go to next elt of list */
+	}
+    }
+
+    SPLX(psw) ;				/* open brief interrupt window */
+    SPLSTR(psw) ;
+
+    if ((q->q_flag & QENAB) || (LIS_RD(q)->q_flag & QENAB)){
+	queue_t *p_scan = lis_qhead;
+	queue_t *p_prev = NULL;
+
+	if (name)
+	    printk("lis_qdetach: queue \"%s\": unscheduling service procedures\n", name);
+
+	/* Unschedule the service procedures.
+	 */
+	while (p_scan != NULL)
+	{
+	    if (p_scan == q || p_scan == LIS_WR (q))
+	    {					/* p_scan points to our queue */
+	      if (p_prev != NULL)		/* trailing ptr valid?  */
+		  p_prev->q_link = p_scan->q_link ;	/* link around q */
+	      else				/* prev still is q_head */
+		  lis_qhead = p_scan->q_link ;	/* link hd around q */
+						/* NULL if last elt in list */
+	      if (lis_qtail == p_scan)		/* last elt in list? */
+		  lis_qtail = p_prev ;		/* back up tail ptr */
+						/* NULL if only elt in list */
+	      /* do not move prev ptr */
+	      LisDownCount(QSCHEDS) ;
+	    }
+	    else				/* not our element */
+		p_prev = p_scan;		/* keep trailing ptr */
+
+	    p_scan = p_scan->q_link ;		/* go to next elt of list */
+	}
+    }
+
+    SPLX(psw) ;				/* open brief interrupt window */
+    SPLSTR(psw) ;
+
+    lis_flushq(q, FLUSHALL);
+    lis_flushq(LIS_RD(q), FLUSHALL);
+
+    downstrm_wrq	= LIS_WR(q)->q_next ;
+    if (downstrm_wrq != NULL)
+	downstrm_rdq= LIS_RD(downstrm_wrq) ;
+    else
+	downstrm_rdq= NULL ;
+
+    upstrm_rdq	= LIS_RD(q)->q_next ;
+    if (upstrm_rdq != NULL)
+	upstrm_wrq	= LIS_WR(upstrm_rdq) ;
+    else
+	upstrm_wrq	= NULL ;
+
+    if (upstrm_wrq != NULL)			/* have write-queue above us */
+    {
+	if (name)
+	    printk("lis_qdetach: queue \"%s\": link around write queue\n", name);
+
+	upstrm_wrq->q_next = downstrm_wrq ;	/* link around our queue */
+    }
+
+    if (downstrm_rdq != NULL)		/* have read-queue below us */
+    {
+	if (name)
+	    printk("lis_qdetach: queue \"%s\": link around read queue\n", name);
+
+	downstrm_rdq->q_next = upstrm_rdq ;	/* link around our queue */
+    }
+
+    if (name)
+	printk("lis_qdetach: queue \"%s\": de-allocate queue\n", name);
+
+    lis_freeq(LIS_RD(q));
+
+    SPLX(psw) ;
+
+}/*lis_qdetach*/
+
+
+/*  -------------------------------------------------------------------  */
+/* lis_qattach - set up a queue pair for driver/module
+ */
+static int
+lis_qattach (stdata_t *hd, struct streamtab *qinfo, queue_t *q, dev_t *devp,
+	     int flag, cred_t *creds)
+{
+    queue_t *newq;
+    int  open_mode,err;
+    int		psw ;
+    const char	*name ;
+    dev_t	 dev = 0 ;
+
+    (void) hd ;
+    if (q == NULL)
+	return -EIO;
+
+    if (   qinfo == NULL
+	|| qinfo->st_rdinit == NULL
+	|| qinfo->st_rdinit->qi_minfo == NULL
+	|| (name = qinfo->st_rdinit->qi_minfo->mi_idname) == NULL
+       )
+	name = "unnamed-queue" ;
+
+
+    if ((newq = lis_allocq(name)) == NULL)
+    {
+	if (LIS_DEBUG_OPEN)
+	    printk("lis_qattach: failed to allocate queue for driver\n") ;
+	return -ENOMEM;
+    }
+
+    SPLSTR(psw) ;
+
+    /* insert the queue 
+     */
+    newq->q_next = q;		/* LIS_RD(q), actually */
+    q = LIS_WR(q);
+    if ((LIS_WR(newq)->q_next = q->q_next) == NULL)
+    	open_mode = DEVOPEN;
+    else {
+    	LIS_OTHERQ(q->q_next)->q_next = newq;
+    	open_mode = MODOPEN;
+    }
+    q->q_next = LIS_WR(newq);
+
+    /* Set up the queue interface stuff */
+    lis_setq(newq, qinfo->st_rdinit, qinfo->st_wrinit);
+    /*
+     * Set initial queue flags.
+     *
+     * We set the QWANTR flag of both sides of the queue so that
+     * a putq into either queue will schedule the service procedure
+     * to run.  The flag means that some service procedure "wants"
+     * to "read" from the queue, that is, take messages out of it.
+     */
+    F_SET(newq->q_flag,QWANTR);
+    F_SET(LIS_WR(newq)->q_flag,QWANTR);		/* yes, even tho it's the wrq */
+
+    SPLX(psw) ;
+    /* Now call the new module/driver's open routine.
+     */
+
+    if (newq->q_qinfo->qi_qopen == NULL)	/* ensure open routine */
+    {
+	if ( LIS_DEBUG_OPEN )
+	    printk("lis_qattach: driver \"%s\" does not have open routine\n",
+		   lis_queue_name(newq)) ;
+
+	return(-ENOPKG) ;			/* pkg not installed */
+    }
+
+    if (devp == NULL)				/* as for module open */
+	devp = &dev ;
+
+    if ((err = (*newq->q_qinfo->qi_qopen) (newq, devp, flag,
+					    open_mode, creds)) != 0)
+    {
+	if ( LIS_DEBUG_OPEN )
+	    printk("lis_qattach: driver \"%s\" returned error %d\n",
+		   lis_queue_name(newq), err) ;
+
+	lis_qdetach(newq, 0, 0, creds);
+
+	if (err < 0) return(err) ;
+	else	     return(-err) ;
+    }
+    else 
+	err=0;
+
+    return(err);
+
+}/*lis_qattach*/
+
+/*  -------------------------------------------------------------------  */
+/* Push this module in this stream and call its open proc.
+ */
+static int
+push_mod(stdata_t *head, streamtab_t *mod, int flags, cred_t *creds)
+{
+    int err;
+
+    if (head->sd_maxpushcnt && head->sd_pushcnt == head->sd_maxpushcnt)
+	return(-ENOSR);
+    if ( (err=lis_qattach(head,mod,LIS_RD(head->sd_wq), NULL, flags, creds )) < 0 )
+	return(err);
+    else
+	head->sd_pushcnt++;
+    return(0);
+}/*push_mod*/
+
+/*  -------------------------------------------------------------------  */
+/* Pop the top module off this stream and call its close proc.
+ */
+static int
+pop_mod(stdata_t *head, int flags, cred_t *creds)
+{
+    if (!head->sd_pushcnt)
+	return(-EINVAL);
+    head->sd_pushcnt--;
+    lis_qdetach(LIS_RD(head->sd_wq->q_next),1,flags, creds);
+    return(0);
+}/*pop_mod*/
+
+/*  -------------------------------------------------------------------  */
+
+/* Set STREAMS options
+ */
+static void
+set_options( stdata_t *hd, stroptions_t *so)
+{
+    /* just set head flags as requested
+     */
+    if (F_ISSET(so->so_flags,SO_MREADON))	F_SET(hd->sd_flag,SNDMREAD);
+    if (F_ISSET(so->so_flags,SO_MREADOFF))	F_CLR(hd->sd_flag,SNDMREAD);
+    if (F_ISSET(so->so_flags,SO_NDELON))	F_SET(hd->sd_flag,OLDNDELAY);
+    if (F_ISSET(so->so_flags,SO_NDELOFF))	F_CLR(hd->sd_flag,OLDNDELAY);
+    if (F_ISSET(so->so_flags,SO_ISTTY))		F_SET(hd->sd_flag,STRISTTY);
+    if (F_ISSET(so->so_flags,SO_ISNTTY))	F_CLR(hd->sd_flag,STRISTTY);
+    if (F_ISSET(so->so_flags,SO_TOSTOP))	F_SET(hd->sd_flag,STRTOSTOP);
+    if (F_ISSET(so->so_flags,SO_TONSTOP))	F_CLR(hd->sd_flag,STRTOSTOP);
+    if (F_ISSET(so->so_flags,SO_STRHOLD))	F_SET(hd->sd_flag,STRHOLD);
+    if (F_ISSET(so->so_flags,SO_DELIM))		F_SET(hd->sd_flag,STRDELIM);
+    if (F_ISSET(so->so_flags,SO_NODELIM))	F_CLR(hd->sd_flag,STRDELIM);
+
+
+    if (F_ISSET(so->so_flags,SO_READOPT))
+	set_readopt(&hd->sd_rdopt,so->so_flags);
+
+    /* This chunk will set parameters
+     */
+    if (F_ISSET(so->so_flags,SO_WROFF))		
+        hd->sd_wroff=so->so_wroff;
+    if (F_ISSET(so->so_flags,SO_MINPSZ))	
+        hd->sd_minpsz= hd->sd_wq->q_minpsz= so->so_minpsz;
+    if (F_ISSET(so->so_flags,SO_MAXPSZ))
+	hd->sd_maxpsz= hd->sd_wq->q_maxpsz= so->so_maxpsz;
+    if (F_ISSET(so->so_flags,SO_BAND)){
+	if (F_ISSET(so->so_flags,SO_HIWAT))
+	    hd->sd_wq->q_hiwat= so->so_hiwat; /* should use so_band */
+	if (F_ISSET(so->so_flags,SO_LOWAT))
+	    hd->sd_wq->q_lowat= so->so_lowat; /* should use so_band */
+    }
+}/*set_options*/
+
+/*  -------------------------------------------------------------------  */
+
+/* Wake up polling processes
+ */
+static void
+lis_wake_up_poll( stdata_t *hd, int ev)
+{
+  polldat_t *pd;
+  int	     psw ;
+
+  if ( LIS_DEBUG_POLL )
+    printk("lis_wake_up_poll: stream %s%s: revents:%s\n",
+	lis_strm_name(hd), lis_maj_min_name(hd), lis_poll_events((short)ev)) ;
+
+  SPLSTR(psw) ;					/* may be unnecessary */
+
+  for (pd=hd->sd_polllist.ph_list; pd != NULL; pd=pd->pd_next) 
+  {
+    pd->pd_events = (short) ev ;		/* events being caused */
+    if (pd->pd_fn != NULL)			/* careful */
+	(*pd->pd_fn)(pd->pd_arg);		/* this will wake up the
+						 * polling process.
+	  					 */
+  }
+
+  SPLX(psw) ;
+
+  lis_select_wakeup(hd) ;			/* wake up selectors */
+
+}/*lis_wake_up_poll*/
+
+/*  -------------------------------------------------------------------  */
+
+/* deallocate poll list
+ * 
+ * Called from stdata structure deallocation code.  Shortly after
+ * this routine returns the stdata structure will be deallocated.
+ * We wake up any processes that are sleeping on poll data structures
+ * chained off of this stdata structure.  Immediately upon return
+ * from the wakeup, we go through the list and nullify the pointer
+ * to the list head in all the pdat structures.  This means that
+ * the poll code, when it finally wakes up, may find this head
+ * pointer to be NULL.  If the poll code has not delinked the
+ * poll entry by then, it may be in trouble.
+ */
+static void
+lis_deallocate_polllist( stdata_t *hd)
+{
+  polldat_t *pd;
+  int	     psw ;
+
+  SPLSTR(psw) ;					/* may be unnecessary */
+
+  if (hd->sd_polllist.ph_list != NULL)
+      lis_wake_up_poll(hd, POLLHUP) ;
+  else						/* no pollers */
+      lis_select_wakeup(hd) ;			/* wake up selectors */
+
+  for (pd=hd->sd_polllist.ph_list; pd != NULL; pd = pd->pd_next) 
+  {
+      pd->pd_headp = NULL ;
+  }
+
+  SPLX(psw) ;
+
+}/*lis_deallocate_polllist*/
+
+/*  -------------------------------------------------------------------  */
+/* kill procs in elist w/ sig
+ */
+static void 
+kill_procs( struct strevent *elist, int sig, short e)
+{
+    strevent_t *ev;
+    int res;
+
+    (void) sig ;
+    for(ev = elist->se_next ; ev != elist; ev=ev->se_next )
+	if ((ev->se_evs & e) != 0){
+	    if (F_ISSET(ev->se_evs,S_BANDURG) && F_ISSET(ev->se_evs,S_RDBAND))
+	    {
+		if (LIS_DEBUG_SIG)
+		    printk("kill_proc(pid=%d, sig=0x%x)\n", ev->se_pid, SIGURG);
+		if ((res=kill_proc(ev->se_pid,SIGURG,1))<0)
+		    lis_error(LIS_ERROR,
+			      "kill_procs","kill_proc: errno %d",res);
+
+		if (ev->se_evs& e& ~S_RDBAND) /* other events -> sigpoll too */
+		{
+		    if (LIS_DEBUG_SIG)
+			printk("kill_proc(pid=%d, sig=0x%x)\n",
+				ev->se_pid, SIGPOLL);
+		    if ((res=kill_proc(ev->se_pid,SIGPOLL,1))<0)
+			lis_error(LIS_ERROR,
+				  "kill_procs","kill_proc: errno %d",res);
+		}
+	    }
+	    else
+	    {
+		if (LIS_DEBUG_SIG)
+		    printk("kill_proc(pid=%d, sig=0x%x)\n",
+			    ev->se_pid, SIGPOLL);
+		if ((res=kill_proc(ev->se_pid,SIGPOLL,1))<0)
+		    lis_error(LIS_ERROR,"kill_procs","kill_proc: errno %d",res);
+	    }
+	}
+    
+}/*kill_procs*/
+/*  -------------------------------------------------------------------  */
+
+/* Will send relevant signals to the usr on arrival of M_[PC]SIG containing
+ * `sig' at the stream head.
+ */
+static void 
+signalusr(int sig, stdata_t *hd)
+{
+    if (sig==SIGPOLL)
+	kill_procs(hd->sd_siglist,SIGPOLL,SIGPOLL); /* ?? !!! */
+    else if (F_ISSET(hd->sd_flag,STRISTTY))
+	kill_pg(hd->sd_pgrp,sig,1);
+}/*signalusr*/
+/*  -------------------------------------------------------------------  */
+
+/* Send an M_READ msg downstream
+ */
+static int
+snd_mread(queue_t *wq, unsigned int ulen)
+{
+    mblk_t *mread = allocb(sizeof(ulen),BPRI_LO);
+    if (mread == NULL)
+	return(-ENOMEM);
+    else {
+	lis_btype(mread)=M_READ;
+	memcpy(mread->b_wptr,(char*)&ulen,sizeof(ulen));
+	mread->b_wptr+=sizeof(ulen);
+	lis_putnext(wq,mread);
+	return(0);
+    }
+}/*snd_mread*/
+
+/* Send an M_FLUSH msg downstream
+ */
+static int
+lis_snd_mflush(queue_t *wq, int flag, int band)
+{
+    mblk_t *mf = allocb(2*sizeof(int),BPRI_LO); /*sizeof mflush msg (?)*/
+    if (mf == NULL)
+	return(-ENOMEM);
+    else {
+	lis_btype(mf)=M_FLUSH;
+	lis_putbyte(&(mf->b_wptr),(char)flag);
+	if (F_ISSET(flag,FLUSHBAND))
+	    lis_putbyte(&(mf->b_wptr),(char)band);
+	lis_putnext(wq,mf);
+	return(0);
+    }
+}/*lis_snd_mflush*/
+
+/*  -------------------------------------------------------------------  */
+/* Send an ioctl negative ack  msg downstream reusing mp (M_IOCTL) msg.
+ */
+static int
+snd_iocnak(queue_t *wq, mblk_t *mp,int code)
+{
+    iocblk_t *iocb = (iocblk_t*)(mp->b_rptr);
+    mblk_t   *dtab;
+    lis_btype(mp)=M_IOCNAK;
+    iocb->ioc_error=code;
+    dtab=lis_unlinkb(mp);
+    lis_freemsg(dtab);
+    lis_putnext(wq,mp);
+    return(0);
+}/*snd_iocnak*/
+
+
+/*  -------------------------------------------------------------------  */
+
+/* Is this ioc blk out of sequence?
+ */
+static int
+bad_ioc_seq( mblk_t *mp, stdata_t *hd)
+{
+    iocblk_t *iocb = (iocblk_t*)mp->b_rptr;
+
+    return(iocb->ioc_id != (u_int) hd->sd_iocseq);
+
+}/*bad_ioc_seq*/
+
+/*  -------------------------------------------------------------------  */
+
+/* Call every open procedure in this queue
+ */
+static int
+open_mods( queue_t *q, dev_t dev, int flags, cred_t *creds)
+{
+    int 	 err;
+    queue_t	*rdq ;
+
+    if (q == NULL)
+	return(-ENOPKG) ;			/* pkg not installed */
+
+    for (q=LIS_WR(q),err=0; !err && q != NULL; q=q->q_next)
+    {
+	rdq = LIS_RD(q) ;
+	if (   rdq->q_qinfo == NULL		/* ensure qinfo */
+	    || rdq->q_qinfo->qi_qopen == NULL)	/* ensure open routine */
+	    return(-ENOPKG) ;			/* pkg not installed */
+
+	if ( ( err =
+		  (*(rdq->q_qinfo->qi_qopen))(rdq, &dev, flags,MODOPEN,creds)
+	     ) != 0
+	   )
+	    return(err > 0 ? -err : err);
+    }
+    return(0);
+}/*open_mods*/
+
+/*  -------------------------------------------------------------------  */
+/* Call every close procedure in this queue
+ */
+static void
+close_mods( queue_t *q, dev_t dev, int flags, cred_t *creds)
+{
+  int err;
+    (void) dev ;
+    for (q=LIS_WR(q),err=0; !err && q != NULL; q=q->q_next)
+      if (q->q_qinfo->qi_qclose != NULL)
+	(*(q->q_qinfo->qi_qclose))(LIS_RD(q),flags,creds);
+
+}/*close_mods*/
+
+/*  -------------------------------------------------------------------  */
+/* lis_strrput - stream head read put procedure
+ *
+ * TBD:  Must consider interrupt protection
+ */
+void
+lis_strrput(queue_t *q, mblk_t *mp)
+{
+    stdata_t *shead ;
+    int typ ;
+
+    if (q==NULL){
+	lis_error(LIS_ERROR,"lis_strrput","no queue, is this vacation?");
+	lis_freemsg(mp);
+	return;
+    }
+    else if ( (shead=q->q_ptr)==NULL){
+	lis_error(LIS_ERROR,"lis_strrput","no head (null) for queue 0x%x",q);
+	lis_freemsg(mp);
+	return;
+    }
+    else if (!mp || !mp->b_datap){
+	lis_error(LIS_ERROR,"lis_strrput","absent msg for queue 0x%x",q);
+	lis_freemsg(mp);
+	return;
+    }
+    /* ok, do the job */
+
+    typ = lis_btype(mp);
+    if (F_ISSET(shead->sd_flag, STRCLOSE))	/* stream is closing */
+    {						/* no file above stream */
+	switch (typ)
+	{
+	case M_PCPROTO:
+	case M_DATA:
+	case M_PROTO:
+	case M_PASSFP:
+	case M_SIG:
+	case M_PCSIG:
+	case M_COPYIN: 
+	case M_COPYOUT:
+	    if (LIS_DEBUG_STRRPUT)
+	      printk(
+	       "lis_strrput: discarding %s from \"%s\" on closed stream %s%s\n",
+			lis_msg_type_name(mp), lis_queue_name(backq(q)),
+			lis_strm_name(shead), lis_maj_min_name(shead)) ;
+	    lis_freemsg(mp) ;			/* no hope of retrieving msg */
+	    return ;
+	}
+    }
+
+    if (LIS_DEBUG_STRRPUT)
+	printk("lis_strrput: received %s (%d) from \"%s\" on stream %s%s size %d\n",
+		lis_msg_type_name(mp), typ, lis_queue_name(backq(q)),
+		lis_strm_name(shead), lis_maj_min_name(shead),
+		lis_msgsize(mp)) ;
+
+    switch(typ){
+    case M_PCPROTO:
+	if (F_ISSET(shead->sd_flag,STRPRI)){
+	    lis_freemsg(mp);
+	    return;
+	}
+	else 
+	    F_SET(shead->sd_flag,STRPRI);
+	/* fall thru... */
+    case M_DATA:
+    case M_PROTO:
+    case M_PASSFP:
+	LisUpCount(MSGQDSTRHD) ;
+        putq(q,mp);
+	/*
+	 * TBD: should this really be done first??
+	 */
+	if (F_ISSET(shead->sd_flag,RSLEEP)){
+	    lis_wake_up_wread(shead);
+	    F_CLR(shead->sd_flag,RSLEEP);
+	}
+
+	if (shead->sd_sigflags == 0 && shead->sd_polllist.ph_list == NULL)
+	    break ;			/* no signalling or polling */
+
+	if (typ == M_PCPROTO || mp == q->q_first)
+	{				/* hipri msg or 1st msg in queue */
+	    short evs=0;
+	    short polls=0 ;
+
+	    if (lis_hipri(typ))
+	    {
+		F_SET(polls,POLLPRI) ;
+		F_SET(evs,S_HIPRI);
+	    }
+	    else
+	    {
+		F_SET(polls,POLLIN) ;
+		F_SET(evs,S_INPUT);
+
+		if (lis_bband(mp)==0)
+		{
+		    F_SET(polls,POLLRDNORM) ;
+		    F_SET(evs,S_RDNORM);
+		}
+
+		if (lis_bband(mp)>0)
+		{
+		    F_SET(polls,POLLRDBAND) ;
+		    F_SET(evs,S_RDBAND);
+		}
+	    }
+
+	    if (evs &= shead->sd_sigflags)
+		kill_procs(shead->sd_siglist,SIGPOLL,evs);
+
+	    if (polls && shead->sd_polllist.ph_list != NULL)
+		lis_wake_up_poll(shead,polls);
+	}
+	break;
+    case M_ERROR:
+	shead->sd_rerror = lis_getint(&mp->b_rptr);
+	if (shead->sd_rerror == NOERROR)
+	    F_CLR(shead->sd_flag,STRDERR);
+	else
+	    F_SET(shead->sd_flag,STRDERR);
+	shead->sd_werror = lis_getint(&(mp->b_rptr));
+	if (shead->sd_werror == NOERROR)
+	    F_CLR(shead->sd_flag,STWRERR);
+	else
+	    F_SET(shead->sd_flag,STWRERR);
+	lis_wake_up_wwrite(shead);
+	lis_wake_up_wread(shead);
+	F_CLR(shead->sd_flag,RSLEEP);
+	F_CLR(shead->sd_flag,WSLEEP);
+	if (shead->sd_werror || shead->sd_rerror)
+	    lis_snd_mflush(LIS_WR(q),FLUSHW,0);
+	if (F_ISSET(shead->sd_sigflags,S_ERROR))
+	    kill_procs(shead->sd_siglist,SIGPOLL,S_ERROR);
+
+	if (shead->sd_polllist.ph_list != NULL)
+	    lis_wake_up_poll(shead,POLLERR);
+
+	lis_freemsg(mp);
+	break;
+    case M_HANGUP:
+	F_SET(shead->sd_flag,STRHUP);
+	lis_wake_up_wwrite(shead);
+	lis_wake_up_wread(shead);
+	if (F_ISSET(shead->sd_sigflags,S_HANGUP))
+	    kill_procs(shead->sd_siglist,SIGPOLL,S_HANGUP);
+	if (shead->sd_polllist.ph_list != NULL)
+	    lis_wake_up_poll(shead,POLLHUP);
+	lis_freemsg(mp);
+	break;
+
+    case M_FLUSH:
+	if (*mp->b_rptr & FLUSHR)
+	{					/* flush read queue */
+	    if (F_ISSET(*mp->b_rptr,FLUSHBAND))
+		lis_flushband(LIS_RD(q),mp->b_rptr[1],FLUSHDATA);
+	    else
+		lis_flushq(LIS_RD(q),FLUSHDATA);
+	    *mp->b_rptr &= ~FLUSHR ;		/* turn off flush read bit */
+	}
+
+	if (*mp->b_rptr & FLUSHW)
+	{					/* flush write queue */
+	    if (F_ISSET(*mp->b_rptr,FLUSHBAND))
+		lis_flushband(LIS_WR(q),mp->b_rptr[1],FLUSHDATA);
+	    else
+		lis_flushq(LIS_WR(q),FLUSHDATA);
+
+	    if (!(mp->b_flag & MSGNOLOOP))
+	    {
+		mp->b_flag |= MSGNOLOOP;
+		lis_putnext(LIS_WR(q),mp);	/* send back downstream */
+	    }
+	}
+	else					/* not flushing write */
+	    lis_freemsg(mp);
+
+	break;
+
+    case M_SIG:
+	putq(q,mp);		/* strread will signalusr() */
+	if (mp == q->q_first && shead->sd_polllist.ph_list != NULL)
+	    lis_wake_up_poll(shead,POLLMSG);
+	break;
+    case M_PCSIG:
+	signalusr(lis_getint(&mp->b_rptr),shead);
+	if (shead->sd_polllist.ph_list != NULL)
+	    lis_wake_up_poll(shead,POLLMSG);
+	lis_freemsg(mp);
+	break;
+    case M_IOCNAK: 
+	if (!F_ISSET(shead->sd_flag,IOCWAIT) || 
+	    F_ISSET(shead->sd_flag,STWRERR) ||
+	    F_ISSET(shead->sd_flag,STRDERR)     || bad_ioc_seq(mp,shead))
+	    lis_freemsg(mp);
+	else {			/* everything's ok: now we process it */
+	    /* make the outstanding ioctl to fail */
+	    shead->sd_iocblk=mp;
+	    lis_wake_up_wiocing(shead); /* this is not an unlock! */
+	}
+	break ;
+    case M_IOCACK: 
+	if (!F_ISSET(shead->sd_flag,IOCWAIT)|| 
+	    F_ISSET(shead->sd_flag,STWRERR) ||
+	    F_ISSET(shead->sd_flag,STRDERR)    || bad_ioc_seq(mp,shead))
+	    lis_freemsg(mp);
+	else {			/* everything's ok: now we process it */
+	    shead->sd_iocblk=mp;
+	    lis_wake_up_wiocing(shead); /* this is not an unlock! */
+	}
+	break ;
+    case M_COPYIN: 
+	if (!F_ISSET(shead->sd_flag,IOCWAIT))
+	    lis_freemsg(mp);
+	else if (F_ISSET(shead->sd_flag,STWRERR) ||
+		 F_ISSET(shead->sd_flag,STRDERR) || bad_ioc_seq(mp,shead)){
+	    /*Check out this!!*/
+      
+	    copyreq_t   req=*(copyreq_t*)mp->b_rptr;
+	    copyresp_t *res=(copyresp_t*)(mp->b_rptr=mp->b_datap->db_base);
+	    mp->b_wptr=(char*)(res+1);
+	    res->cp_cmd=req.cq_cmd;
+	    res->cp_uid=req.cq_uid;
+	    res->cp_gid=req.cq_gid;
+	    res->cp_rval=(caddr_t)1;
+	    res->cp_private=req.cq_private;
+	    lis_putnext(LIS_WR(q),mp);
+	}
+	else {			/* everything's ok: now we process it */
+	    shead->sd_iocblk=mp;
+	    lis_wake_up_wiocing(shead); /* this is not an unlock! */
+	}
+	break;
+    case M_COPYOUT:
+	if (!F_ISSET(shead->sd_flag,IOCWAIT))
+	    lis_freemsg(mp);
+	else if (F_ISSET(shead->sd_flag,STWRERR) ||
+		 F_ISSET(shead->sd_flag,STRDERR) ||  bad_ioc_seq(mp,shead)){
+	    /*Check this!!*/
+	    copyreq_t   req=*(copyreq_t*)mp->b_rptr;
+	    copyresp_t *res=(copyresp_t*)(mp->b_rptr=mp->b_datap->db_base);
+	    mp->b_wptr=(char*)(res+1);
+	    res->cp_cmd=req.cq_cmd;
+	    res->cp_uid=req.cq_uid;
+	    res->cp_gid=req.cq_gid;
+	    res->cp_rval=(caddr_t)1;
+	    res->cp_private=req.cq_private;
+	    lis_putnext(LIS_WR(q),mp);
+	}
+	else {			/* everything's ok: now we process it */
+	    shead->sd_iocblk=mp;
+	    lis_wake_up_wiocing(shead); /* this is not an unlock! */
+	}
+	break;
+    case M_SETOPTS:
+	set_options(shead,(stroptions_t*)mp->b_rptr);
+	lis_freemsg(mp);
+	break ;
+    case M_IOCTL:
+	snd_iocnak(LIS_WR(q),mp,1);
+	break;
+    default:
+	lis_freemsg(mp);
+	break ;
+    }
+
+}/*lis_strrput*/
+
+
+/*  -------------------------------------------------------------------  */
+/*  lis_strwsrv
+ *
+ * This is the stream head write service procedure.  It is used
+ * for detecting that the stream below the stream head no longer
+ * has messages queued for output so the stream can be closed.
+ */
+
+void	lis_strwsrv(queue_t *q)
+{
+    stdata_t	*hd = (stdata_t *) q->q_ptr ;
+    mblk_t	*mp ;
+
+    if (hd == NULL)				/* should not happen */
+    {
+	printk("lis_strwsrv: queue %s: q_ptr is NULL\n", lis_queue_name(q));
+	return ;
+    }
+    
+    if (hd->magic != STDATA_MAGIC || hd->sd_wq != q) return ;
+
+    while (   lis_bcanputnext(q,0)		/* can send downstream */
+	   && (mp = getq(q)) != NULL		/* have queued messages */
+	  )
+    {
+	putnext(q, mp) ;			/* send downstream */
+    }
+
+    if (   F_ISSET(hd->sd_flag, STRCLOSE)	/* stream is closing */
+	&& lis_qcountstrm(q) == 0 		/* queues are empty */
+       )
+   {
+	if ( LIS_DEBUG_CLOSE )
+	    printk("lis_strwsrv: stream %s%s empty, wake up close routine\n",
+		    lis_strm_name(hd),
+		    lis_maj_min_name(hd)) ;
+
+	lis_wakeup_close((caddr_t) hd) ;	/* wake up close */
+   }
+   else
+   if (hd->sd_sigflags != 0)
+   {
+	if (F_ISSET(hd->sd_sigflags,S_OUTPUT)
+	    && lis_bcanputnext(q,0)
+	   )
+	    kill_procs(hd->sd_siglist,SIGPOLL,S_OUTPUT);
+
+	/*
+	 * AT&T says in STREAMS Programmer's Guide:
+	 *
+	 * "S_WRBAND
+	 *
+	 * "A priority band greater than 0 of a queue downstream exists
+	 * and is writeable.  This notifies the user that there is room
+	 * on the queue for sending (or writing) priority data downstream."
+	 */
+	if (F_ISSET(hd->sd_sigflags,S_WRBAND)
+	    && lis_bcanputnext_anyband(q)
+	   )
+	    kill_procs(hd->sd_siglist,SIGPOLL,S_WRBAND);
+   }
+
+    if (   hd->sd_polllist.ph_list != NULL	/* poll waiting */
+	&& lis_bcanputnext(q,0)			/* can still send downstream */
+       )
+    {
+	lis_wake_up_poll(hd,POLLOUT);
+    }
+
+} /* lis_strwsrv */
+
+
+/*  -------------------------------------------------------------------  */
+/* This is the tmout handling function.
+ * it will be called on response to a tmout and is responsible to
+ * take the right actions.
+ * It should be called w/ an stream head as argument.
+ */
+static void
+lis_do_tmout( unsigned long arg )
+{
+    stdata_t *hd = (stdata_t*)arg;
+
+    if (hd->magic != STDATA_MAGIC){
+	lis_error(LIS_ERROR,"lis_do_tmout","timeout with bad stream 0x%x",arg);
+	return;
+    }
+    if (F_ISSET(hd->sd_flag,STIOCTMR)){     /* ioctl timer: awake sleeper*/
+	F_CLR(hd->sd_flag,STIOCTMR);
+	lis_wake_up_wiocing(hd);
+    }
+}/*lis_do_tmout*/
+
+
+/*  -------------------------------------------------------------------  */
+/* lis_wait_for_wiocing - wait until ioc response arrived or timeout occur
+ */
+static int
+lis_wait_for_wiocing(stdata_t *hd, int tmout)
+{
+    struct timer_list tl;
+    int		      rslt ;
+
+    while( hd->sd_iocblk == NULL )
+    {
+	if ( F_ISSET(hd->sd_flag,(STRDERR|STWRERR)) )
+	    return(-hd->sd_rerror) ;
+	F_SET(hd->sd_flag,STIOCTMR);
+	lis_tmout(&tl,lis_do_tmout,(long)hd, SECS_TO(tmout));
+	rslt = lis_sleep_on_wiocing(hd);
+	if (rslt < 0)
+	{
+	    lis_untmout(&tl);
+	    F_CLR(hd->sd_flag,STIOCTMR);
+	    return(rslt) ;
+	}
+
+	if (!F_ISSET(hd->sd_flag,STIOCTMR)) /* timer expired */
+	    return(-ETIME);
+	else {
+	    lis_untmout(&tl);
+	    F_CLR(hd->sd_flag,STIOCTMR);
+	}
+    }
+    return(0);			/* got msg */
+}/*lis_wait_for_wiocing*/
+
+/*  -------------------------------------------------------------------  */
+
+/* copyout bmlks for reads
+ */
+static void 
+copyout_blks(struct file *f, char *ubuff, long count, mblk_t *mp)
+{
+    mblk_t *mb;
+    long ocount=count;
+    int len;
+
+    for (mb=mp ; mb && count > 0; mp=mb)
+    {
+	mb=mp->b_cont;				/* next buffer in chain */
+	mp->b_cont = NULL ;			/* unchain this buffer */
+	len=min(count,lis_mblksize(mp));	/* size of current bfr */
+	lis_copyout(f,mp->b_rptr,ubuff,len);	/* copy out current bfr */
+	count -=len;
+	ubuff +=len;
+	lis_freeb(mp);				/* free current buffer */
+    }
+
+    if (count != 0)			/* hopefully, copied whole buffer */
+	lis_error(LIS_WARN,"copyout_blks",
+		  "count (%d) doesn't match data (%d)", ocount, ocount-count);
+}
+
+/*  -------------------------------------------------------------------  */
+/* strdoioctl - ioctl handler used by strioctl
+ */
+static int
+lis_strdoioctl(struct file *f, stdata_t *hd,
+		strioctl_t *ioc, cred_t *creds, int do_copyin)
+{
+    mblk_t *mioc,*mdta;
+    iocblk_t *iocb;
+    int err;
+
+    if (ioc->ic_len < 0 || ioc->ic_timout < -1)
+	return(-EINVAL);
+    if ((mioc=allocb(sizeof(iocblk_t),BPRI_LO))==NULL)
+	return(-ENOMEM);
+    if (ioc->ic_len){
+	if (do_copyin && 
+	    (err=lis_check_umem(f,VERIFY_WRITE,ioc->ic_dp,ioc->ic_len))<0)
+	    return(err);
+	if ((mdta=allocb(ioc->ic_len,BPRI_LO))==NULL){
+	    lis_freemsg(mioc);
+	    return(-ENOMEM);
+	}
+	if (do_copyin)
+	    lis_copyin(f,mdta->b_wptr,ioc->ic_dp,ioc->ic_len);
+	else
+	    memcpy(mdta->b_wptr,ioc->ic_dp,ioc->ic_len);
+	mdta->b_wptr += ioc->ic_len;
+	lis_linkb(mioc,mdta);
+    }
+    iocb=(iocblk_t*)mioc->b_wptr;
+    mioc->b_wptr += sizeof(iocblk_t);
+    mioc->b_datap->db_type = M_IOCTL ;
+    iocb->ioc_cmd=ioc->ic_cmd;
+    iocb->ioc_uid=creds->cr_uid;
+    iocb->ioc_gid=creds->cr_gid;
+    iocb->ioc_count=ioc->ic_len;
+    iocb->ioc_error=0;
+    iocb->ioc_rval=0;
+  again:
+    err = lis_lock_wioc(hd);
+    if (err < 0)
+    {
+	lis_freemsg(mioc);
+	return(err) ;
+    }
+
+    iocb->ioc_id=hd->sd_iocseq =  ++lis_iocseq;
+
+    if ( LIS_DEBUG_IOCTL )
+	printk("lis_strdoioctl: send %s to \"%s\" on stream %s%s, cmd(0x%x)\n",
+			lis_msg_type_name(mioc),
+			lis_queue_name(hd->sd_wq->q_next),
+			lis_strm_name(hd), lis_maj_min_name(hd), iocb->ioc_cmd) ;
+    lis_putnext(hd->sd_wq,mioc);
+    mioc=NULL;			
+    if (   (err=lis_wait_for_wiocing(hd,ioc->ic_timout))<0
+        || (mioc = hd->sd_iocblk) == NULL		/* rtnd ioctl msg */
+       )
+    {
+	lis_unlock_wioc(hd);
+	return(err);
+    }
+    /* Here we have! */
+    hd->sd_iocblk = NULL ;
+    if ( LIS_DEBUG_IOCTL )
+	printk("lis_strdoioctl: %s from \"%s\" on stream %s%s\n",
+		    lis_msg_type_name(mioc),
+		    lis_queue_name(hd->sd_wq->q_next),
+		    lis_strm_name(hd), lis_maj_min_name(hd)) ;
+
+    switch(lis_btype(mioc))
+    {
+    case M_IOCACK:
+	iocb=(iocblk_t*)mioc->b_rptr;
+	if (iocb->ioc_error){
+	    lis_freemsg(mioc);
+	    lis_unlock_wioc(hd);
+	    return(-(iocb->ioc_error));
+	}
+	else {
+	    int rval=iocb->ioc_rval;
+	    int len = iocb->ioc_count ;
+	    mblk_t *dat=lis_unlinkb(mioc);
+
+	    if (len != 0 && do_copyin)
+	    {
+		if ((err=lis_check_umem(f,VERIFY_WRITE,ioc->ic_dp,len)) < 0)
+		    rval = err ;		/* oops... */
+		else
+		{
+		    copyout_blks(f,ioc->ic_dp, len, dat);
+		    dat = NULL;			/* see copyout_blks() */
+		    ioc->ic_len = len ;		/* length */
+		}
+	    }
+
+	    if (dat)
+		lis_freemsg(dat);
+
+	    lis_freemsg(mioc);
+	    lis_unlock_wioc(hd);
+	    return(rval);
+	}
+	break ;
+    case M_IOCNAK:
+	iocb=(iocblk_t*)mioc->b_rptr;
+	{
+	    int res=-(iocb->ioc_error);
+	    lis_freemsg(mioc);
+	    lis_unlock_wioc(hd);
+	    return(res);
+	}
+	break ;
+    case M_COPYIN:
+	{
+	    copyreq_t *cp=(copyreq_t*)mioc->b_rptr;
+	    copyresp_t*cr=(copyresp_t*)mioc->b_rptr;
+	    u_int      len=cp->cq_size;
+	    mblk_t    *dat;
+	    char      *ubuf=cp->cq_addr;
+
+	    err = 0 ;
+	    if ((dat=allocb(len,BPRI_LO))==NULL)
+		cr->cp_rval=(caddr_t)ENOMEM;
+	    else if ((err=lis_check_umem(f,VERIFY_READ,ubuf,len)) < 0)
+		lis_freemsg(dat);
+	    else {
+		lis_copyin(f,dat,ubuf,len);
+		lis_linkb(mioc,dat);
+		cr->cp_rval=0;
+	    }
+	    lis_btype(mioc)=M_IOCDATA;
+	    lis_putnext(hd->sd_wq,mioc); 
+	    lis_unlock_wioc(hd);
+	    goto again;
+	}
+	break ;
+    case M_COPYOUT:
+	{
+	    copyreq_t *cp=(copyreq_t*)mioc->b_rptr;
+	    copyresp_t*cr=(copyresp_t*)mioc->b_rptr;
+	    char      *ubuf=cp->cq_addr;
+	    u_int      len=cp->cq_size;
+	    mblk_t    *dat;
+
+	    if ((err=lis_check_umem(f,VERIFY_WRITE,ubuf,len)) >= 0){
+		dat=lis_unlinkb(mioc);
+		copyout_blks(f,ubuf,len,dat);
+		cr->cp_rval=0;
+	    } 
+	    lis_btype(mioc)=M_IOCDATA;
+	    lis_putnext(hd->sd_wq,mioc);
+	    lis_unlock_wioc(hd);
+	    goto again;
+	}
+	break ;
+    default:
+	lis_freemsg(mioc);
+	lis_unlock_wioc(hd);
+	return(-EINVAL) ;
+    }
+    return(0);
+}/*lis_strdoioctl*/
+
+/*  -------------------------------------------------------------------  */
+/*
+ * lis_add_filetbl
+ *
+ * Add a file to the file table of the stream.
+ *
+ * Return 0 for success, negative errno if failed.
+ */
+static int
+lis_add_filetbl(stdata_t *hd, struct file *f)
+{
+    struct file		**ff ;
+    struct file		**empty = NULL ;
+    int			  n ;
+
+    if (hd->sd_filetbl == NULL)
+    {
+	hd->sd_filetbl = (struct file **)
+			    ALLOCF(SD_FILETBL_DFLT*sizeof(hd->sd_filetbl),
+			    "sd_filetbl ");
+	if (hd->sd_filetbl == NULL)
+	    return(-ENOMEM) ;
+
+	hd->sd_filetbl_size = SD_FILETBL_DFLT ;
+	memset(hd->sd_filetbl, 0, SD_FILETBL_DFLT*sizeof(hd->sd_filetbl)) ;
+    }
+
+    for (ff = hd->sd_filetbl, n = hd->sd_filetbl_size; n > 0; n--, ff++)
+    {
+	if (*ff == f)				/* have file already */
+	    return(0) ;				/* done (unlikely case) */
+
+	if (empty == NULL && *ff == NULL)
+	    empty = ff ;			/* ptr to empty slot */
+    }
+
+    if (empty == NULL)				/* table full, expand */
+    {
+	n = hd->sd_filetbl_size + SD_FILETBL_DFLT ;	/* new size */
+	ff = (struct file **) ALLOCF(n*sizeof(hd->sd_filetbl), "sd_filetbl ");
+	if (ff == NULL)				/* could not allocate */
+	    return(-ENOMEM) ;
+
+	memset(ff, 0, n*sizeof(hd->sd_filetbl)) ;
+	memcpy(ff, hd->sd_filetbl, hd->sd_filetbl_size*sizeof(hd->sd_filetbl)) ;
+	empty = ff + hd->sd_filetbl_size ;	/* next available slot */
+	FREE(hd->sd_filetbl) ;			/* free old file table */
+
+	hd->sd_filetbl = ff ;			/* new file table */
+	hd->sd_filetbl_size += SD_FILETBL_DFLT ;/* now bigger */
+    }
+
+    *empty = f ;				/* save file ptr */
+    return(0) ;					/* success */
+
+} /* lis_add_filetbl */
+
+/*  -------------------------------------------------------------------  */
+/*
+ * lis_sub_filetbl
+ *
+ * Subtract a file from the file table of the stream.
+ */
+static void
+lis_sub_filetbl(stdata_t *hd, struct file *f)
+{
+    struct file		**ff ;
+    int			  n ;
+
+    if (hd->sd_filetbl == NULL) return ;
+
+    for (ff = hd->sd_filetbl, n = hd->sd_filetbl_size; n > 0; n--, ff++)
+    {
+	if (*ff == f)				/* have file */
+	    *ff = NULL ;			/* remove file from list */
+    }
+
+} /* lis_sub_filetbl */
+
+/*  -------------------------------------------------------------------  */
+/*
+ * lis_mod_filetbl
+ *
+ * Modify each file of the file list to point to a new inode.
+ */
+static void
+lis_mod_filetbl(stdata_t *hd, struct inode *i)
+{
+    struct file		**ff ;
+    int			  n ;
+
+    if (hd->sd_filetbl == NULL) return ;
+
+    for (ff = hd->sd_filetbl, n = hd->sd_filetbl_size; n > 0; n--, ff++)
+    {
+	if (*ff != NULL)			/* valid file */
+	    STR_FILE_INODE(*ff) = i ;		/* modify its inode ptr */
+    }
+
+} /* lis_mod_filetbl */
+
+/*  -------------------------------------------------------------------  */
+/*
+ * lis_get_inode
+ *
+ * Return the inode that the files that are operating 'hd' point to.
+ */
+static struct inode *lis_get_inode(stdata_t *hd)
+{
+    struct file		**ff ;
+    int			  n ;
+
+    if (hd->sd_filetbl == NULL) return(NULL) ;
+
+    for (ff = hd->sd_filetbl, n = hd->sd_filetbl_size; n > 0; n--, ff++)
+    {
+	if (*ff != NULL)
+	    return(STR_FILE_INODE(*ff)) ;
+    }
+
+    return(NULL) ;
+
+} /* lis_get_inode */
+
+/*  -------------------------------------------------------------------  */
+/*
+ * lis_lookup_stdata
+ *
+ * Look through all the stdata structures for one that has the
+ * given device id.  Return a pointer to it.
+ */
+static
+stdata_t *lis_lookup_stdata(dev_t dev, stdata_t *not_this_one)
+{
+    stdata_t		*hd ;
+    int			 n ;
+
+    if (lis_stdata_head == NULL)
+	return(NULL) ;			/* no strdata structs allocated */
+
+    for (hd = lis_stdata_head, n = 0;
+	 n == 0 || hd != lis_stdata_head;
+	 hd = hd->sd_next, n++)
+    {
+	if (hd != not_this_one && hd->sd_dev == dev)
+	    return(hd) ;		/* found it */
+    }
+
+    return(NULL) ;			/* not found */
+
+} /* lis_lookup_stdata */
+
+/*  -------------------------------------------------------------------  */
+/*
+ * lis_find_stdata
+ *
+ * Try to find an stdata structure with the given device id.  Return
+ * a pointer to it.
+ *
+ * This is useful in cases where a clone open created an stdata structure
+ * and then a directed open landed on the same device id.
+ *
+ * This routine is called from lis_stropen PRIOR to calling the
+ * streams driver open routine.  If we find another stream that
+ * is already attached to this 'dev' then we want to use that stream
+ * rather than the one passed to us by sys_open().
+ *
+ * The routine 'lis_pick_inode' is a callout routine to the environment
+ * that knows how to choose between two inodes that indicate the
+ * same device and dispose of the one that we are NOT going to use.
+ */
+static
+stdata_t *lis_find_stdata(struct inode **open_inode_ptr,
+			  struct file   *f,
+			  dev_t dev)
+{
+    stdata_t		*hd ;
+    struct inode	*newi ;
+    struct inode	*rtni ;
+    struct inode	*oldi = *open_inode_ptr ;
+
+    hd = lis_lookup_stdata(dev, NULL) ;	/* find stdata struct for 'dev' */
+    if (hd == NULL)
+	return(NULL) ;			/* not found */
+
+    newi = lis_get_inode(hd) ;		/* get inode of stream */
+    if (newi == NULL)
+	return(NULL) ;			/* no inode for 'hd' somehow */
+
+    rtni = lis_pick_inode(oldi, newi, dev) ;	/* callout routine */
+    if (rtni == NULL)			/* something did not work */
+	return(NULL) ;			/* just open as new file */
+
+    *open_inode_ptr = rtni ;		/* use new inode */
+    STR_FILE_INODE(f) = rtni ;		/* hook file to new inode */
+    if (rtni != newi)			/* using different inode */
+	lis_mod_filetbl(hd, rtni) ;	/* make all files use new inode */
+
+    return(hd) ;			/* use this other stream */
+
+} /* lis_find_stdata */
+
+
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+/*  -------------------------------------------------------------------  */
+
+
+
+
+
+/*  -------------------------------------------------------------------  */
+/* lis_stropen - open a stream (see Magic Garden 7.9.3 and 7.9.4)
+ */
+
+int 
+lis_stropen( struct inode *i, struct file *f )
+{
+    struct stdata *head = NULL;
+    struct queue  *q = NULL;
+    streamtab_t	  *st;
+    const char	  *name = "(unknown)";
+    const char	  *majmin = "(unknown)";
+    cred_t	   creds;
+    dev_t	   odev ;
+    dev_t	   ndev ;
+    int		   err = 0;
+    int		   hd_locked = 0 ;
+    int		   maj;
+    int		   a;
+    int		   psw ;
+
+    lis_open_cnt++ ;
+    if (LIS_DEBUG_OPEN)
+    {
+	printk("lis_stropen: call number %ld\n", lis_open_cnt) ;
+	if (LIS_DEBUG_ADDRS)
+	    printk(
+		"lis_stropen: f=%lx f->f_inode=%lx i=%lx i->i_rdev=%x\n",
+		   (long) f, (long) f->f_inode, (long) i, i->i_rdev) ;
+    }
+
+    CHECK_INO(i,"lis_stropen");	/* may return */
+    odev = i->i_rdev;
+    maj=STR_MAJOR(odev);
+    head=INO_STR(i);
+
+    if (head == NULL)			/* opening new stream */
+	head = lis_find_stdata(&i, f, i->i_rdev) ;
+					/* chk for duplicate dev open */
+
+    creds.cr_uid  = (uid_t) EUID(f);
+    creds.cr_gid  = (gid_t) EGID(f);
+    creds.cr_ruid = (uid_t) UID(f);
+    creds.cr_rgid = (gid_t) GID(f);
+    if (head != NULL)
+    {
+	if (head->magic != STDATA_MAGIC)
+	{
+	    printk("lis_stropen: head@%lx has magic number %lx, should be %lx\n",
+	    		(long)head, head->magic, STDATA_MAGIC) ;
+	    return(-EINVAL) ;
+	}
+
+	/* Stream was created by previous open of device: sleep if still
+           opening, then call every module open() and awake sleepers */
+
+	SPLSTR(psw) ;
+	head->sd_refcnt++;		/* another use counted */
+	SPLX(psw) ;
+
+	err = lis_lock_wopen(head);	/* get exclusive use of the head */
+	if (err < 0)
+	    goto error_rtn ;
+
+	hd_locked = 1 ;
+
+	if ( LIS_DEBUG_OPEN )
+	{
+	    name = lis_strm_name(head) ;
+	    majmin = lis_maj_min_name(head) ;
+	}
+
+	q = LIS_RD(head->sd_wq->q_next);
+
+	if ((err=open_mods(q,i->i_rdev,f->f_flags,&creds))<0) { 
+	    close_mods(q,i->i_rdev,f->f_flags,&creds);
+	    F_SET(head->sd_flag,STRHUP);
+	    goto error_rtn ;
+	}
+
+	if ( (err = lis_add_filetbl(head, f)) < 0 )
+	    goto error_rtn ;
+
+	goto successful_rtn ;
+    }
+
+    /* First open of the stream: allocate a queue pair and stream head if
+       STREAMS is not already using too much memory */
+    if (!stravail(f))
+    {
+	if (LIS_DEBUG_OPEN)
+	    printk("lis_stropen: not enough memory to open a stream\n") ;
+
+	return(-ENOSR);
+    }
+
+    q=lis_allocq("stream-head");
+    if (!q){
+	if (LIS_DEBUG_OPEN)
+	    printk("lis_stropen: failed to allocate a queue for stream head\n") ;
+
+	return(-ENOMEM);
+    }
+
+    /* initialize the stream head and set the STWOPEN flag set
+       vp->v_stream to point to stream head set q_ptr fields in queue
+       pair to point to stream head */
+    if ((head=alloc_stdata(i))==NULL){		/* allocate and lock */
+	if (LIS_DEBUG_OPEN)
+	    printk("lis_stropen: failed to allocate stream head\n") ;
+
+	err = -ENOMEM;
+	goto error_rtn ;
+    }
+
+    /*
+     * alloc_stdata() returned with the stdata structure locked
+     */
+    hd_locked = 1 ;
+    head->sd_refcnt=1;
+
+    LIS_RD(q)->q_ptr=head;
+    LIS_WR(q)->q_ptr=head;
+    head->sd_wq = LIS_WR(q);
+    lis_setq(q, &strmhd_rdinit, &strmhd_wrinit);
+    head->sd_rdopt = RPROTNORM | RNORM ;
+    head->sd_wropt = 0 ;
+
+    /* head->sd_session=SESSION();	DMG not used??  */
+    head->sd_pgrp= PGRP(f);
+
+    /* TBD: need a better default for LIS_MAXPSZ */
+    head->sd_maxpsz   = LIS_MAXPSZ; /* probably not to be done so */
+    head->sd_minpsz   = LIS_MINPSZ;
+
+#ifdef FIFO_IMPL
+//	lis_fifo_strtab not yet defined !!
+    if (LIS_ISDEV(maj,LIS_FIFO))
+	head->sd_strtab= &lis_fifo_strtab;
+    else
+#endif
+	head->sd_strtab= LIS_DEVST(maj).f_str;	/* use strmtab of opened strm */
+
+    head->sd_dev = odev ;
+    ndev = odev ;
+    name = lis_strm_name(head) ;
+    majmin = lis_maj_min_name(head) ;
+    lis_mark_mem(head, name, MEM_STRMHD) ;	/* plug in name */
+    head->sd_open_flags = f->f_flags ;
+    err = lis_qattach(head,head->sd_strtab, q, &ndev, f->f_flags, &creds);
+    if (err < 0)				/* failed queue attach */
+	goto error_rtn ;			/* go cleanup */
+
+    if ( (err = lis_add_filetbl(head, f)) < 0 )	/* allocate file tbl */
+	goto error_rtn ;
+
+    if (ndev != odev)				/* clone open */
+    {						/* changed the device */
+	stdata_t	*other_hd ;
+	const char	*clone_name = name ;
+	const char	*clone_majmin = majmin ;
+
+	head->sd_dev = ndev ;
+	head->sd_strtab = LIS_DEVST(STR_MAJOR(ndev)).f_str;
+	name = lis_strm_name(head) ;		/* update names */
+	majmin = lis_maj_min_name(head) ;
+	lis_mark_mem(head, name, MEM_STRMHD) ;	/* plug in name */
+
+	other_hd = lis_lookup_stdata(ndev, head) ;
+						/* chk for other strm */
+	if (other_hd != NULL)
+	{					/* use it instead of head */
+	    printk("lis_stropen: clone open stream to '%s%s' same as '%s%s'\n",
+		    name, lis_maj_min_name(head),
+		    lis_strm_name(other_hd), lis_maj_min_name(other_hd)
+		    ) ;
+	}
+	else
+	{
+	    struct inode	*rtni ;
+
+						/* allocate new inode */
+	    rtni = lis_pick_inode(i, NULL, ndev) ;	/* callout routine */
+	    if (rtni == NULL)
+	    {
+		err = -ENOMEM ;
+		goto error_rtn ;
+	    }
+
+	    i = rtni ;				/* use new inode */
+	    STR_FILE_INODE(f) = i ;		/* hook file to new inode */
+	    lis_mod_filetbl(head, i) ;	      /* make all files use new inode */
+	}
+
+	if ( LIS_DEBUG_OPEN )
+	{
+	    printk("lis_stropen: open clone '%s%s' to '%s%s'\n",
+		    clone_name, clone_majmin,
+		    name, majmin
+		    ) ;
+	    if (LIS_DEBUG_ADDRS)
+	      printk(
+		"lis_stropen: clone: f=%lx f->f_inode=%lx i=%lx i->i_rdev=%x\n",
+			   (long) f, (long) f->f_inode, (long) i, i->i_rdev) ;
+	}
+    }						/* ndev != odev */
+
+    for (a=0; a<MAX_APUSH && (st=lis_apushm(a,i->i_rdev))!=NULL; a++ )
+    {
+	if ( (err = push_mod(head,st,f->f_flags,&creds)) < 0 )
+	    goto error_rtn ;			/* go cleanup */
+    }
+
+successful_rtn:					/* returning success */
+    if ( LIS_DEBUG_OPEN )
+    {
+	printk(
+	  "lis_stropen: open number %d on stream to '%s%s' (%ld open streams)\n",
+		head->sd_refcnt, name, majmin, lis_stdata_cnt) ;
+	printk("             head-q:\"%s\" driver-q:\"%s\"\n",
+		lis_queue_name(head->sd_wq),
+		lis_queue_name(head->sd_wq->q_next)) ;
+    }
+
+    lis_unlock_wopen(head);
+    return(0);
+
+error_rtn:				/* come here if fail */
+					/* no need to unlock the head */
+    if ( LIS_DEBUG_OPEN )
+      printk(
+       "lis_stropen: open stream to \"%s\" returning error %d (%ld open streams)\n",
+		name, err, lis_stdata_cnt) ;
+
+    if (q != NULL) lis_freeq(q);
+    if (head != NULL)			/* head was allocated */
+    {
+	if (hd_locked)			/* head is locked */
+	    lis_unlock_wopen(head);	/* unlock it */
+
+	if (   --head->sd_refcnt <= 0	/* last use of head */
+	    && INO_STR(i) == head	/* inode points to head */
+	   )
+        {
+	    free_stdata(head) ;	/* free & clear i_str ptr */
+	    INO_STR(i)=NULL;
+        }
+    }
+
+    return(err) ;
+
+}/*lis_stropen*/
+
+/*  -------------------------------------------------------------------  */
+/* strwrite - write to a stream (see Magic Garden 7.9.5)
+ */
+int
+lis_strwrite(struct inode *i, struct file *fp, const char *ubuff,  int ulen)
+{
+    stdata_t *hd;
+    mblk_t   *held;
+    const char  *name = "" ;
+    int		 chunk;
+    int		 written=0; 
+    int		 flags ;
+    int err,newmsg;
+
+    /* Just in case we're holding messages in the write side we use
+       head->sd_wmsg msg to hold data to be sent. When it's time to send it we
+       just lis_putnext() such message.  If we're not holding then we just
+       lis_putnext() the message w/ the usr data.       */
+
+    CHECK_INO(i,"lis_strwrite"); /* may return */
+    if (!(hd = INO_STR(i))) /* should lock/check also hd status */
+	return(-ENODEV);
+
+    if (LIS_DEBUG_WRITE) name = lis_strm_name(hd) ;
+
+    if (!stravail(fp))
+    {
+	if (LIS_DEBUG_WRITE)
+	  printk(
+	    "strwrite: stream %s%s: out of streams resources\n",
+			name, lis_maj_min_name(hd)) ;
+
+	return(-ENOSR); 
+    }
+
+    if (ulen < hd->sd_minpsz)
+    {
+	if (LIS_DEBUG_WRITE)
+	  printk(
+	    "strwrite: stream %s%s: write length %d less than min size of %ld\n",
+			name, lis_maj_min_name(hd),
+			ulen, hd->sd_minpsz) ;
+
+	return(-EINVAL);
+    }
+
+    if (!ulen && !F_ISSET(hd->sd_wropt,SNDZERO)) /* we don't send anything */
+    {
+	if (LIS_DEBUG_WRITE)
+	  printk(
+	    "strwrite: stream %s%s: write length zero and SNDZERO not set\n",
+			name, lis_maj_min_name(hd)) ;
+
+	return(0);
+    }
+
+    if ((err=lis_check_umem(fp,VERIFY_READ,ubuff,ulen))<0)
+    {
+	if (LIS_DEBUG_WRITE)
+	  printk(
+	    "strwrite: stream %s%s: user address 0x%lx cannot be read from\n",
+			name, lis_maj_min_name(hd), (long)ubuff) ;
+
+	return(err);
+    }
+
+    if (F_ISSET(hd->sd_flag,STWRERR))
+    {
+	if (LIS_DEBUG_WRITE)
+	  printk(
+	    "strwrite: stream %s%s: stream has been I_LINKed\n",
+		name, lis_maj_min_name(hd)) ;
+	return(-EINVAL) ;
+    }
+
+    do {
+	if (F_ISSET(hd->sd_flag,STWRERR))
+	{
+	    if (LIS_DEBUG_WRITE)
+	      printk(
+		"strwrite: stream %s%s: stream has received M_ERROR %d\n",
+			    name, lis_maj_min_name(hd), hd->sd_werror) ;
+
+	    return(-hd->sd_werror);
+	}
+
+	if (F_ISSET(hd->sd_flag,STRHUP))
+	{
+	    if (LIS_DEBUG_WRITE)
+	      printk(
+		"strwrite: stream %s%s: stream has received M_HANGUP\n",
+			    name, lis_maj_min_name(hd)) ;
+	    return(-ENODEV);
+	}
+
+	/* write packets until all data has been written. */
+	if (!lis_bcanputnext(hd->sd_wq,0))
+	{
+	    if (should_notblock_wr(hd,fp))
+	    {
+		if (LIS_DEBUG_WRITE)
+		    printk(
+		     "strwrite: stream %s%s: flw cntrl blocked, return EAGAIN\n",
+			name, lis_maj_min_name(hd)) ;
+		return(-EAGAIN);
+	    }
+	    else {
+		F_SET(hd->sd_flag,WSLEEP);
+		if (LIS_DEBUG_WRITE)
+		    printk(
+		     "strwrite: stream %s%s: flw cntrl blocked, sleep\n",
+			name, lis_maj_min_name(hd)) ;
+		err = lis_wait_on_wwrite(hd);
+		if (err < 0)
+		{
+		    F_CLR(hd->sd_flag,WSLEEP);
+		    return(err) ;
+		}
+
+		continue ;
+	    }
+	}
+	/* get mblk if there's not one */
+	held=hd->sd_wmsg;
+	chunk=min((int)hd->sd_maxpsz,ulen-written);
+	newmsg= (held==NULL);
+	if ( held == NULL && 
+	     (held=hd->sd_wmsg=allocb(chunk+hd->sd_wroff,BPRI_LO))==NULL)
+	{
+	    lis_runqueues();
+	    return(written?written:-ENOMEM);
+	}
+	/* now copy from usr to mblk (type M_DATA by default) */
+	if (newmsg)
+	{
+	    held->b_wptr=held->b_datap->db_base + hd->sd_wroff;
+	    if (F_ISSET(hd->sd_flag,STRDELIM))		/* delimited msg */
+		held->b_flag |= MSGDELIM ;
+	}
+
+	if (held->b_datap->db_lim - held->b_wptr >= chunk)    /* enough room */
+	{
+	    lis_copyin(fp,held->b_wptr,ubuff,chunk);
+	    ubuff        += chunk;
+	    written      += chunk;
+	    held->b_wptr += chunk;
+
+	    if (strholding(hd) && 
+		held->b_datap->db_lim - held->b_wptr > written)
+	    {					/* hold for more data */
+		if (LIS_DEBUG_WRITE)
+		    printk(
+		     "strwrite: stream %s%s: hold message %d bytes for scan timer\n",
+			name, lis_maj_min_name(hd), chunk) ;
+
+		if (newmsg) 
+		    start_scanl_timer(hd); 
+
+		lis_runqueues();
+		return(written);
+	    }
+	}        
+
+        /*
+         * Either there was not enough room in the existing message
+         * to hold the next write, or we wrote to a new message
+         * and the write-holding mechanism is not active.
+         *
+         * In either case, now is the time to send the message downstream.
+         */
+        SPLSTR(flags) ;
+        if (hd->sd_scantimer != 0)		/* scantimer running */
+        {
+	    untimeout(hd->sd_scantimer) ;	/* cancel the timer */
+	    hd->sd_scantimer = 0 ;		/* note timer is not running */
+        }
+        SPLX(flags) ;
+
+	if (LIS_DEBUG_WRITE)
+	    printk(
+		"strwrite: stream %s%s: send %d bytes downstream to %s\n",
+		name, lis_maj_min_name(hd), chunk,
+		lis_queue_name(hd->sd_wq->q_next)) ;
+
+        lis_putnext(hd->sd_wq,hd->sd_wmsg);
+        hd->sd_wmsg = NULL ;			/* don't reuse the message */
+
+    } while (written<ulen);
+
+
+    lis_runqueues();
+    return(written);
+
+}/*lis_strwrite*/
+
+/*  -------------------------------------------------------------------  */
+/* lis_strread - read from a stream head
+ */
+int 
+lis_strread(struct inode *i, struct file *fp, char *ubuff,  int ulen)
+{
+    stdata_t *hd;
+    queue_t  *hd_rq;
+    mblk_t   *mp;
+    const char     *name = "" ;
+    int		 count=0;
+    unsigned int chunk;
+    int		 nbytes ;
+    int		 msg_lgth ;
+    int		 msg_marked ;
+    int err;
+
+#define	RTN(val)	{ err = val; goto return_point; }
+
+
+    CHECK_INO(i,"lis_strrread");
+    if (!(hd=INO_STR(i)))
+	RTN(-ENODEV);
+
+    if (LIS_DEBUG_READ) name = lis_strm_name(hd) ;
+
+    if ((err=lis_check_umem(fp,VERIFY_WRITE,ubuff,ulen))<0)
+    {
+	if (LIS_DEBUG_READ)
+	  printk(
+	    "strread: stream %s%s: user buffer at 0x%lx cannot be written into\n",
+		name, lis_maj_min_name(hd), (long)ubuff) ;
+
+	RTN(err);
+    }
+
+    if (F_ISSET(hd->sd_flag,STPLEX))
+    {
+	if (LIS_DEBUG_READ)
+	  printk(
+	    "strread: stream %s%s: stream has been I_LINKed\n",
+		name, lis_maj_min_name(hd)) ;
+
+	RTN(-EINVAL) ;
+    }
+
+    hd_rq=LIS_RD(hd->sd_wq);
+
+    for (;/*ever*/;) {
+	while (hd_rq->q_first == NULL)
+	{					/* nothing to read */
+	    if (F_ISSET(hd->sd_flag,STRDERR))
+	    {
+		if (LIS_DEBUG_READ)
+		  printk(
+		    "strread: stream %s%s: stream has received M_ERROR %d\n",
+			name, lis_maj_min_name(hd), hd->sd_rerror) ;
+		RTN(-hd->sd_rerror);
+	    }
+	    
+	    if (F_ISSET(hd->sd_flag,STRHUP))
+	    {
+		if (LIS_DEBUG_READ)
+		  printk(
+		    "strread: stream %s%s: stream has received M_HANGUP\n",
+			name, lis_maj_min_name(hd)) ;
+
+		RTN(0);
+	    }
+
+	    if (F_ISSET(hd->sd_flag,SNDMREAD))
+	    {
+		if (LIS_DEBUG_READ)
+		    printk(
+			"strread: stream %s%s: send M_READ downstream to %s\n",
+			name, lis_maj_min_name(hd),
+			lis_queue_name(hd->sd_wq->q_next)) ;
+
+		snd_mread(hd->sd_wq,ulen);
+	    }
+
+	    if (should_notblock_rd(hd,fp))
+	    {
+		if (LIS_DEBUG_READ)
+		    printk(
+			"strread: stream %s%s: O_NONBLOCK set, return EAGAIN\n",
+			name, lis_maj_min_name(hd)) ;
+
+		RTN(-EAGAIN);
+	    }
+	    if (LIS_DEBUG_READ)
+		printk(
+		    "strread: stream %s%s: O_NONBLOCK not set, sleep\n",
+		    name, lis_maj_min_name(hd)) ;
+	    F_SET(hd->sd_flag,RSLEEP);
+	    err = lis_sleep_on_wread(hd);
+	    if (err < 0)
+	    {
+		F_CLR(hd->sd_flag,RSLEEP);
+		RTN(err) ;
+	    }
+	}
+	mp = lis_getq(hd_rq);
+	LisDownCount(MSGQDSTRHD) ;
+	msg_marked = mp->b_flag & MSGMARK;
+	switch(lis_btype(mp)){
+	case M_DATA:
+	    msg_lgth = 0 ;
+	    do
+	    {
+		/*
+		 * If rptr > wptr the message block is ill-formed
+		 * and nbytes will be negative.
+		 */
+		if (lis_btype(mp) != M_DATA)
+		    nbytes = -1 ;		/* pretend invalid */
+		else
+		    nbytes = mp->b_wptr - mp->b_rptr;
+
+		if (nbytes > 0)			/* safety check */
+		{
+		    chunk=min(ulen-count,nbytes);
+		    lis_copyout(fp,mp->b_rptr,ubuff,chunk);
+
+		    msg_lgth   += nbytes ;	/* keep track of msg lgth */
+		    mp->b_rptr += chunk;	/* message read ptr */
+		    ubuff      += chunk ;	/* user buffer ptr */
+		    count      += chunk;	/* bytes copied to user */
+		    nbytes     -= chunk ;	/* bytes left in msg */
+		}
+
+		if (nbytes <= 0)		/* time for nxt blk */
+		{				/* includes bad blocks */
+		    mblk_t *dust=mp;		/* and zero-lgth msgs */
+		    mp=lis_unlinkb(mp);
+		    lis_freeb(dust);
+		}
+
+	    } while(count < ulen && mp);
+
+	    if (mp != NULL)			/* not at msg boundary */
+	    {
+		if ( (hd->sd_rdopt & RMODEMASK) == RMSGD )
+		    lis_freemsg(mp);		/* discard rest of msg */
+		else				/* RMSGN or RNORM */
+		    lis_putbq(hd_rq,mp); 	/* save rest of msg */
+	    }
+
+	    if (LIS_DEBUG_READ)
+	      printk(
+	      "strread: stream %s%s: RDOPT=0x%x user buffer %d bytes, read %d\n",
+		    name, lis_maj_min_name(hd), hd->sd_rdopt, ulen, count) ;
+
+	    if (   ulen == count			/* filled user buffer */
+		|| (hd->sd_rdopt & RMODEMASK) != RNORM	/* RMSGN or RMSGD */
+		|| msg_lgth == 0			/* 0-lgth msg */
+		|| msg_marked				/* at marked msg */
+	       )					/* return to user */
+	    {
+	        RTN(count);
+	    }
+
+	    break;
+	case M_PCPROTO:
+	    F_CLR(hd->sd_flag,STRPRI);
+	    /*fall thru...*/
+	case M_PROTO: 
+	    if (LIS_DEBUG_READ)
+		printk(
+		    "strread: stream %s%s: RDOPT=0x%x",
+		    name, lis_maj_min_name(hd), hd->sd_rdopt) ;
+
+	    if (F_ISSET(hd->sd_rdopt,RPROTNORM))
+	    {					/* return with EBADMSG */
+		lis_freemsg(mp);		/* discard the messasge */
+		if (LIS_DEBUG_READ)
+		    printk(" discard M_PROTO msg\n") ;
+		RTN(-EBADMSG);			/* return */
+	    }
+
+	    if (F_ISSET(hd->sd_rdopt,RPROTDAT))/* treat M_PROTO as M_DATA */
+	    {
+		if (LIS_DEBUG_READ)
+		    printk(" change M_PROTO msg to M_DATA\n") ;
+		lis_btype(mp) = M_DATA;		/* change to M_DATA */
+		lis_putbq(hd_rq, mp);		/* put back in queue */
+		break ;				/* go around again */
+	    }
+
+	    if (F_ISSET(hd->sd_rdopt,RPROTDIS))/* discard M_PROTO */
+	    {					/* deliver M_DATA */
+		mblk_t	*proto = mp;		/* the M_PROTO */
+
+		if (LIS_DEBUG_READ)
+		    printk(" discard M_PROTO block, retain M_DATA\n") ;
+		mp = lis_unlinkb(mp);		/* mp is M_DATA or NULL */
+		lis_freeb(proto);		/* discard proto */
+		if (mp != NULL)			/* still have a msg */
+		    lis_putbq(hd_rq, mp);	/* put back in queue */
+	    }					/* go around again */
+	    else
+	    {
+		if (LIS_DEBUG_READ)
+		    printk(" invalid rdopt, discard M_PROTO msg\n") ;
+
+		lis_freemsg(mp);		/* discard the messasge */
+		RTN(-EBADMSG);			/* return */
+	    }
+
+	    break;
+
+	case M_READ:		/* add to-be-discarded msgs here */
+	    if (LIS_DEBUG_READ)
+		printk(
+		    "strread: stream %s%s: read %s: discard\n",
+		    name, lis_maj_min_name(hd), lis_msg_type_name(mp)) ;
+	    lis_freemsg(mp);
+	    break;
+
+	case M_SIG:
+	    {
+		int	signo = *mp->b_rptr ;
+
+		if (LIS_DEBUG_READ)
+		    printk(
+			"strread: stream %s%s: read M_SIG, signo=%d\n",
+			name, lis_maj_min_name(hd), signo) ;
+		signalusr(signo,hd);
+		lis_freemsg(mp);
+		RTN(-EAGAIN);			/* return from system call */
+	    }
+	    break;
+
+	default:
+	    if (LIS_DEBUG_READ)
+		printk(
+		    "strread: stream %s%s: read %s: return EBADMSG\n",
+		    name, lis_maj_min_name(hd), lis_msg_type_name(mp)) ;
+	    lis_freemsg(mp);
+	    RTN(-EBADMSG);
+	}/*sw db_type*/
+    }
+
+return_point:
+    lis_runqueues();				/* run the streams queues */
+    return(err) ;				/* return to user */
+
+#undef	RTN
+
+}/*lis_strrread*/
+
+/*  -------------------------------------------------------------------  */
+/* strputmsg - stream head handler for putmsg
+ */
+int
+lis_strputpmsg(struct inode *i, struct file *fp, 
+	       void *ctlp, void *datp, int band, int flags)
+{
+    int		    err;
+    int		    couldput ;
+    mblk_t	   *msg;
+    stdata_t	   *hd;
+    const char     *name = "" ;
+    strbuf_t	   *ctl = (strbuf_t *) ctlp ;
+    strbuf_t	   *dat = (strbuf_t *) datp ;
+
+    CHECK_INO(i,"lis_strputmsg"); /* may return */
+    if (!(hd = INO_STR(i))) /* should lock/check also hd status */
+	return(-ENODEV);
+
+    if (LIS_DEBUG_PUTMSG) name = lis_strm_name(hd) ;
+
+    if (!stravail(fp))
+    {
+	if (LIS_DEBUG_PUTMSG)
+	  printk(
+	    "strputmsg: stream %s%s: out of streams resources\n",
+			name, lis_maj_min_name(hd)) ;
+
+	return(-ENOSR); 
+    }
+
+    if (F_ISSET(hd->sd_flag,STWRERR))
+    {
+	if (LIS_DEBUG_PUTMSG)
+	  printk(
+	    "strputmsg: stream %s%s: stream has been I_LINKed\n",
+		name, lis_maj_min_name(hd)) ;
+
+	return(-EINVAL) ;
+    }
+
+    if (band >= 0)				/* putpmsg */
+    {
+	if ( (flags & (MSG_HIPRI|MSG_BAND)) == (MSG_HIPRI|MSG_BAND) )
+	    return(-EINVAL) ;			/* flags are exclusive */
+	if ( flags & ~(MSG_HIPRI|MSG_BAND) )
+	    return(-EINVAL) ;			/* other flags set */
+	if (flags == 0)
+	    return(-EINVAL) ;			/* flags must be non-zero */
+	if (F_ISSET(flags,MSG_HIPRI))		/* usr wants hi priority msg */
+	    band = 0 ;				/* must be band zero */
+    }
+    else					/* putmsg */
+    {
+	if (flags & ~RS_HIPRI)
+	    return(-EINVAL) ;			/* other flags set */
+    }
+
+    if ( (err=copyin_msg(fp,hd,&msg,ctl,dat))<0)	/* allocates msg */
+    {
+	return(err);
+    }
+
+    if (msg == NULL)			/* no message to send */
+    {
+	if (band >= 0)			/* putpmsg */
+	{
+	    if (flags & ~MSG_BAND)	/* asking for hi-pri */
+		return(-EINVAL) ;	/* no can do */
+	}
+	else				/* putmsg */
+	{
+	    if (flags & RS_HIPRI)	/* asking for hi-pri */
+		return(-EINVAL) ;	/* no can do */
+	}
+
+	return(0) ;			/* no options, no error */
+    }
+
+    if (band >= 0)			/* putpmsg */
+    {
+	if (F_ISSET(flags,MSG_HIPRI))		/* usr wants hi priority msg */
+	{
+	    if (lis_btype(msg) == M_PROTO)	/* is there a ctl part */
+		lis_btype(msg)=M_PCPROTO;	/* yes */
+	    else
+	    {
+		lis_freemsg(msg);
+		return(-EINVAL) ;		/* no, sorry */
+	    }
+	}
+	else					/* regular priority msg */
+	if (F_ISSET(flags,MSG_BAND))		/* non-zero band */
+	{
+	    if (band >=0 && band <=LIS_MAX_BAND)	/* range check */
+		lis_bband(msg) = (unsigned char) band;
+	    else
+	    {
+		lis_freemsg(msg);
+		return(-EINVAL);
+	    }
+	}
+    }
+    else					/* putmsg */
+    {
+	if (F_ISSET(flags,RS_HIPRI))		/* usr wants hi priority msg */
+	{
+	    if (lis_btype(msg) == M_PROTO)	/* is there a ctl part */
+		lis_btype(msg)=M_PCPROTO;	/* yes */
+	    else
+	    {
+		lis_freemsg(msg);
+		return(-EINVAL) ;		/* no, sorry */
+	    }
+	}
+    }
+
+    /*
+     * wait for flow control 
+     */
+    do
+    {
+	if (F_ISSET(hd->sd_flag,STWRERR))
+	{
+	    if (LIS_DEBUG_PUTMSG)
+	      printk(
+		"strputmsg: stream %s%s: stream has received M_ERROR %d\n",
+			    name, lis_maj_min_name(hd), hd->sd_werror) ;
+
+	    freemsg(msg) ;
+	    return(-hd->sd_werror);
+	}
+
+	if (F_ISSET(hd->sd_flag,STRHUP))
+	{
+	    if (LIS_DEBUG_PUTMSG)
+	      printk(
+		"strputmsg: stream %s%s: stream has received M_HANGUP\n",
+			    name, lis_maj_min_name(hd)) ;
+	    freemsg(msg) ;
+	    return(-ENODEV);
+	}
+
+	couldput = lis_bcanputnext(hd->sd_wq,(unsigned char) band);
+						    /* check the band */
+	if (   !couldput
+	    && (should_notblock_wr(hd,fp) || F_ISSET(flags,MSG_HIPRI))
+	   )
+	{						/* return b4 allocating msg */
+	    if (LIS_DEBUG_PUTMSG)
+		printk(
+		 "strputmsg: stream %s%s: flw cntrl blocked, return EAGAIN\n",
+		    name, lis_maj_min_name(hd)) ;
+	    freemsg(msg) ;
+
+	    return(-EAGAIN);
+	}
+
+	if (!couldput)				/* flw cntrl blocked */
+	{
+	    if (LIS_DEBUG_PUTMSG)
+		printk(
+		 "strputmsg: stream %s%s: flw cntrl blocked, sleep\n",
+		    name, lis_maj_min_name(hd)) ;
+
+	    F_SET(hd->sd_flag,WSLEEP);		/* wait until unblocked */
+	    err = lis_wait_on_wwrite(hd);
+	    if (err < 0)
+	    {
+		F_CLR(hd->sd_flag,WSLEEP);
+		lis_freemsg(msg) ;
+		return(err) ;
+	    }
+	}
+
+    } while (!couldput) ;
+	    
+    if (LIS_DEBUG_PUTMSG)
+    {
+	printk(
+	    "strputmsg: stream %s%s: send %d/%d ctl/data bytes downstream to %s\n",
+	    name, lis_maj_min_name(hd),
+	    msg->b_datap->db_type == M_DATA ? 0 : lis_xmsgsize(msg),
+	    lis_msgdsize(msg),
+	    lis_queue_name(hd->sd_wq->q_next)) ;
+
+	if (LIS_DEBUG_ADDRS)
+	    printk("strputmsg: q = 0x%lx, msg = 0x%lx\n",
+		    (long)hd->sd_wq, (long)msg);
+    }
+
+    lis_putnext(hd->sd_wq,msg);			/* send downstream */
+
+    return(0);
+
+}/*lis_strputpmsg*/
+
+/*  -------------------------------------------------------------------  */
+/* strgetmsg - stream head handler for getmsg
+ *
+ * If 'doit' is set then this is a getmsg or getpmsg system call.
+ * In this case 'ctl', 'dat' and 'flagsp' are all user space addresses.
+ * 'bandp' can be NULL if the call is from getmsg().  It will be
+ * a non-null user-space address if the call is from getpmsg().
+ *
+ * If 'doit' is not set then this is an I_PEEK call.  In this case
+ * 'ctl', 'dat' and 'flagsp' and 'bandp' point to kernel memory.
+ *
+ * Note that getmsg() and I_PEEK use one encoding of the flags
+ * (the RS_...) and that getpmsg() uses another (the MSG_...).
+ */
+int
+lis_strgetpmsg(struct inode *i, struct file *fp, 
+	       void *ctlp, void *datp, int *bandp, int *flagsp,
+	       int doit)
+{
+    strbuf_t	*ctl = (strbuf_t *) ctlp ;
+    strbuf_t	*dat = (strbuf_t *) datp ;
+    const char	*ctl_type = "" ;
+    const char	*dat_type = "" ;
+    int		 err;
+    int		 rtn ;
+    stdata_t	*hd;
+    strbuf_t	 kctl,kdat;
+    mblk_t	*mp;
+    queue_t	*rdq ;
+    int		 band = 0 ;
+    int		 flags = 0 ;
+    int		 mtype ;
+    int		 psw = 0 ;
+
+    CHECK_INO(i,"lis_strgetmsg"); /* may return */
+    if (!stravail(fp))
+	return(-ENOSR); /* no more streams resources */
+    else if (!(hd = INO_STR(i))) /* should lock/check also hd status */
+	return(-ENODEV);
+    else if (F_ISSET(hd->sd_flag,STRDERR))
+	return(-hd->sd_rerror);
+    else if (ctl == NULL || dat == NULL)
+	return(-EFAULT) ;
+    else if (doit && ctl != NULL &&
+	     (err=lis_check_umem(fp,VERIFY_READ,ctl,sizeof(strbuf_t)))<0)
+	return(err);
+    else if (doit && dat != NULL &&
+	     (err=lis_check_umem(fp,VERIFY_READ,dat,sizeof(strbuf_t)))<0)
+	return(err);
+    else if (flagsp == NULL)
+	return(-EFAULT) ;
+    else if (doit && (err=lis_check_umem(fp,VERIFY_READ,flagsp,sizeof(int)))<0)
+	return(err);
+    else if (doit && bandp != NULL
+	     && (err=lis_check_umem(fp,VERIFY_READ,bandp,sizeof(int)))<0)
+	return(err);
+
+    if (F_ISSET(hd->sd_flag,STPLEX))
+    {
+	if (LIS_DEBUG_GETMSG)
+	  printk(
+	    "strgetmsg: stream %s%s: stream has been I_LINKed\n",
+		lis_strm_name(hd), lis_maj_min_name(hd)) ;
+
+	return(-EINVAL) ;
+    }
+
+    rdq = LIS_RD(hd->sd_wq) ;
+    if (doit)
+    {					/* fetch structs from usr space */
+	if (ctl != NULL)
+	    lis_copyin(fp,&kctl,ctl,sizeof(strbuf_t));
+	else
+	{
+	    kctl.maxlen = -1 ;
+	    kctl.len    = -1 ;
+	    kctl.buf    = NULL ;
+	}
+
+	if (dat != NULL)
+	    lis_copyin(fp,&kdat,dat,sizeof(strbuf_t));
+	else
+	{
+	    kdat.maxlen = -1 ;
+	    kdat.len    = -1 ;
+	    kdat.buf    = NULL ;
+	}
+
+	lis_copyin(fp,&flags,flagsp,sizeof(flags));
+	if (doit && bandp != NULL)
+	    lis_copyin(fp,&band,bandp,sizeof(band));
+	else
+	    band  = 0 ;
+
+	if (kctl.maxlen >= 0 || kdat.maxlen >= 0)
+	{
+	    while (   rdq->q_first == NULL
+	           && (hd->sd_flag & (STRHUP | STRDERR)) == 0
+	          )
+	    {
+		if (should_notblock_rd(hd,fp))
+		    return(-EAGAIN);
+		F_SET(hd->sd_flag,RSLEEP);
+		rtn = lis_sleep_on_wread(hd);
+		if (rtn < 0) 
+		{
+		    F_CLR(hd->sd_flag,RSLEEP);
+		    return(rtn) ;
+		}
+	    }
+	}
+    }
+    else				/* fetch structs from kernel space */
+    {
+	kctl  = *ctl ;
+	kdat  = *dat ;
+	flags = *flagsp ;
+	band  = *bandp ;
+    }
+
+    /*
+     * Disable interrupts.  Every exit from here on should go out
+     * via the "return_point" label for cleanup purposes.
+     *
+     * Remember, interrupt routines could putnext() messages up
+     * to the stream head read queue and change our idea of the
+     * head message in the queue while we are looking at it.
+     * We must keep interrupts disabled at least until we remove
+     * the message from the queue.
+     *
+     * If we are peeking we do not need the interrupt exclusion
+     * since once we have the mp that is all we need.
+     */
+    if (doit) SPLSTR(psw) ;
+
+    if ((mp = rdq->q_first) == NULL)		/* mp is 1st msg */
+    {						/* empty read queue */
+	if (F_ISSET(hd->sd_flag,STRHUP))
+	{
+	    kctl.len=0;			      /* so sez STREAMS pgrmr's guide */
+	    kdat.len=0;
+	    rtn = 0 ;
+	}
+	else
+	if (F_ISSET(hd->sd_flag,STRDERR))
+	{
+	    kctl.len = -1;			/* just a guess */
+	    kdat.len = -1;
+	    rtn = -hd->sd_rerror;
+	}
+	else					/* return NULL msg action */
+	    rtn=copyout_msg(fp,NULL,&kctl,&kdat,
+			    (strbuf_t*)ctl,(strbuf_t*)dat,doit) ;
+
+	if (doit) SPLX(psw) ;
+	goto return_point ;			/* go return 'rtn' */
+    }
+
+    if (LIS_DEBUG_GETMSG && LIS_DEBUG_DMP_MBLK && LIS_DEBUG_ADDRS)
+    {
+	printk("lis_strgetpmsg: q=%lx, mp=%lx, mp->b_rptr=%lx\n",
+				(long)rdq, (long)mp, (long)mp->b_rptr);
+    }
+
+    /*
+     * At this point we have a message.  Ensure that it is
+     * of the type that we want to process.
+     */
+    mtype = lis_btype(mp) ;
+    if (LIS_DEBUG_GETMSG)
+    {
+	if (mtype != M_DATA)
+	{
+	    ctl_type = lis_msg_type_name(mp) ;
+	    dat_type = lis_msg_type_name(mp->b_cont) ;
+	}
+	else
+	{
+	    ctl_type = "NULL-MSG" ;
+	    dat_type = lis_msg_type_name(mp) ;
+	}
+    }
+
+    switch (mtype)
+    {
+    case M_DATA:
+    case M_PROTO:
+    case M_PCPROTO:
+    case M_SIG:
+	break ;				/* OK, keep going */
+
+    case M_PASSFP:
+    default:
+	if (doit) SPLX(psw) ;
+	rtn = -EBADMSG ;		/* unsure of rtn value here */
+	goto return_point ;
+    }
+
+    if (doit)					/* it's get[p]msg() */
+    {
+	if (lis_hipri(mtype))			/* M_PCPROTO */
+	{
+	    F_CLR(hd->sd_flag,STRPRI);		/* about to remove the msg */
+	    flags = MSG_HIPRI ;
+	    band  = 0 ;
+	}
+	else					/* normal priority msg */
+	{
+	    if (flags == MSG_HIPRI)		/* user wanted hi-pri only */
+	    {
+		SPLX(psw) ;
+		rtn = -EBADMSG;
+		goto return_point ;		/* go return 'rtn' */
+	    }
+
+	    if (flags == MSG_BAND)		/* wants from particular band */
+	    {
+		if (mp->b_band < (unsigned char) band)	/* msg in wrong band */
+		{
+		    SPLX(psw) ;
+		    rtn = -EBADMSG;
+		    goto return_point ;		/* go return 'rtn' */
+		}
+	    }
+
+	    if (flags != 0 && flags != MSG_ANY)
+	    {
+		SPLX(psw) ;
+		rtn = -EINVAL;			/* invalid flags */
+		goto return_point ;		/* go return 'rtn' */
+	    }
+
+	    flags = MSG_BAND ;
+	    band  = mp->b_band ;
+	}
+
+	/*
+	 * Now we commit to removing the message from the read queue
+	 */
+	mp = lis_getq(rdq);			/* remove from queue */
+
+	if ( mp == NULL )
+	{
+	    printk("lis_strgetpmsg: empty queue: addr of queue 0x%lx\n",
+		    (long) rdq);
+	    rtn = -EINVAL;
+	    SPLX(psw) ;				/* OK to enable now */
+	    goto return_point;
+	}
+
+	LisDownCount(MSGQDSTRHD) ;
+	if (LIS_DEBUG_GETMSG && LIS_DEBUG_DMP_DBLK)
+	{
+	    lis_print_msg(mp, "lis_strgetpmsg", PRINT_DATA_RDWR) ;
+	}
+
+	SPLX(psw) ;				/* OK to enable now */
+
+	if (mtype == M_SIG)			/* process M_SIG */
+	{
+	    signalusr(*mp->b_rptr,hd);		/* signal nr is a byte */
+	    lis_freemsg(mp);
+	    rtn = -EAGAIN ;
+	    goto return_point ;
+	}
+    }
+    else					/* it's I_PEEK */
+    {
+	if (mtype == M_SIG)			/* not suitable msg */
+	{
+	    rtn = -EBADMSG ;
+	    goto return_point ;
+	}
+
+	if (lis_hipri(mtype))			/* M_PCPROTO */
+	    flags = MSG_HIPRI ;
+	else					/* M_DATA or M_PROTO */
+	if (flags == RS_HIPRI)			/* wants hi-priority only */
+	{
+	    rtn = -EBADMSG;
+	    goto return_point ;			/* go return 'rtn' */
+	}
+	else
+	    flags = MSG_BAND ;			/* regular priority */
+    }
+
+    /* 
+     * copyout_msg will copy data to usr returning MORECTL,MOREDATA status
+     */
+    if ((rtn=copyout_msg(fp,mp,&kctl,&kdat,(strbuf_t*)ctl,(strbuf_t*)dat,doit))<0)
+    {
+	if (doit)
+	    lis_freemsg(mp);
+    } 
+    else 
+    if (doit)				/* getmsg/getpmsg */
+    {
+	if (rtn)			/* there's still ctl or data in msg */
+	  lis_putbq(rdq, mp);
+	else
+	  lis_freemsg(mp);
+    }
+    else				/* I_PEEK */
+	rtn = kctl.len >= 0 || kdat.len >= 0 ;	/* got something */
+
+
+return_point:
+
+    if (rtn >= 0)			/* return flags to user */
+    {
+	if (!doit || bandp == NULL)	/* I_PEEK or getmsg */
+	{				/* different encoding of flags */
+	    switch (flags)
+	    {
+	    case MSG_HIPRI:
+		flags = RS_HIPRI ;
+		break ;
+	    case MSG_BAND:
+	    case MSG_ANY:
+	    case 0:
+	    default:
+		flags = 0 ;
+		break ;
+	    }
+	}
+
+	if (!doit)
+	    *flagsp = flags ;		/* return flags to kernal space */
+	else				/* return flags to user space */
+	if ((err=lis_check_umem(fp,VERIFY_WRITE,flagsp,sizeof(int))) == 0)
+	    lis_copyout(fp,&flags,flagsp,sizeof(flags));
+	else				/* check failed */
+	    rtn = err ;			/* return error */
+    }
+
+    if (doit && bandp != NULL)		/* getpmsg() */
+    {
+	if ((err=lis_check_umem(fp,VERIFY_WRITE,bandp,sizeof(int))) == 0)
+	    lis_copyout(fp,&band,bandp,sizeof(band));
+	else				/* check failed */
+	    rtn = err ;			/* return error */
+    }
+    else				/* getmsg or I_PEEK */
+    if (!doit && bandp != NULL)		/* kernel pointer */
+	*bandp = band ;
+
+    if (LIS_DEBUG_GETMSG)
+    {
+      printk("strgetmsg:    maxlen     len    return=0x%x flags=0x%x band=%d",
+					      rtn,        flags,     band) ;
+      printk(" stream %s%s\n", lis_strm_name(hd), lis_maj_min_name(hd)) ;
+      printk("  control:    %6d  %6d    %s\n",
+		  kctl.maxlen, kctl.len, ctl_type) ;
+      printk("     data:    %6d  %6d    %s\n",
+		  kdat.maxlen, kdat.len, dat_type) ;
+    }
+
+    lis_runqueues();
+    return(rtn);
+
+}/*lis_strgetpmsg*/
+
+
+/*  -------------------------------------------------------------------  */
+/* strioctl - handle IOCTLs at the stream head
+ *
+ * NOTE: This functions needs pretty much cleanup. Perhaps ioctling stuff
+ * should be moved to strioc.c (or alike). THe lis_runqueues() calls should
+ * be relocated, i.e. place them only when you think there could be
+ * things to be [STREAMS] scheduled.
+ */
+int
+lis_strioctl(struct inode *i, struct file *f, unsigned int cmd, unsigned long arg)
+{
+    stdata_t *hd;
+    int err=0,flush_pri=0;
+    cred_t creds;
+    streamtab_t *st;
+    const char        *name = "(unknown)" ;
+    const char	      *lis_maj_min = "" ;
+    pid_t pid=(pid_t)PID(f);
+
+    CHECK_INO(i,"lis_strioctl");
+    if (LIS_DEBUG_IOCTL && LIS_DEBUG_ADDRS)
+	printk("lis_strioctl: f=%lx f->f_inode=%lx i=%lx i->i_rdev=%x\n",
+	       (long) f, (long) f->f_inode, (long) i, i->i_rdev) ;
+
+    if (!(hd = INO_STR(i))) /* should lock/check also hd status */
+	return(-ENODEV);
+    if (!stravail(f))
+	return(-ENOSR); 
+    creds.cr_uid  = (uid_t) EUID(f);
+    creds.cr_gid  = (gid_t) EGID(f);
+    creds.cr_ruid = (uid_t) UID(f);
+    creds.cr_rgid = (gid_t) GID(f);
+    if ( LIS_DEBUG_IOCTL )
+    {
+	name = lis_strm_name(hd) ;
+	lis_maj_min = lis_maj_min_name(hd) ;
+    }
+
+    if (F_ISSET(hd->sd_flag,STPLEX))
+    {
+	if (LIS_DEBUG_IOCTL)
+	  printk(
+	    "strioctl: stream %s%s: stream has been I_LINKed\n",
+		name, lis_maj_min) ;
+
+	return(-EINVAL) ;
+    }
+
+
+    switch( cmd ){		/* the often an ioc is called the 
+				 * closer it should be to the begin of the sw*/
+    case I_PUSH:		/* tested */
+	if (F_ISSET(hd->sd_flag,STRHUP))
+	    return(-ENXIO);
+#ifdef FIFO_IMPL
+	if (LIS_ISDEV(STR_MAJOR(i->i_rdev),LIS_FIFO)) /* not ok for a fifo  */
+	    return(-ENXIO);
+#endif
+	if ((err=lis_check_umem(f,VERIFY_READ,(char*)arg,FMNAMESZ+1))<0)
+	    return(err);
+	else {
+	    char *mname;
+	    if((err=lis_copyin_str(f,(char*)arg,&mname,FMNAMESZ+1))<0)
+		return(err);
+
+	    if ( LIS_DEBUG_IOCTL )
+		printk("strioctl: I_PUSH \"%s\" below %s%s: ",
+			mname, name, lis_maj_min) ;
+
+	    if ((st = lis_modstr(lis_findmod(mname))) == NULL)
+	    {
+		err=-EINVAL;
+		if ( LIS_DEBUG_IOCTL )
+		    printk("module not found\n") ;
+
+		FREE((caddr_t)mname);
+	    }
+	    else
+	    {
+		FREE((caddr_t)mname);
+		err = lis_lock_wopen(hd);
+		if (err < 0) break ;
+
+		err=push_mod(hd,st,f->f_flags,&creds);
+		if ( LIS_DEBUG_IOCTL )
+		{
+		    if (err)	printk("error %d\n", err) ;
+		    else	printk("OK\n") ;
+		}
+
+		if (F_ISSET(hd->sd_flag,STRISTTY)){
+		    /* 
+		       we should make this the controling terminal...
+		     */
+		    hd->sd_pgrp = PGRP(f);
+		}
+		lis_unlock_wopen(hd);
+	    }
+	}
+	break;
+    case I_POP:		/* tested */
+      {
+	const char	*qname = "";
+
+	if (F_ISSET(hd->sd_flag,STRHUP))
+	    return(-ENXIO);
+	err = lis_lock_wopen(hd);
+	if (err < 0) break ;
+
+	if ( LIS_DEBUG_IOCTL )
+	    qname = lis_queue_name(hd->sd_wq->q_next) ;
+
+	err=pop_mod(hd,f->f_flags, &creds); 
+
+	if ( LIS_DEBUG_IOCTL )
+	{
+	    printk("strioctl: I_POP \"%s\" from stream %s%s: ",
+		    qname, name, lis_maj_min) ;
+
+	    if (err)	printk("error %d\n", err) ;
+	    else	printk("OK\n") ;
+	}
+
+	lis_unlock_wopen(hd);
+      }
+      break;
+    case I_LOOK:		/* tested */
+	err = lis_lock_wopen(hd);
+	if (err < 0)
+	    return(err) ;
+	if ((err=lis_check_umem(f,VERIFY_WRITE,(char*)arg,FMNAMESZ+1))<0)
+	    return(err);
+	if (!hd->sd_pushcnt)
+	    return(-EINVAL);
+	if ( LIS_DEBUG_IOCTL )
+	    printk("strioctl: I_LOOK: top driver/module of stream %s%s is \"%s\"\n",
+		    name, lis_maj_min, lis_queue_name(hd->sd_wq->q_next)) ;
+
+	name = lis_queue_name(hd->sd_wq->q_next) ;
+	lis_copyout(f,name, (char*)arg, strlen(name)+1);
+	lis_unlock_wopen(hd);
+	break;
+    case I_FLUSHBAND:
+	{
+	    struct bandinfo bi;
+	    if ((err=lis_check_umem(f,VERIFY_READ,
+				    (char*)arg,sizeof(bandinfo_t)))<0)
+		return(err);
+		lis_copyin(f,&bi,(char*)arg,sizeof(bandinfo_t));
+	    arg= bi.bi_flag|FLUSHBAND;
+	    flush_pri=bi.bi_pri;
+	}
+        /*fall thru...*/
+    case I_FLUSH:
+	if (F_ISSET(hd->sd_flag,STRHUP))
+	    return(-ENXIO);
+	if ( LIS_DEBUG_IOCTL )
+	    printk("strioctl: I_FLUSH arg=0x%lx\n", arg) ;
+
+	switch(arg & FLUSHRW){
+	case FLUSHR:
+#ifdef FIFO_IMPL
+	    if (LIS_ISDEV(STR_MAJOR(i->i_rdev),LIS_FIFO)){
+	      /*flush rw/other-wr for fifo;*/
+	    }
+	    else
+#endif
+	    {
+	      int res = lis_snd_mflush(LIS_WR(hd->sd_wq),FLUSHR,flush_pri);
+	      lis_runqueues();
+	      return(res);
+	    }
+	    break;
+	case FLUSHW:
+#ifdef FIFO_IMPL
+	    if (LIS_ISDEV(STR_MAJOR(i->i_rdev),LIS_FIFO)){
+		/*flush rw/other-wr for fifo;*/
+	    }
+	    else
+#endif
+	    {
+	      int res=lis_snd_mflush(LIS_WR(hd->sd_wq),FLUSHW,flush_pri);
+	      lis_runqueues();
+	      return(res);
+	    }
+	case FLUSHRW:
+#ifdef FIFO_IMPL
+	    if (LIS_ISDEV(STR_MAJOR(i->i_rdev),LIS_FIFO)){
+		/*flush rd/other-rd;*/
+	    }
+	    else
+#endif
+	    {
+		int res=lis_snd_mflush(LIS_WR(hd->sd_wq),FLUSHRW,flush_pri);
+		lis_runqueues();
+		return(res);
+	    }
+	default:
+	    return(-EINVAL);
+	}
+	break;
+    case I_SETSIG:
+	if (!arg){
+	    if (lis_del_from_elist(&(hd->sd_siglist),pid,S_ALL))
+		err = -EINVAL;
+	    else 
+		if (!hd->sd_siglist)
+		    hd->sd_sigflags=0;
+	}
+	else 
+	    if (lis_add_to_elist(&(hd->sd_siglist),pid, (short) arg))
+		err = -EAGAIN;
+	    else
+		F_SET(hd->sd_sigflags,arg);
+
+	if ( LIS_DEBUG_IOCTL || LIS_DEBUG_SIG )
+	{
+	    printk("strioctl: I_SETSIG: stream %s%s signal %ld: ",
+		    name, lis_maj_min, arg) ;
+	    if (err)	printk("error %d\n", err) ;
+	    else	printk("OK\n") ;
+	}
+
+	lis_runqueues();
+	break;
+    case I_GETSIG:
+	{
+	    int evs;
+
+	    if ( LIS_DEBUG_IOCTL )
+		printk("strioctl: I_GETSIG: stream %s%s: ",
+			name, lis_maj_min) ;
+
+	    err=lis_check_umem(f,VERIFY_WRITE,(char*)arg,sizeof(int)) ;
+	    if (   err == 0
+		&& (evs=(int)lis_get_elist_ent(hd->sd_siglist,pid)) == 0
+	       )
+		err = -EINVAL;
+
+	    if ( LIS_DEBUG_IOCTL )
+	    {
+		if (err)	printk("error %d\n", err) ;
+		else		printk("signal %d\n", evs) ;
+	    }
+
+	    if (err == 0)
+		lis_copyout(f,&evs,(char*)arg,sizeof(int));
+	}
+	break;
+    case I_FIND:		/* tested */
+	{
+	    char *mname;
+	    queue_t *q;
+
+	    err = lis_lock_wopen(hd);
+	    if (err < 0)
+		return(err) ;
+	    if ((err=lis_check_umem(f,VERIFY_READ,(char*)arg,FMNAMESZ+1))<0)
+		return(err);
+	    if (hd->sd_pushcnt){
+		if ((err=lis_copyin_str(f,(char*)arg,&mname,FMNAMESZ+1))<0)
+		    return(err);
+		if ( LIS_DEBUG_IOCTL )
+		    printk("strioctl: I_FIND: stream %s%s module \"%s\"\n",
+					    name, lis_maj_min, mname);
+		for (q=hd->sd_wq; 
+		     q && !strncmp(lis_queue_name(q),mname,FMNAMESZ);
+		     q=q->q_next )
+		    ;
+		if (q){		
+		    FREE(mname) ;
+		    lis_unlock_wopen(hd);
+		    lis_runqueues();
+		    return(1);	/* found! */
+		}
+	    }
+	    lis_unlock_wopen(hd);
+	    if (!lis_findmod(mname))
+	    {
+		FREE(mname) ;
+		return(-EINVAL);	/* not a valid module */
+	    }
+	    else {
+		FREE(mname) ;
+	        lis_runqueues();
+	        return(0);		/* not present */
+	    }
+	}
+    case I_PEEK:
+	{
+	    strpeek_t pb;
+	    strbuf_t *ctl=&(pb.ctlbuf), *dat=&(pb.databuf);
+	    int band =0;
+	    int res,flags;
+	    if (   (err=lis_check_umem(f,VERIFY_READ,
+				    (char*)arg,sizeof(strpeek_t)))<0
+		|| (err=lis_check_umem(f,VERIFY_WRITE,
+				    (char*)arg,sizeof(strpeek_t)))<0
+	       )
+		return(err);
+	    lis_copyin(f,&pb,(char*)arg,sizeof(strpeek_t));
+            flags=(int)pb.flags;
+	    res=lis_strgetpmsg(i,f,ctl,dat,&band,&flags,0); /*0-> just peek!*/
+            pb.flags=(long)flags;
+	    lis_copyout(f,&pb,(char*)arg,sizeof(strpeek_t));
+	    if ( LIS_DEBUG_IOCTL )
+		printk("strioctl: I_PEEK: stream %s%s flags=0x%x rslt=%d\n",
+					name, lis_maj_min, flags, res) ;
+	    lis_runqueues();
+	    return(res);
+	}
+	break;
+    case I_SRDOPT:
+      {
+	int res = set_readopt(&hd->sd_rdopt,arg);
+	if ( LIS_DEBUG_IOCTL )
+	    printk("strioctl: I_SRDOPT: stream %s%s arg=%ld rslt=%d\n",
+					name, lis_maj_min, arg, res) ;
+	lis_runqueues();
+	return(res);
+      }
+    case I_GRDOPT:
+	{
+	    int rmode;
+	    if ((err=lis_check_umem(f,VERIFY_WRITE,(char*)arg,sizeof(int)))<0)
+		return(err);
+	    rmode=hd->sd_rdopt;
+	    if ( LIS_DEBUG_IOCTL )
+		printk("strioctl: I_GRDOPT: stream %s%s mode=0x%x\n",
+					    name, lis_maj_min, rmode);
+	    lis_copyout(f,&rmode,(char*)arg,sizeof(int));
+	}	
+	break;
+    case I_NREAD:		/* tested */
+	{ 
+	    int bytes=0;
+	    if ((err=lis_check_umem(f,VERIFY_WRITE,(char*)arg,sizeof(int)))<0)
+		return(err);
+	    if (LIS_RD(hd->sd_wq)->q_first)
+		bytes=lis_msgdsize(LIS_RD(hd->sd_wq)->q_first);
+	    if ( LIS_DEBUG_IOCTL )
+		printk("strioctl: I_NREAD: stream %s%s bytes=%d\n",
+				name, lis_maj_min, bytes);
+	    lis_copyout(f,&bytes,(char*)arg,sizeof(int));
+	}
+	break;
+    case I_FDINSERT:
+	{
+	    if ( LIS_DEBUG_IOCTL )
+		printk("strioctl: I_FDINSERT: stream %s%s: not implemented\n",
+						name, lis_maj_min) ;
+	    return(-EINVAL);	/* not implemented */
+#if 0
+	    strfdinsert_t *fdins=copy sizeof(strfdinsert_t) from usr;
+	    fd= fd in strfdinsert;
+	    ihd= stdata for ifd;
+	    put ptr to the bottom (rd) queue of ihd in new a-la-putmsg msg at
+		given offset;
+#endif
+	}
+	break;
+    case I_STR:		/* tested */
+	if (F_ISSET(hd->sd_flag,STRHUP))
+	    return(-ENXIO);
+	else {
+	    strioctl_t ioc;
+	    int res;
+	    if ((err=lis_check_umem(f,VERIFY_READ,
+				    (char*)arg,sizeof(strioctl_t)))<0)
+		return(err);
+	    if ((err=lis_check_umem(f,VERIFY_WRITE,
+				    (char*)arg,sizeof(strioctl_t)))<0)
+		return(err);
+	    lis_copyin(f,&ioc,(char*)arg,sizeof(strioctl_t));
+	    res=lis_strdoioctl(f,hd,&ioc,&creds,1);
+	    lis_copyout(f,&ioc,(char*)arg,sizeof(strioctl_t));
+	    if ( LIS_DEBUG_IOCTL )
+	     printk(
+	      "strmioctl: I_STR: stream %s%s ic_cmd=0x%x ic_timout=%d ic_len=%d rslt=%d\n",
+			    name, lis_maj_min,
+			    ioc.ic_cmd, ioc.ic_timout, ioc.ic_len, res) ;
+		
+	    lis_runqueues();
+	    return(res);
+	}
+	break;
+    case I_SWROPT:
+	if ( LIS_DEBUG_IOCTL )
+	    printk("strioctl: I_SWROPT: stream %s%s arg=0x%lx\n",
+					name, lis_maj_min, arg) ;
+	hd->sd_wropt = arg ;
+	return(0) ;
+    case I_GWROPT:
+	if ((err=lis_check_umem(f,VERIFY_WRITE,(char*)arg,sizeof(int)))<0)
+	    return(err);
+
+	if ( LIS_DEBUG_IOCTL )
+	    printk("strioctl: I_GWROPT: stream %s%s mode=0x%x\n",
+				name, lis_maj_min, hd->sd_wropt);
+	lis_copyout(f,&hd->sd_wropt,(char*)arg,sizeof(int));
+	lis_runqueues();
+	return(0);
+    case I_SENDFD:
+	if ( LIS_DEBUG_IOCTL )
+	    printk("strioctl: I_SENDFD: stream %s%s: not implemented",
+	    				name, lis_maj_min) ;
+
+	return(-EINVAL);	/* not implemented */
+
+        /* copy strrecvfd (arg) struct from usr and get fd value; put it in a
+	   M_PASSFP msg and give it to the hd->q_next; it's assumed this is a
+	   streams pipe --see mg 7.10 */
+	
+	break;
+    case I_RECVFD:
+	if ( LIS_DEBUG_IOCTL )
+	    printk("strioctl: I_RECVFD: stream %s%s: not implemented",
+	    				name, lis_maj_min) ;
+	return(-EINVAL);	/* not implemented --see I_SENDFD*/
+	break;
+    case I_LIST:
+	if (!arg)		/* want number of modules */
+	{
+	    if ( LIS_DEBUG_IOCTL )
+		printk("strioctl: I_LIST: stream %s%s arg=NULL, return %d\n",
+				    name, lis_maj_min, hd->sd_pushcnt+1) ;
+	    return(hd->sd_pushcnt+1); /* +1 for driver  */
+	}
+	else {
+	    str_list_t list;
+	    queue_t   *q;
+	    int	       nmods ;
+	    if ((err=lis_check_umem(f,VERIFY_READ,(char*)arg,sizeof(str_list_t)))<0)
+		return(err);
+	    lis_copyin(f,&list,(char*)arg,sizeof(str_list_t));
+	    if (list.sl_nmods<=0)
+		return(-EINVAL);
+	    if ((err=lis_check_umem(f,VERIFY_WRITE,
+				 list.sl_modlist,
+				 sizeof(struct str_mlist)*list.sl_nmods)) <0)
+		return(err);
+
+	    if (hd->sd_wq == NULL || (q=hd->sd_wq->q_next) == NULL)
+	    {
+		printk("strioctl: I_LIST: stream %s%s: NULL queue ptrs\n",
+					name, lis_maj_min) ;
+		return(0) ;			/* really a bug */
+	    }
+
+	    for (nmods = 0; 
+		 q && list.sl_nmods-- ; 
+		 q=q->q_next, list.sl_modlist++, nmods++
+		)
+	    {
+		lis_copyout(f,lis_queue_name(q),
+			    list.sl_modlist->l_name,
+			    FMNAMESZ);
+	    }
+
+	    if ( LIS_DEBUG_IOCTL )
+		printk("strioctl: I_LIST: stream %s%s arg=non-NULL, return %d\n",
+				    name, lis_maj_min, nmods) ;
+	    return(nmods);
+	}
+	break;
+    case I_ATMARK:
+	{
+	    mblk_t	*mp ;
+	    int		 rtn = 0 ;
+
+	    /* Switch on arg and return whether the first msg in the
+	     * stream head read queue is marked if arg is ANYMARK.
+	     * Return whether is it the last marked message if arg is LASTMARK.
+	     */
+	    if (   hd->sd_wq == NULL		/* no queue */
+		|| LIS_RD(hd->sd_wq) == NULL	/* no rd queue */
+		|| (mp = LIS_RD(hd->sd_wq)->q_first) == NULL	/* no msg */
+	       )
+	    {
+		rtn = 0 ;			/* obviously not marked */
+	    }
+	    else
+	    switch (arg)
+	    {
+	    case ANYMARK:			/* is 1st msg marked?  */
+		rtn = (mp->b_flag & MSGMARK) ? 1 : 0 ;
+		break ;
+
+	    case LASTMARK:			/* is 1st msg the last marked */
+		if ( !(mp->b_flag & MSGMARK) )	/* 1st msg not marked at all */
+		{
+		    rtn = 0 ;			/* is not the last one, then */
+		    break ;
+		}
+
+		rtn = 1 ;			/* assume no other msg marked */
+		for (mp = mp->b_next; mp != NULL; mp = mp->b_next)
+		{
+		    if (mp->b_flag & MSGMARK)	/* some other msg is marked */
+		    {
+			rtn = 0 ;		/* condition not met */
+			break ;
+		    }
+		}
+
+		break ;
+
+	    default:
+		rtn = -EINVAL;			/* invalid argument */
+	    }
+
+	    if ( LIS_DEBUG_IOCTL )
+		printk("strioctl: I_ATMARK: stream %s%s: arg=%ld, return %d\n",
+				    name, lis_maj_min, arg, rtn) ;
+	    return(rtn) ;
+	}
+	break;
+    case I_CKBAND:
+	if ( LIS_DEBUG_IOCTL )
+	    printk("strioctl: I_CKBAND: stream %s%s arg=%ld\n",
+				    name, lis_maj_min, arg) ;
+	if ( arg > LIS_MAX_BAND )
+	    return(-EINVAL);
+	else {
+	    long val = 0;
+	    
+	    err = lis_strqget(LIS_RD(hd->sd_wq),QCOUNT,(char)arg, &val) ; 
+	    if (err) 
+		val = -err ;			/* failed */
+	    else
+		val = (val != 0) ? 1 : -1 ;	/* AT&T STREAMS pgrmr's guide */
+
+	    lis_runqueues();
+	    return(val);
+	}
+	break;
+    case I_GETBAND:
+	{
+	    int res;
+	    if ((err=lis_check_umem(f,VERIFY_WRITE,(char*)arg,sizeof(int)))<0)
+		return(err);
+	    if (!LIS_RD(hd->sd_wq)->q_first)
+		return(-ENODATA);
+	    res=LIS_RD(hd->sd_wq)->q_first->b_band;
+	    if ( LIS_DEBUG_IOCTL )
+		printk("strioctl: I_GETBAND: stream %s%s rslt=%d\n",
+					name, lis_maj_min, res) ;
+	    lis_copyout(f,&res,(char*)arg,sizeof(int));
+	    lis_runqueues();
+	    return(0);
+	}
+	break;
+    case I_CANPUT:
+        {
+	    int	res ;
+	    lis_runqueues();
+	    if ( arg > LIS_MAX_BAND )
+		return(-EINVAL);
+	    else 
+	    {
+		res = lis_bcanputnext(hd->sd_wq, (unsigned char) arg);
+		if ( LIS_DEBUG_IOCTL )
+		    printk("strioctl: I_CANPUT: stream %s%s rslt=%d\n",
+				    name, lis_maj_min, res) ;
+		return(res) ;
+	    }
+        }
+	break;
+    case I_SETCLTIME:
+	if (arg >LIS_MAX_CLTIME)
+	    return(-EINVAL);
+	hd->sd_closetime=arg;
+	if ( LIS_DEBUG_IOCTL )
+	    printk("strioctl: I_SETCLTIME: stream %s%s arg=%ld\n",
+				    name, lis_maj_min, arg) ;
+	return(0);
+	break;
+    case I_GETCLTIME:
+	{
+	    int res;
+	    if ((err=lis_check_umem(f,VERIFY_WRITE,(char*)arg,sizeof(int)))<0)
+		return(err);
+	    res=hd->sd_closetime;
+	    if ( LIS_DEBUG_IOCTL )
+		printk("strioctl: I_GETCLTIME: stream %s%s rslt=%d\n",
+					name, lis_maj_min, res) ;
+	    lis_copyout(f,&res,(char*)arg,sizeof(int));
+	    return(0);
+	}
+	break;
+    case I_PLINK:		
+	/*fall through...  */
+    case I_LINK:		/* link arg(=fd) stream below this one */
+				/* see magic garden 7.5.1              */
+				/* also AT&T STREAMS Pgrmr's Guide Chapt 10 */
+	if (F_ISSET(hd->sd_flag,STRDERR)||
+	    F_ISSET(hd->sd_flag,STWRERR))
+	    return(-EINVAL);
+	if (F_ISSET(hd->sd_flag,STRHUP))
+	    return(-ENXIO);
+
+	if (   hd->sd_strtab->st_muxrinit == NULL
+	    || hd->sd_strtab->st_muxwinit == NULL
+	   )					/* must have lower qinits */
+	    return(-EINVAL);
+
+	err = lis_i_link(i, f, hd, (int) arg, cmd, &creds) ;
+	lis_runqueues();
+	return(err) ;
+	
+    case I_PUNLINK:
+	/*fall through...  */
+    case I_UNLINK:
+	if (F_ISSET(hd->sd_flag,STRHUP))
+	    return(-ENXIO);
+	if ((long) arg < -1)		/* compare as signed quantity */
+	    return(-EINVAL);
+
+	err = lis_lock_wopen(hd);
+	if (err >= 0)
+	{
+	    err = lis_i_unlink(i, f, hd, (int)arg, cmd, &creds ) ;
+	    lis_unlock_wopen(hd);
+	}
+
+	lis_runqueues();
+	return(err) ;
+
+    case I_LIS_GETSTATS:		/* LiS only - return stats */
+	err = lis_check_umem(f,VERIFY_WRITE,(char*)arg, sizeof(lis_strstats)) ; 
+	if (err < 0)
+	    return(err);
+
+	lis_copyout(f,lis_strstats,(char*)arg,sizeof(lis_strstats));
+	return(0);
+
+    case I_LIS_PRNTSTRM:		/* LiS only - print stream */
+	lis_print_stream(hd) ;
+	break;
+
+    case I_LIS_PRNTMEM:			/* LiS only - print memory */
+	lis_print_mem() ;		/* maybe an suser() check */
+	break;
+
+    case I_LIS_SDBGMSK:			/* LiS only - set debug mask */
+	lis_debug_mask = arg ;		/* maybe an suser() check */
+	break;
+
+    case I_LIS_GET_MAXMSGMEM:		/* LiS only - get max msg mem */
+	err = lis_check_umem(f,VERIFY_WRITE,(char*)arg, sizeof(long)) ; 
+	if (err < 0)
+	    return(err);
+
+	lis_copyout(f,&lis_max_msg_mem,(char*)arg,sizeof(lis_max_msg_mem));
+	break;
+
+    case I_LIS_SET_MAXMSGMEM:		/* LiS only - set max msg mem */
+	if (!lis_suser(f))
+	    return(-EINVAL) ;
+
+	lis_max_msg_mem = arg ;
+	lis_strstats[MSGMEMLIM][MAXIMUM] = lis_max_msg_mem ;
+	break;
+
+    case I_LIS_GET_MAXMEM:		/* LiS only - get max mem */
+	err = lis_check_umem(f,VERIFY_WRITE,(char*)arg, sizeof(long)) ; 
+	if (err < 0)
+	    return(err);
+
+	lis_copyout(f,&lis_max_mem,(char*)arg,sizeof(lis_max_mem));
+	break;
+
+    case I_LIS_SET_MAXMEM:		/* LiS only - set max mem */
+	if (!lis_suser(f))
+	    return(-EINVAL) ;
+
+	lis_max_mem = arg ;
+	lis_strstats[MEMLIM][MAXIMUM] = lis_max_mem ;
+	break;
+
+
+    default:
+	/* encapsulate ioctl(fd,cmd,arg)as if the user specified 
+	 * instead     ioctl(fd,I_STR,{cmd,arg})
+	 * and pass down to strdoioctl()
+	 * apps should not use transparent ioctls (*this* ioclts) as
+	 * the ioctl processing module will have to issue
+	 * M_COPY{IN,OUT} msgs to get the usr buffer pointed by arg
+	 */
+	{
+	    strioctl_t ioc;
+	    int res;
+	    ioc.ic_cmd=cmd;
+	    ioc.ic_timout=LIS_LNTIME;
+	    ioc.ic_len=0;
+	    ioc.ic_dp=(char*)arg;
+	    res=lis_strdoioctl(f,hd,&ioc,&creds,1);
+	    if ( LIS_DEBUG_IOCTL )
+		printk("strioctl: stream %s%s ic_cmd=0x%x ic_timout=%d ic_len=0 rslt=%d\n",
+			    name, lis_maj_min,
+			    ioc.ic_cmd, ioc.ic_timout, res) ;
+	    lis_runqueues();
+	    return(res);
+	}
+    }/*sw cmd*/
+    lis_runqueues();
+    return(err);
+}/*lis_strioctl*/
+
+/*  -------------------------------------------------------------------  */
+/* strpoll - called from lis_syspoll() poll() syscall handler
+ *
+ * The STREAMS poll function is called with the file info and
+ * a pointer to a polldat structure.  The STREAMS routine
+ * interrogates the file for the requested conditions according
+ * to the 'pd_events' field in the polldat structure.  It returns
+ * a bit-mask of the events that satisfy the conditions, if any.
+ * The STREAMS routine also sets the pd_headp pointer to point to
+ * its list head in its stream structure for the polldat list.
+ * The caller takes care of linking the structure into the list.
+ */
+int
+lis_strpoll(struct inode *i, struct file *f, void *ptr)
+{
+    polldat_t		*pdat_ptr  = (polldat_t *) ptr ;
+    int			 revents   = 0 ;
+    int			 events    = pdat_ptr->pd_events ;
+    int			 mtype ;
+    stdata_t		*hd;
+    mblk_t		*mp ;
+
+#define	RTN(e)		{revents = e; goto return_point; }
+
+    (void) f ;				/* reference 'f' for compiler */
+
+    if (   !(hd = INO_STR(i))
+	|| hd->magic != STDATA_MAGIC
+       )
+	RTN(POLLNVAL) ;
+
+    if ( F_ISSET(hd->sd_flag,(STRDERR|STWRERR)) )
+	RTN(POLLERR) ;
+
+    if (F_ISSET(hd->sd_flag,(STRHUP|STRCLOSE)))
+	RTN(POLLHUP) ;
+
+    if (F_ISSET(hd->sd_flag,STPLEX))
+    {
+	if (LIS_DEBUG_POLL)
+	  printk(
+	    "strpoll: stream %s%s: stream has been I_LINKed\n",
+		lis_strm_name(hd), lis_maj_min_name(hd)) ;
+
+	RTN(POLLNVAL) ;
+    }
+
+    /*
+     * Is user asking for read-oriented conditions?
+     */
+    if (   F_ISSET(events, (POLLIN | POLLRDNORM | POLLRDBAND | POLLPRI))
+        && (mp = LIS_RD(hd->sd_wq)->q_first) != NULL	/* mp is 1st msg */
+       )
+    {
+	mtype = lis_btype(mp) ;
+	if (lis_hipri(mtype))
+		revents |= POLLPRI ;
+	else
+	{
+	    revents |= POLLIN ;			/* other than hi pri msg */
+
+	    if ( events & (POLLRDNORM | POLLRDBAND | POLLMSG) )
+	    {
+		switch (mtype)
+		{
+		case M_DATA:
+		case M_PROTO:
+		    if (mp->b_band > 0)
+			revents |= POLLRDBAND ;
+		    else
+			revents |= POLLRDNORM ;
+		    break ;
+
+		case M_SIG:
+		    if (lis_getint(&mp->b_rptr) == SIGPOLL)
+			revents |= POLLMSG ;
+		    break ;
+		}
+	    }
+	}
+    }
+
+    if ((events & POLLWRNORM) && lis_bcanputnext(hd->sd_wq, 0))
+	revents |= POLLWRNORM ;			/* can write band 0 data */
+
+    if ((events & POLLWRBAND) && lis_bcanputnext_anyband(hd->sd_wq->q_next))
+	revents |= POLLWRBAND ;			/* can write band > 0 */
+
+    /*
+     * Restrict returned events to those that were asked for.
+     */
+    revents &= events ;
+
+    pdat_ptr->pd_headp = &hd->sd_polllist ;	/* ptr to list hd struct */
+						/* allows insertion */
+return_point:
+
+    if ( LIS_DEBUG_POLL )
+	printk("strpoll: stream %s%s: events:%s revents:%s\n",
+		lis_strm_name(hd), lis_maj_min_name(hd),
+	      lis_poll_events((short)events), lis_poll_events((short)revents)) ;
+
+    return(revents) ;				/* return events */
+
+#undef RTN
+
+} /* lis_strpoll */
+
+/*  -------------------------------------------------------------------  */
+/*  lis_wakeup_close
+ *
+ * This routine is used as a timout routine and as a utility function.
+ * The argument is really a pointer to a streamhead structure.
+ */
+int	lis_wakeup_close(caddr_t arg)
+{
+    stdata_t	*hd = (stdata_t *) arg ;
+
+    if (hd->magic == STDATA_MAGIC)
+    {
+	untimeout(hd->sd_close_timer) ;		/* cancel timer, just in case */
+	lis_up(&hd->sd_closing) ;			/* semaphore wakeup */
+    }
+
+    return(0) ;					/* compiler happiness */
+
+} /* lis_wakeup_close */
+
+/*  -------------------------------------------------------------------  */
+/* strclose - dec refcnt & dismantle the stream when sd_refcnt gets 0.
+ */
+static int
+lis_doclose(struct inode *i, struct file *f, struct stdata *head, cred_t *creds)
+{
+    pid_t	   pid = (pid_t) PID(f);
+    int		   err ;
+    int		   refcnt ;
+
+    err = lis_lock_wopen(head);
+    if (err < 0)
+	printk("lis_strclose: error %d locking stream head, closing anyway\n",
+		err) ;
+
+    lis_sub_filetbl(head, f) ;			/* remove file from tbl */
+    lis_del_from_elist(&head->sd_siglist,pid,S_ALL);
+
+    if ( LIS_DEBUG_CLOSE )
+    {
+	printk("lis_strclose: closing stream %s%s refcnt=%d linkcnt=%d\n",
+		lis_strm_name(head),
+		lis_maj_min_name(head),
+		head->sd_refcnt, head->sd_linkcnt ) ;
+	printk("              head-q:\"%s\" driver-q:\"%s\"\n",
+		lis_queue_name(head->sd_wq),
+		lis_queue_name(head->sd_wq->q_next)) ;
+    }
+
+    head->sd_refcnt-- ;				/* decr ref count */
+    refcnt = head->sd_refcnt ;			/* will return this */
+
+    /*
+     * If the reference count is now down to the plink count
+     * then all that is left are the plinks.  This means that
+     * this is really the last close of the stream and the inode
+     * is about to disappear.  We clear the inode ptr in the
+     * stdata structure.  There will be no more accesses of
+     * this stream from above via the file system.
+     *
+     * The stream remains allocated but cannot be reached via an
+     * open.  Open will allocate a new stdata structure upon a
+     * re-open.
+     */
+    if (head->sd_linkcnt != 0 && head->sd_refcnt <= head->sd_linkcnt)
+    {
+	lis_free_elist(&head->sd_siglist);	/* do in signal masks */
+    }
+    
+    if (head->sd_refcnt == 0)			/* dismantle stream */
+    {
+	head->sd_flag |= STRCLOSE ;
+	if (   head->sd_closetime != 0		/* have close time set */
+	    && lis_qcountstrm(head->sd_wq) != 0	/* messages queued */
+	   )
+	{					/* set a timer */
+	    if ( LIS_DEBUG_CLOSE )
+	      printk(
+		"lis_strclose: stream %s%s waiting %dms for queues to drain\n",
+			lis_strm_name(head), lis_maj_min_name(head),
+			head->sd_closetime);
+
+	    head->sd_wq->q_next->q_flag |= QCLOSING ;
+	    head->sd_close_timer = lis_timeout_fcn(lis_wakeup_close,
+					   (caddr_t) head,
+					   (head->sd_closetime*HZ)/1000,
+					   "stream-close", MEM_TIMER) ;
+	    lis_down(&head->sd_closing) ;		/* sleep for awhile */
+	}
+
+	lis_free_elist(&head->sd_siglist);	/* do in signal masks */
+	if (head->sd_mux.mx_hd != NULL)		/* is a ctl stream */
+	    lis_i_unlink(i, f, head, -1,
+			 I_PUNLINK, creds) ;	/* unlink all lowers */
+
+	/* if M_PASSFD implemented then 
+	      we should close fds; */
+	while (!pop_mod(head,head->sd_open_flags,creds))
+	    ;
+
+	lis_qdetach(LIS_RD(head->sd_wq->q_next),1,head->sd_open_flags,creds);
+	lis_dismantle(head, creds);		/* deallocate head */
+						/* must be last thing */
+    }
+    else				/* still has users, unlock it */
+	lis_unlock_wopen(head);
+
+    if ( LIS_DEBUG_CLOSE )
+	printk("lis_strclose: %ld open streams\n", lis_stdata_cnt) ;
+
+    return(refcnt);
+								     
+} /*lis_doclose*/
+
+void
+lis_strclose(struct inode *i, struct file *f)
+{
+    struct stdata *head;
+    cred_t	   creds;
+    
+    lis_close_cnt++ ;
+    if ( LIS_DEBUG_CLOSE )
+    {
+	printk("lis_strclose: call number %ld\n", lis_close_cnt) ;
+	if (LIS_DEBUG_ADDRS)
+	      printk("lis_strclose: f=%lx f->f_inode=%lx i=%lx i->i_rdev=%x\n",
+			   (long) f, (long) f->f_inode, (long) i, i->i_rdev) ;
+    }
+
+    if (!i) {
+	lis_error(LIS_ERROR,"lis_strclose","called w/ null inode");
+	return;
+    }
+
+    if (!S_ISCHR(i->i_mode))
+	return;
+
+    if (!LIS_DEVOK(STR_MAJOR(i->i_rdev)))
+	return;
+
+    if (!(head=INO_STR(i))){
+	lis_error(LIS_ERROR,"lis_strclose",
+		  "called with null stream (inode 0x%x)",i);
+	return;
+    }    
+
+    creds.cr_uid  = (uid_t) EUID(f);
+    creds.cr_gid  = (gid_t) EGID(f);
+    creds.cr_ruid = (uid_t) UID(f);
+    creds.cr_rgid = (gid_t) GID(f);
+
+    if (lis_doclose(i, f, head, &creds) == 0)	/* last close, gone */
+	INO_STR(i) = NULL ;			/* unhook inode ptr */
+
+} /* lis_strclose */
+
+/*  -------------------------------------------------------------------  */
+
+/* Initialize some glob vars...
+ */
+void lis_init_head( void )
+{
+  module_config_t	*modp ;
+  driver_config_t	*drvp ;
+
+  /* We'd better use defaults from strconfig instead of magic #s.
+   */
+  lis_qhead = lis_qtail =  lis_scanqhead= lis_scanqtail = NULL;
+  lis_queues_running = 0;
+  lis_nstrpush = 0;
+  lis_strhold = 0;
+  lis_strthresh = 0;
+  lis_fmodcnt = 1 ;
+  /*lis_iocseq=whichever get's in the air -- so we have some kind of random
+   *number for this seq # <-should be fixed*/
+
+  for (modp = lis_module_config; modp->cnf_str != NULL; modp++)
+    if (lis_register_strmod(modp->cnf_str, modp->cnf_name) < 0) break ;
+
+  for (drvp = lis_driver_config; drvp->cnf_str != NULL; drvp++)
+    if (lis_register_strdev(drvp->cnf_major,
+			    drvp->cnf_str,
+			    drvp->cnf_n_minors,
+			    drvp->cnf_name ) < 0) break ;
+
+}/*lis_init_head*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/init.c /usr/src/linux/drivers/streams/LiS/head/init.c
--- debug/drivers/streams/LiS/head/init.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/init.c	Mon Dec 16 16:36:37 1996
@@ -0,0 +1,121 @@
+/*                               -*- Mode: C -*- 
+ * init.c --- 
+ * Author          : David Howells
+ * Created On      : 
+ * Last Modified By: 
+ * Last Modified On: 
+ * Update Count    : 0
+ * RCS Id          : : init.c$
+ * Usage           : see below :)
+ * Required        : see below :)
+ * Status          : 
+ * Prefix(es)      : 
+ * Requeriments    : 
+ * Purpose         : 
+ *                 : 
+ * ----------------______________________________________________
+ *   Copyright (C) 1995  Denis Froschauer
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Library General Public
+ *    License as published by the Free Software Foundation; either
+ *    version 2 of the License, or (at your option) any later version.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Library General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Library General Public
+ *    License along with this library; if not, write to the Free
+ *    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach me by email to
+ *    100741.1151@compuserve.com
+ */
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <asm/system.h>
+#include <sys/strconfig.h>	/* streams config symbols are here */
+#include <sys/stream.h>
+#include <sys/poll.h>		/* usr structs */
+
+#include <sys/LiS/streamsdrv.h>
+
+asmlinkage void streams_init(void);
+
+/*****************************************************************************/
+/* dummy streams module */
+static module_info_t MOD_mi;
+static streamtab_t MOD_s;
+
+/* module linkage */
+static LiS_module_t MOD_lm = {
+    LIS_MODULE_MAGIC,						/* lm_magic */
+    "dummyMOD",							/* lm_name */
+    "Dummy STREAMS test module\n(c) D.W.Howells 1995\n",	/* lm_desc */
+    &MOD_mi,							/* lm_minfo */
+    &MOD_s,							/* lm_access */
+    0,								/* lm_usage */
+    LIS_NULL_MID						/* lm_idnum */
+};
+
+/*****************************************************************************/
+/* dummy streams driver */
+static module_info_t DRV_mi;
+static streamtab_t DRV_s;
+
+/* module linkage */
+static LiS_driver_t DRV_ld = {
+    LIS_DRIVER_MAGIC,						/* ld_magic */
+    18,								/* ld_major */
+    "dummyDRV",							/* ld_name */
+    "Dummy STREAMS test driver\n(c) D.W.Howells 1995\n",	/* ld_desc */
+    &DRV_mi,							/* ld_minfo */
+    &DRV_s,							/* ld_access */
+    0,								/* ld_usage */
+    							      /* ld_automods */
+};
+
+/*****************************************************************************/
+/* dummy file ops */
+int
+lis_stropen(struct inode *i, struct file *f)
+{
+    return -ENODEV;
+}
+
+struct file_operations
+lis_streams_fops = {
+	NULL,			/* lseek   -- no lseek  */
+	NULL,			/* read    */
+	NULL,			/* write to stream      */
+	NULL,			/* readdir -- no readdir*/
+	NULL,			/* select  */
+	NULL,			/* ioctl   */
+	NULL,			/* mmap    -- no mmap   */
+	lis_stropen,		/* open the stream      */
+	NULL,			/* close   */
+	NULL,			/* fsync   -- no fsync  */
+	NULL,			/* fasync  -- no fasync */
+	NULL,			/* check_media_change	*/
+	NULL,			/* revalidate		*/
+	NULL,			/* putpmsg & putmsg	*/
+	NULL,			/* getpmsg & getmsg	*/
+};
+
+/*****************************************************************************/
+/* streams_init() - STREAMS bootup initialization entry point
+ *
+ * STATUS: incomplete, untested
+ */
+asmlinkage void
+streams_init()
+{
+    printk("Inititalizing STREAMS subsystem\n");
+    lis_register_driver(&DRV_ld);
+    lis_register_module(&MOD_lm);
+} /* end streams_init() */
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/linux/Makefile /usr/src/linux/drivers/streams/LiS/head/linux/Makefile
--- debug/drivers/streams/LiS/head/linux/Makefile	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/linux/Makefile	Wed Jan  8 08:51:05 1997
@@ -0,0 +1,88 @@
+#
+# Environment of LINUX means the intent is to link the code into the
+# Linux kernel.
+#
+ENV	= -DLINUX
+SRC	= ..
+TOP	= $(SRC)/..
+GNU	= -DINLINE=""
+GNU	= -DINLINE=inline
+OG	= -O3 -pg
+OG	= -O3
+OG	= -g
+OG	= -O2 -g
+INCL	= -I../user
+CCOPT	= $(OG) $(GNU) -DSAFE -Wall -Wshadow -Wstrict-prototypes
+CCOPT	= $(OG) $(GNU) $(INCL) -DSAFE -Wall          -Wstrict-prototypes -DANSI
+DEBUG_MASK	= -DDEBUG_MASK=0x0FFFFFFF
+DEBUG_MASK	= 
+UTILDIR	= $(TOP)/util
+UTILOBJ	= $(UTILDIR)/linux
+UTILOBJ	= /usr/local/bin
+#
+# LIBDIR is defined on the command line by the invoking makefile
+#
+
+#
+# Initial targets
+#
+all:	strms strms+config makenodes
+
+util:	
+	cd $(UTILOBJ); make
+
+include ../Makefile.standalone
+
+strms+config:	$(LIBDIR)/streams.a modconf.o poll.o
+	ar r $(LIBDIR)/streams.a modconf.o poll.o
+	touch strms+config
+#
+# module configuration is compiled here so that is can be customized
+# for each installation
+#
+modconf.o:	modconf.c
+	$(CC) -c -o $(TMP)/$@ modconf.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+
+#
+# this file is built by the strconf utility program
+# We will start automatically assigned major numbers for STREAMS
+# drivers at 51.
+#
+modconf.c:	config $(UTILOBJ)/strconf
+	$(UTILOBJ)/strconf -b51 config
+
+#
+# this file is built by the strconf utility program
+#
+makenodes.c:	config $(UTILOBJ)/strconf
+	$(UTILOBJ)/strconf	config
+
+makenodes:	makenodes.c
+	$(CC) -o $(TMP)/$@	makenodes.c
+	cp $(TMP)/$@ .
+	-$(RM) $(TMP)/$@
+
+clean:	FORCE
+	-$(RM) *.o *.a strms+config
+
+#
+# Test program for STREAMS.  Source code resides in ../user
+#
+strtst:	strtst.o 
+	$(CC) -o $@ strtst.o 
+	
+strtst.o:	$(UTILDIR)/strtst.c 
+	$(CC) -c -U__KERNEL__ -g $(UTILDIR)/strtst.c
+
+
+#
+# Timing test program for STREAMS.  Source code resides in ../user
+#
+timetst:	timetst.o 
+	$(CC) -o $@ timetst.o 
+	
+timetst.o:	$(UTILDIR)/timetst.c 
+	$(CC) -c -U__KERNEL__ -g $(UTILDIR)/timetst.c
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/linux/config /usr/src/linux/drivers/streams/LiS/head/linux/config
--- debug/drivers/streams/LiS/head/linux/config	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/linux/config	Mon Dec 16 16:36:37 1996
@@ -0,0 +1,55 @@
+#
+# Configuration file for STREAMS device drivers
+#
+# Driver specifications
+#
+# The clone driver has a fixed major number.  Others can be allocated
+# automatically.
+#
+#	name		prefix	major	n-minors
+driver	clone-drvr	clone_	50
+driver	loop-around	loop_	*
+driver	mini-mux	mux_	*
+driver	runq		runq_	*
+driver	printk		printk_	*
+#driver	rsys		Rsys	*
+#driver	cdip		cdip	*
+#driver	dlpi		dlpi	*
+#driver	npip		npip	*
+
+#
+# Pushable module specifications
+#
+#	name		prefix
+module	relay		relay_
+module	relay2		relay2_
+
+#
+# Node specifications
+#
+#	name	          type	perm	major		minor
+node	/dev/loop.1	     c	0644	loop-around	1
+node	/dev/loop.2	     c	*	loop-around	2
+node	/dev/loop_clone	     c	*	clone-drvr	loop-around
+node	/dev/mux_clone	     c	*	clone-drvr	mini-mux
+node	/dev/clone_drvr	     c	*	clone-drvr	0
+node	/dev/runq	     c  0600	runq		0
+node	/dev/printk	     c	*	printk		0
+#node	/dev/rsys	     c  *	rsys		0
+#node	/dev/rsys1	     c  *	rsys		1
+#node	/dev/rsys_clone	     c  *	clone-drvr	rsys
+#node	/dev/cdip	     c  *	cdip		0
+#node	/dev/cdip_clone	     c  *	clone-drvr	cdip
+#node	/dev/dlpi	     c  *	dlpi		0
+#node	/dev/dlpi1	     c  *	dlpi		1
+#node	/dev/dlpi_clone	     c  *	clone-drvr	dlpi
+#node	/dev/npip	     c  *	npip		0
+#node	/dev/npip_clone	     c  *	clone-drvr	npip
+
+#
+# Device specifications
+#
+#	drvr-name	unit  port nports share	IRQ     mem M-size DMA1 DMA2
+#device	cdip		   0 0x310     16     S  10 0xD0000 0x4000
+#device	cdip		   1     0      0     S  10       0      0
+
Binary files debug/drivers/streams/LiS/head/linux/makenodes and /usr/src/linux/drivers/streams/LiS/head/linux/makenodes differ
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/linux/port.c /usr/src/linux/drivers/streams/LiS/head/linux/port.c
--- debug/drivers/streams/LiS/head/linux/port.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/linux/port.c	Mon Dec 16 16:36:38 1996
@@ -0,0 +1,3 @@
+/*
+ * This is a dummy file that is here just to keep the makefile happy
+ */
Binary files debug/drivers/streams/LiS/head/linux/strtst and /usr/src/linux/drivers/streams/LiS/head/linux/strtst differ
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/linux-mdep.c /usr/src/linux/drivers/streams/LiS/head/linux-mdep.c
--- debug/drivers/streams/LiS/head/linux-mdep.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/linux-mdep.c	Wed Jan  1 14:13:02 1997
@@ -0,0 +1,490 @@
+/*                               -*- Mode: C -*- 
+ * linux-mdep.c --- Linux kernel dependent support for LiS.
+ * Author          : Francisco J. Ballesteros
+ * Created On      : Sat Jun  4 20:56:03 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: linux-mdep.c,v 1.8 1996/01/26 16:53:01 dave Exp $
+ * Purpose         : provide Linux kernel <-> LiS entry points.
+ * ----------------______________________________________________
+ *
+ *    Copyright (C) 1995  Francisco J. Ballesteros, Denis Froschauer
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach me by email to
+ *    nemo@ordago.uc3m.es, 100741.1151@compuserve.com
+ *    dave@gcom.com
+ */
+
+
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#include <sys/LiS/linux-mdep.h>	/* interface */
+#include <sys/LiS/errmsg.h>	/* LiS err msg types */
+#include <sys/LiS/buffcall.h>	/* bufcalls */
+#include <sys/LiS/head.h>	/* stream head */
+#include <sys/stream.h>		/* LiS entry points */
+#include <sys/cmn_err.h>
+#include <sys/poll.h>
+#include <linux/fs.h>		/* linux file sys externs */
+#ifdef VERSION_2
+#include <asm/semaphore.h>	/* kernel semaphore routines */
+#endif
+/*  -------------------------------------------------------------------  */
+
+/* This should be entry points from the kernel into LiS
+ * kernel should be fixed to call them when appropriate.
+ */
+
+
+struct file_operations
+lis_streams_fops = {
+	NULL,			/* lseek   -- no lseek  */
+	lis_strread,		/* read    		*/
+	lis_strwrite,		/* write to stream      */
+	NULL,			/* readdir -- no readdir*/
+	lis_select,		/* select  		*/
+	lis_strioctl,		/* ioctl   		*/
+	NULL,			/* mmap    -- no mmap   */
+	lis_stropen,		/* open the stream      */
+	lis_strclose,		/* close   		*/
+	NULL,			/* fsync   -- no fsync  */
+	NULL,			/* fasync  -- no fasync */
+	NULL,			/* check_media_change	*/
+	NULL			/* revalidate		*/
+};
+
+/* some kernel memory has been free'd 
+ * tell STREAMS
+ */
+void lis_memfree( void )
+{
+}/*lis_memfree*/
+
+/* This will copyin usr string pointed by ustr and return the result  in
+ * *kstr. It will stop at  '\0' or max bytes copyed in.
+ * caller should call FREE(*kstr) on success.
+ * Will return 0 or errno
+ * STATUS: complete, untested
+ */
+int 
+lis_copyin_str(struct file *f, const char *ustr, char **kstr, int max)
+{
+	int i=max, error;
+	char  *tmp, c;
+	char  *mem ;
+
+	(void) f ;
+	if (max <= 0)
+	    return(-ENOMEM);
+	error = -EFAULT;
+	c = get_fs_byte(ustr++);
+	if (!c)
+	    return(-EINVAL);
+	if((mem = ALLOCF(max,"copyin-buf ")) == NULL)
+	    return(-ENOMEM);
+	*kstr = tmp = mem ;
+	while (--i) {
+	    *(tmp++) = c;
+	    c = get_fs_byte(ustr++);
+	    if (!c) {
+		*tmp = '\0';
+		return(0);
+	    }
+	}
+	FREE(mem);
+	return(error);
+}/*lis_copyin_str*/
+
+
+/*  -------------------------------------------------------------------  */
+/*
+ * lis_down
+ *
+ * This routine is patterned after the Linux __down() function from
+ * linux/sched.c.  This version watches for signals and returns
+ * < 0 if the process has been signalled.  It returns 0 for a
+ * good wakeup.
+ */
+int     
+lis_down(struct semaphore *sem)
+{
+#ifdef VERSION_2
+	return(down_interruptible(sem)) ;
+#else
+        struct wait_queue wait = { current, NULL };
+	int		  rslt = 0 ;
+
+	if (sem->count > 0)		/* available */
+	{
+	    ((volatile)sem->count)-- ;		/* one less on counter */
+	    return(0) ;
+	}
+
+        add_wait_queue(&sem->wait, &wait);
+        current->state = TASK_INTERRUPTIBLE;
+        while (sem->count <= 0) {
+                schedule();
+		/*
+		 * Check for signal
+		 */
+		if (current->signal & ~current->blocked)
+		{
+		    rslt = -EINTR ;	/* interrupted system call */
+		    break ;
+		}
+
+                current->state = TASK_INTERRUPTIBLE;
+        }
+        current->state = TASK_RUNNING;
+        remove_wait_queue(&sem->wait, &wait);
+	if (rslt >= 0)				/* if not signalled */
+	    ((volatile)sem->count)-- ;		/* one less on counter */
+
+	return(rslt) ;
+
+#endif
+
+} /* lis_down */
+
+
+
+/*  -------------------------------------------------------------------  */
+/* get a err msg for error level
+ */
+char  *lis_errmsg( int lvl )
+{
+    switch(lvl){
+    case LIS_PANIC:
+	return(KERN_EMERG);
+    case LIS_ERROR:
+	return(KERN_ERR);
+    case LIS_WARN:
+	return(KERN_WARNING);
+    case LIS_DEBUG:
+	return(KERN_DEBUG);
+    default:
+	return("unknown severity");
+    }
+} /*lis_errmsg*/
+
+/*  -------------------------------------------------------------------  */
+/*				    Timeouts                             */
+
+void
+lis_tmout(struct timer_list *tl, void (*fn)(ulong), long arg, long ticks)
+{
+    init_timer(tl);
+    tl->function= fn;
+    tl->data	= arg;
+    tl->expires	= jiffies + ticks;
+    add_timer(tl);
+}
+
+void
+lis_untmout( struct timer_list *tl)
+{
+    del_timer(tl);
+}
+
+/************************************************************************
+*                            lis_time_till                             *
+*************************************************************************
+*									*
+* Given a target time in terms of elapsed milli-seconds, in other words,*
+* the same units as jiffies if jiffies were in milli-seconds, return	*
+* the number of milli-seconds that it will take to reach to target time.*
+*									*
+* The return is negative if the target time is in the past, zero	*
+* if it is the same as the current target time, and positive if		*
+* target time is in the future.						*
+*									*
+************************************************************************/
+long	lis_time_till(long target_time)
+{
+    return( target_time - jiffies*(1000/HZ) ) ;
+
+} /* lis_time_till */
+
+/************************************************************************
+*                           lis_target_time                             *
+*************************************************************************
+*									*
+* Convert the milli_sec interval to an absolute target time expressed	*
+* in milli-seconds.  We compute this relative to the Linux software	*
+* clock, jiffies, converted to milliseconds.				*
+*									*
+************************************************************************/
+long	lis_target_time(long milli_sec)
+{
+    return( jiffies*(1000/HZ) + milli_sec ) ;
+
+} /* lis_target_time */
+
+
+
+/*  -------------------------------------------------------------------  */
+
+/* find the head for a file descriptor.
+ * STATUS: complete, untested
+ */
+stdata_t *
+lis_fd2str( int fd )
+{
+    struct file		* file;
+    struct inode	* inode;
+    stdata_t		* hd ;
+
+    if (fd>=NR_OPEN || !(file=current->files->fd[fd]) || !(inode=file->f_inode))
+	    return(NULL);
+
+    hd = INO_STR(inode);
+    if (hd != NULL && hd->magic == STDATA_MAGIC)
+	return(hd) ;			/* looks like a stdata structure */
+
+    return(NULL) ;			/* not a streams file */
+}
+
+
+/************************************************************************
+*                          lis_select                                   *
+*************************************************************************
+*									*
+* Called from the Linux sys_select routine to interrogate the status	*
+* of a stream.								*
+*									*
+* Return 1 if the stream is ready for the requested operation.  	*
+* Return 0, and set up the wait queue entry, if it is not.		*
+*									*
+************************************************************************/
+int      lis_select(struct inode *inode, struct file *file,
+		    int sel_type, select_table *wait)
+{
+    stdata_t		*hd;
+    polldat_t		 pdat ;
+    int			 evts ;
+    int			 msk ;
+    int			 rtn ;
+
+    memset(&pdat, 0, sizeof(pdat)) ;		/* just in case */
+    switch (sel_type)
+    {
+    case SEL_IN:
+	pdat.pd_events = POLLIN | POLLPRI | POLLRDNORM | POLLRDBAND ;
+	msk = POLLNVAL ;
+	break ;
+    case SEL_OUT:
+	pdat.pd_events = POLLOUT | POLLWRNORM | POLLWRBAND ;
+	msk = POLLNVAL ;
+	break ;
+    case SEL_EX:
+    default:
+	pdat.pd_events = POLLMSG ;			/* SIG-POLL msg */
+	msk = POLLERR | POLLHUP | POLLNVAL ;
+	break ;
+    }
+
+    evts = lis_strpoll(inode, file, &pdat) ;	/* get stream status */
+    rtn = ( (evts & (pdat.pd_events | msk)) != 0 ) ;/* expected status */
+    if (rtn) return(1) ;			/* yes, can do that */
+
+    /*
+     * Requested events are not present, add ourselves to the
+     * wait queue for the stream.
+     */
+    hd = INO_STR(inode) ;
+    select_wait(&hd->sd_select.sel_wait, wait) ;
+    return(0) ;
+
+} /* lis_select */
+
+/************************************************************************
+*                        lis_select_wakeup                              *
+*************************************************************************
+*									*
+* Wake up those waiting on this stream.					*
+*									*
+************************************************************************/
+void lis_select_wakeup(stdata_t *hd)
+{
+    if (   hd == NULL
+	|| hd->magic != STDATA_MAGIC
+	|| hd->sd_select.sel_wait == NULL
+	|| hd->sd_select.sel_wait == WAIT_QUEUE_HEAD(&hd->sd_select.sel_wait)
+       )
+	return ;
+
+    wake_up_interruptible(&hd->sd_select.sel_wait) ;
+
+} /* lis_select_wakeup */
+
+/************************************************************************
+*                            lis_pick_inode                             *
+*************************************************************************
+*									*
+* This routine is called from stropen().				*
+*									*
+* From the two inodes passed in, choose one of them to return to the	*
+* caller and "dispose" of the other one.				*
+*									*
+* 'old' is the inode passed into stropen by sys_open, 'new' is an	*
+* inode with the same i_rdev that was allocated to a previously opened	*
+* stream (so it's really the "older" of the two).			*
+*									*
+* Alternatively, 'old' is the inode passed to stropen for a clone open	*
+* and 'new' is NULL.  In this case we need to allocate a new inode,	*
+* transfer some attributes into it and return a pointer to it.  We are	*
+* done with the 'old' inode since it was the one that pointed to the	*
+* /dev/clone and the new one points to the actual stream device opened.	*
+*									*
+************************************************************************/
+struct inode *lis_pick_inode(struct inode *old, struct inode *new, dev_t dev)
+{
+    if (new == NULL)				/* no new inode */
+    {						/* may need to make one */
+	if (old != NULL && old->i_rdev == dev)	/* old has same rdev */
+	    return(old) ;			/* use old one */
+
+	new = get_empty_inode() ;		/* system routine */
+	if (new == NULL)			/* couldn't allocate one */
+	    goto free_old ;			/* old is wrong dev */
+
+	new->i_rdev = dev ;			/* set desired dev */
+	if (old != NULL)			/* new is cloned */
+	{					/* new will own the stream */
+	    INO_STR(new) = INO_STR(old) ;
+	    new->i_mode  = old->i_mode ;	/* inherit mode */
+	    new->i_ctime = old->i_ctime;
+	    new->i_atime = old->i_atime;
+	    new->i_mtime = old->i_mtime;
+	    goto free_old ;
+	}
+	else
+	    printk("lis_pick_inode: clone requires old inode non-NULL\n") ;
+    }
+    else					/* 'new' is present */
+    if (old != NULL && old->i_rdev == dev)	/* and both the same dev */
+    {
+	/*
+	 * If old has disk inode and new does not, then use the
+	 * old one, otherwise use the new one.  These inodes represent
+	 * two opens of the same stream, so bump the use count of
+	 * the one that we are going to use.
+	 */
+	if (old->i_sb != NULL && new->i_sb == NULL)
+	{					/* interchange old/new */
+	    struct inode	*tmp ;
+
+	    INO_STR(old) = INO_STR(new) ;
+	    tmp = new ;
+	    new = old ;
+	    old = tmp ;
+	}
+
+	new->i_count++ ;			/* one more use of "new" */
+    }
+
+    /*
+     * We have both old and new.  Use the "new" one and free up the
+     * "old" one.
+     */
+
+free_old:					/* free old and return new */
+
+    if (old != NULL)
+    {
+	INO_STR(old) = NULL ;
+	iput(old) ;				/* free old inode */
+    }
+
+    return(new) ;				/* use new one */
+
+} /* lis_pick_inode */
+
+
+/*  -------------------------------------------------------------------  */
+/*				    Module                               */
+#ifdef LINUX
+
+static int lis_major;
+char kernel_version[]= UTS_RELEASE;
+
+int init_module( void )
+{
+    lis_major = register_chrdev(0,"streams",&lis_streams_fops);
+    if	(lis_major < 0)
+    {
+	printk("Unable to register Streams Subsystem\n");
+	return -EIO;
+    }
+    /* Initialize every global variable to a default value, if there're
+     * modules w/ not-exported globals we should create init_() functions for
+     * them and call them from here. */
+    lis_init_bufcall();
+    printk ("Linux Streams Subsystem ready. Major %d\n", lis_major);
+    return(0);
+}
+
+void cleanup_module( void )
+{
+    unregister_chrdev(lis_major,"streams");
+    printk ("Linux Streams Subsystem removed\n");
+}
+
+
+/************************************************************************
+*                       lis_print_trace_func                            *
+*************************************************************************
+*									*
+* This function is pointed to by the lis_print_trace pointer.  It makes	*
+* cmn_err strings come out in the log. 					*
+*									*
+************************************************************************/
+void lis_print_trace_func(char *msg)
+{
+    printk("%s", msg) ;
+
+} /* lis_print_trace_func */
+
+/************************************************************************
+*                          streams_init                                 *
+*************************************************************************
+*									*
+* This routine is called from the Linux main.c.  It registers the 	*
+* streams driver and initializes some streams variables.		*
+*									*
+* No memory is allocated.						*
+*									*
+************************************************************************/
+void	streams_init(void)
+{
+    lis_print_trace = lis_print_trace_func ;
+
+    init_module() ;		/* register STREAMS with Linux */
+    lis_init_head() ;		/* register STREAMS drivers with LInux */
+
+} /* streams_init */
+
+
+#endif /* LINUX */
+
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/mdep.c /usr/src/linux/drivers/streams/LiS/head/mdep.c
--- debug/drivers/streams/LiS/head/mdep.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/mdep.c	Mon Dec 16 16:36:38 1996
@@ -0,0 +1,25 @@
+#if defined(__MSDOS__)				/* DOS version */
+#include "dos-mdep.c"
+#elif defined(LINUX)				/* Linux version */
+#include "linux-mdep.c"
+#elif defined(USER)				/* user-level version */
+#include "user-mdep.c"
+#elif defined(SYS_SCO)				/* SCO user-level version */
+#include "user-mdep.c"
+#elif defined(SYS_54)				/* SCO user-level version */
+#include "user-mdep.c"
+#elif defined(QNX)				/* QNX driver version */
+#include "qnx-mdep.c"
+#elif defined(PORTABLE)				/* just the portable part */
+#include "port-mdep.c"
+#endif
+
+
+
+
+
+
+
+
+
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/mod.c /usr/src/linux/drivers/streams/LiS/head/mod.c
--- debug/drivers/streams/LiS/head/mod.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/mod.c	Wed Jan  1 14:13:03 1997
@@ -0,0 +1,214 @@
+/*                               -*- Mode: C -*- 
+ * mod.c --- module mgmt
+ * Author          : Francisco J. Ballesteros Camara
+ * Created On      : Thu Jun 29 11:03:59 1995
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: mod.c,v 1.4 1996/01/21 01:23:37 dave Exp $
+ * Purpose         : provide LiS STREAMS modules glue
+ * ----------------______________________________________________
+ *
+ *    Copyright (C) 1995  Francisco J. Ballesteros, Denis Froschauer
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    nemo@ordago.uc3m.es, 100741.1151@compuserve.com
+ */
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#include <sys/strport.h>
+#include <sys/strconfig.h>	/* config definitions */
+#include <sys/LiS/share.h>	/* streams shared defs*/
+#include <sys/LiS/queue.h>	/* streams queues */
+#include <sys/LiS/mod.h>	/* module interface */
+#include <string.h>
+
+/*  -------------------------------------------------------------------  */
+/*				  Glob. vars                             */
+
+struct fmodsw     lis_fstr_sw[MAX_STRDEV]; /* streams devices */
+
+struct fmodsw     lis_fmod_sw[MAX_STRMOD]; /* streams modules */
+int               lis_fmodcnt=0;             /* # of modules */
+int               lis_reuse_modsw=1; /* should we reuse mod entries */
+lis_apush_t      *lis_str_amod[MAX_STRDEV];/* autopushed modules */
+
+extern struct file_operations lis_streams_fops;
+
+/*  -------------------------------------------------------------------  */
+/* register a new module
+ */
+int
+lis_register_strmod(struct streamtab *strtab, char *name)
+{
+    int       count=lis_fmodcnt;
+    fmodsw_t *slot=&lis_fmod_sw[1];
+
+    if (lis_reuse_modsw)
+	for(count=1; 
+	    count < lis_fmodcnt && slot->f_str; slot++, count++)
+	    ;
+    if (count==lis_fmodcnt){
+	if(count == MAX_STRMOD)
+	    return(-ENOSR);
+	lis_fmodcnt++;
+    }
+    slot->f_str=strtab;
+    slot->f_count=0;
+    if (name)
+    {
+	strncpy(slot->f_name,name,FMNAMESZ);
+	printk ("%s streams module registered. Index %d\n", name, count);
+    }
+    else
+	*slot->f_name='\0';
+
+    return(count);
+}/*lis_register_strmod*/
+
+/*  -------------------------------------------------------------------  */
+/* unregister this module
+ */
+int
+lis_unregister_strmod(struct streamtab *strtab)
+{
+    fmodsw_t *slot;
+    for( slot=lis_fmod_sw+lis_fmodcnt; 
+	 slot != lis_fmod_sw+1 && slot->f_str!=strtab ; slot-- )
+	;
+    if (slot->f_str!=strtab)
+	return(-EINVAL);
+    if (slot->f_count)
+	return(-EBUSY);
+    slot->f_str=NULL;
+    return(0);
+}/*lis_unregister_strmod*/
+
+/*  -------------------------------------------------------------------  */
+/* Find module name in fmodsw[] 
+ */
+int
+lis_findmod(const char *name)
+{
+	int	i ;
+
+	for (i=lis_fmodcnt; 
+	     i > 0 && strcmp(lis_fmod_sw[i].f_name,name);
+	     i--)
+	    ;
+	if ( i == 0 )
+	    return(-EINVAL);
+	else
+	    return(i);
+}/*lis_findmod*/
+
+/*  -------------------------------------------------------------------  */
+/* register a new streams device
+ */
+int 
+lis_register_strdev(int majnum, 
+		    struct streamtab *strtab, 
+		    int nminor,
+		    char *name)
+{
+    int		rslt ;
+
+    (void)nminor;
+    rslt = register_chrdev(majnum,name,&lis_streams_fops);
+    if	(rslt < 0)
+    {
+	printk("Unable to get major %d for stream driver \"%s\", errno=%d\n",
+		majnum, name, rslt);
+	return -EIO;
+    }
+
+    if (majnum == 0)			/* register routine assigned it */
+	majnum = rslt ;
+
+    if (lis_fstr_sw[majnum].f_str!=NULL && lis_fstr_sw[majnum].f_str != strtab)
+	return(-EBUSY);
+
+    lis_fstr_sw[majnum].f_str=strtab;
+    lis_fstr_sw[majnum].f_count=0;
+    if (name)
+	strncpy(lis_fstr_sw[majnum].f_name,name,FMNAMESZ);
+    else
+	*lis_fstr_sw[majnum].f_name='\0';
+
+    printk ("Streams driver \"%s\" registered, major %d\n", name, majnum);
+
+    return(majnum);
+
+}/*lis_register_strdev*/
+
+/*  -------------------------------------------------------------------  */
+/* unregister a streams device
+ */
+int 
+lis_unregister_strdev(uint majnum, struct streamtab *strtab, int nminor)
+{
+    (void) nminor ;			/* compiler happiness */
+
+    if (majnum >= MAX_STRDEV || lis_fstr_sw[majnum].f_str != strtab)
+	return(-ENODEV);
+    if ( lis_fstr_sw[majnum].f_count)
+	return(-EBUSY);
+
+    lis_fstr_sw[majnum].f_str=NULL;
+	unregister_chrdev(majnum,lis_fstr_sw[majnum].f_name);
+	printk ("%s streams subsystem unregistered\n", lis_fstr_sw[majnum].f_name);
+    return(0);
+}/*lis_unregister_strdev*/
+
+/*  -------------------------------------------------------------------  */
+/* Find a driver  by major device number and return a pointer to
+ * its streamtab entry.
+ */
+streamtab_t *
+lis_find_strdev(int maj)
+{
+    if (maj >= MAX_STRDEV) return(NULL) ;
+
+    return(lis_fstr_sw[maj].f_str) ;
+
+} /* lis_find_strdev */
+
+/*  -------------------------------------------------------------------  */
+/* Get the streamtab for the autopush module #n in stream w/ dev d
+ */
+streamtab_t *
+lis_apushm( int idx, dev_t dev)
+{
+    int majnum=STR_MAJOR(dev);
+    if (majnum<0 || majnum >= MAX_STRDEV ||  !lis_str_amod[majnum] ||
+	idx < 0 || idx >= MAX_STRAMOD)
+	return(NULL);
+    else {
+	lis_amod_t *amod=(*lis_str_amod[majnum])+idx;
+	if (amod->a_mid == LIS_NULL_MID)
+	    return(NULL);
+	else
+	    return(lis_fmod_sw[(int)amod->a_mid].f_str);
+    }
+}/*lis_apushm*/
+
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/msg.c /usr/src/linux/drivers/streams/LiS/head/msg.c
--- debug/drivers/streams/LiS/head/msg.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/msg.c	Wed Jan  1 14:13:03 1997
@@ -0,0 +1,479 @@
+/*                               -*- Mode: C -*- 
+ * msg.c --- streams message handling
+ * Author          : Graham Wheeler
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: msg.c,v 1.6 1996/01/17 18:57:05 dave Exp $
+ * Purpose         : provide streams message handling
+ *                 : this is the main memory allocation related module.
+ * ----------------______________________________________________
+ *
+ *   Copyright (C) 1995 Graham Wheeler, Francisco J. Ballesteros, 
+ *                      Denis Froschauer
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    gram@aztec.co.za, nemo@ordago.uc3m.es, 100741.1151@compuserve.com
+ */
+
+/*
+ * The memory allocation mechanism is based on that in SVR4.2.
+ * That is, all memory is allocated dynamically, with freed
+ * message headers being held on a free list. When kernel memory
+ * is low some of these can be reclaimed by calling strgiveback.
+ *
+ * Message headers are 128 bytes in size. The extra space
+ * is used as the data buffer for smallish messages. This
+ * scheme means that in most cases, a call to allocb just
+ * requires unlinking a message header from the free list
+ * and initialising it.
+ *
+ * This scheme does add some complexity, however, with
+ * regard to dupb/dupmsg. In this case the duplicate can
+ * have pointers to a data buffer within some other message
+ * header. Thus, if a message header is freed, we have to
+ * check if its internal data buffer is still in use by
+ * someone else, in which case we defer freeing the header;
+ * on the other hand, if we are freeing the last reference
+ * to some other data buffer in a message header, we have two
+ * headers to free. All of this logic is nicely hidden in freeb()
+ * (with a little bit of it leaking into pullupmsg).
+ *
+ * NB: This does rely on the fact that if a message block
+ * has a data buffer of FASTBUF or less in size and no special
+ * free function (i.e. it wasn't an esballoc), then that data
+ * buffer lives internally within some (not necessarily the same)
+ * message header, and was *not* allocated elsewhere.
+ *
+ * To put it another way, if you don't completely understand
+ * the memory management scheme, don't fiddle with any of
+ * the following code, and don't ever directly modify data
+ * block elements like db_base, db_lim and db_size.
+ */
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#include <sys/stream.h>
+
+/*  -------------------------------------------------------------------  */
+/*			       Symbols & types                           */
+
+
+
+/*  -------------------------------------------------------------------  */
+/*				  Glob. Vars                             */
+
+struct mdbblock  *lis_mdbfreelist = NULL; /* message block free list	 */
+int lis_strmsgsz;	 		  /* maximum stream message size */
+int lis_strcount ;			  /* # bytes allocated to msgs   */
+long	 lis_max_msg_mem ;		  /* maximum to allocate */
+
+/*  -------------------------------------------------------------------  */
+/*			   Local functions & macros                      */
+
+
+/* allochdr - allocate a message header. For internal use.
+ *
+ * Use DBLK_ALLOC to get the memory.  Since a header (mblk) also
+ * contains a small data block it must be DMA-able memory.
+ */
+static struct mdbblock *
+allochdr(char *file_name, int line_nr)
+{
+    struct mdbblock *rtn;
+    int psw;
+    SPLSTR(psw);
+    rtn = lis_mdbfreelist;
+    /* Try to get an mdbblock from the free list */
+    if (rtn == NULL) /* free list empty; try allocate a new header */
+    {
+	if (lis_max_msg_mem == 0 || lis_strcount < lis_max_msg_mem)
+	    rtn = (struct mdbblock *)
+		    DBLK_ALLOC(sizeof(struct mdbblock), file_name, line_nr);
+    }
+    else
+    {
+	/* paranoia */
+	if (lis_mdbfreelist ==
+	    (struct mdbblock *)lis_mdbfreelist->msgblk.m_mblock.b_next)
+	{
+	    rtn = (struct mdbblock *) NULL;
+	}
+	else
+	{
+	    /* remove header from free list */
+	    lis_mdbfreelist = 
+		(struct mdbblock *)lis_mdbfreelist->msgblk.m_mblock.b_next;
+
+	    LisDownCount(FREEHDRS);
+	    lis_mark_mem(rtn, file_name, line_nr) ;     /* under new ownership*/
+	}
+    }
+
+    if (rtn)	/* update counts of header allocations */
+    {
+	LisUpCount(HEADERS);
+	rtn->msgblk.m_mblock.b_next = NULL;
+    }
+    else	/* update counts of header allocation failures */
+    {
+	LisUpFailCount(HEADERS);
+    }
+
+    SPLX(psw);
+    return rtn;
+
+}/*allochdr*/
+
+/*  -------------------------------------------------------------------  */
+
+/* freehdr - return a header to the free list. For internal use.
+ */
+
+static void
+freehdr(mblk_t *bp)
+{
+    int psw;
+    SPLSTR(psw);
+
+    LisDownCount(HEADERS);
+
+    if (lis_strstats[FREEHDRS][CURRENT] >= MAX_MBLKS)
+    {
+	FREE(bp);
+	return ;
+    }
+
+    bp->b_cont = NULL ;
+    bp->b_next = (mblk_t *)lis_mdbfreelist;
+    /*
+     * If the data block ptr points to the data area of this same
+     * mblk then leave it alone for port mortem debugging purposes.
+     * If it points outside this area then clear these pointers
+     * so that memory printers won't be looking at deallocated memory.
+     */
+    if (   bp->b_datap == NULL
+	|| (bp->b_datap->db_base != (void*) ((struct mdbblock *)bp)->databuf)
+       )
+    {
+	bp->b_datap= NULL ;			/* clear data block ptr */
+	bp->b_rptr = NULL ;
+	bp->b_wptr = NULL ;
+    }
+
+    lis_mdbfreelist = (struct mdbblock *)bp;
+    lis_mark_mem(bp, "free", MEM_MSG) ;		     /* under new ownership */
+    LisUpCount(FREEHDRS);
+    SPLX(psw);
+}/*freehdr*/
+
+/*  -------------------------------------------------------------------  */
+/* allocdb - allocate a data buffer. For internal use.
+ *
+ * Use DBLK_ALLOC to allocate the memory.  STREAMS buffers must
+ * be DMA-able.
+ */
+static char *
+allocdb(int size, char *file_name, int line_nr)
+{
+    char *rtn;
+    int   psw;
+
+    if (lis_max_msg_mem != 0 && lis_strcount >= lis_max_msg_mem)
+    {
+	SPLSTR(psw);
+	LisUpFailCount(DATABS);
+	SPLX(psw);
+	return(NULL) ;
+    }
+
+    ASSERT(size > FASTBUF);
+    rtn = (char *)DBLK_ALLOC(size, file_name, line_nr);
+    SPLSTR(psw);
+    if (rtn == NULL)
+	LisUpFailCount(DATABS);
+    else
+    {
+	lis_strcount += size;/* increment count of allocated memory */
+	LisUpCount(DATABS);
+	LisUpCounter(DBLKMEM, size);
+    }
+
+    SPLX(psw);
+    return rtn;
+}/*allocdb*/
+
+/*  -------------------------------------------------------------------  */
+/* initb: initialise an allocated msg block. For internal use only.
+ */
+
+static void
+initb(struct mdbblock *blk, char *buff, int size,
+      struct free_rtn *frtn)
+{
+    /* I don't know what purpose the m_func field serves at this stage!! */
+    lis_bzero(&blk->msgblk, sizeof(blk->msgblk)) ;
+    blk->msgblk.m_mblock.b_rptr = (unsigned char *)buff;
+    blk->msgblk.m_mblock.b_wptr = (unsigned char *)buff;
+    blk->msgblk.m_mblock.b_datap=  (struct datab *)&blk->datblk.d_dblock;
+    
+    lis_bzero(&blk->datblk, sizeof(blk->datblk)) ;
+    blk->datblk.d_dblock.frtnp = (struct free_rtn *)frtn;
+    blk->datblk.d_dblock.db_base = (unsigned char *)buff;
+    if ((char *) buff != blk->databuf)	/* separate data block */
+    {					/* of exact size */
+	blk->datblk.d_dblock.db_lim = (unsigned char *)(buff + size);
+	blk->datblk.d_dblock.db_size = size;
+    }
+    else				/* data block w/header */
+    {
+	blk->datblk.d_dblock.db_lim = (unsigned char *)(buff + FASTBUF);
+	blk->datblk.d_dblock.db_size = FASTBUF;
+    }
+
+    blk->datblk.d_dblock.db_ref = (uchar)1;
+    blk->datblk.d_dblock.db_type = (uchar)M_DATA;
+    if (LIS_DEBUG_CLEAN_MSG)
+	lis_bzero(blk->datblk.d_dblock.db_base, blk->datblk.d_dblock.db_size) ;
+}/*initb*/
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+
+/*  -------------------------------------------------------------------  */
+
+/* allocb: allocate an M_DATA message block of the specified
+ *	size. The priority is for compatibility only.
+ */
+
+struct msgb *
+lis_allocb(int size, unsigned int priority, char *file_name, int line_nr)
+{
+    struct mdbblock *rtn = allochdr(file_name, line_nr);
+    char *buff;
+    (void)priority;
+    if (rtn == NULL)
+	return NULL;
+    if (size > FASTBUF)
+    {
+	/* allocate data buffer */
+	if ((buff = allocdb(size, file_name, line_nr)) == NULL)
+	{
+	    /* failed; replace header in free list and return */
+	    freehdr((mblk_t *)rtn);
+	    return NULL;
+	}
+    }
+    else buff = rtn->databuf;
+
+    /* Set up message and data block headers */
+
+    initb(rtn, buff, size, NULL);
+
+    if ( LIS_DEBUG_ALLOC )
+    {
+	if (LIS_DEBUG_ADDRS)
+	  printk("lis_allocb: mp = 0x%lx from %s %d, rptr 0x%lx, wptr 0x%lx\n",
+		  (long) rtn, file_name, line_nr,
+		  (long) ((mblk_t *)rtn)->b_rptr,
+		  (long) ((mblk_t *)rtn)->b_wptr);
+	else
+	  printk("lis_allocb: from %s #%d size=%d\n", file_name, line_nr, size);
+    }
+
+    return (mblk_t *)rtn;
+}/*lis_allocb*/
+
+/*  -------------------------------------------------------------------  */
+/* testb: see if an allocation can actually be done.
+ */
+
+int
+lis_testb(int size, unsigned int priority)
+{
+#ifdef AVAIL
+    int sz = 0;
+    (void)priority;
+    if (size > FASTBUF)
+	sz += size;
+    if (lis_mdbfreelist == NULL)
+	sz += sizeof(struct mdbblock); /* gotta getta hedda */
+    return (sz <= AVAIL());
+#else
+    /* hack - allocate and free */
+    mblk_t *bp = allocb(size, priority);
+    return bp ? (lis_freeb(bp), 1) : 0;
+#endif
+}/*lis_testb*/	
+
+/*  -------------------------------------------------------------------  */
+/*
+ * esballoc: allocate a message block, using a user-provided data buffer
+ */
+
+mblk_t *
+lis_esballoc(unsigned char *base, int size, int priority,
+	     frtn_t *freeinfo, char *file_name, int line_nr)
+{
+    struct mdbblock *rtn = NULL;
+    (void)priority;
+    if (base && freeinfo && (rtn  = allochdr(file_name, line_nr)) != NULL)
+    	initb(rtn, base, size, freeinfo);
+    return (mblk_t *)rtn;
+}/*lis_esballoc*/
+
+/*  -------------------------------------------------------------------  */
+
+/* lis_freedb - Free the data block associated with a message and
+ *              possibly the message header as well.
+ */
+void
+lis_freedb(mblk_t *bp, int free_hdr)
+{
+    int psw;
+
+    if (bp)
+    {
+	struct datab *dp = bp->b_datap;
+
+    	if (dp)
+	{
+	    if (dp -> db_ref == 0)
+	    {
+		printk ("lis_freeb: mp 0x%lx ref count 0\n", (long) bp);
+		return;
+	    }
+
+	    if (--dp->db_ref == 0)
+            {
+	    	if (dp->frtnp)
+		{
+		    if ( LIS_DEBUG_FREEMSG && LIS_DEBUG_ADDRS )
+		       printk("lis_freeb: (external data blk) dp = 0x%lx\n",
+			       (long) dp);
+
+	             (*(dp->frtnp->free_func))(dp->frtnp->free_arg);
+		}
+	    	else if (dp->db_size > FASTBUF) /* separate data buffer? */
+	    	{
+		    if ( LIS_DEBUG_FREEMSG && LIS_DEBUG_ADDRS  )
+			printk("lis_freeb: (data blk) dp = 0x%lx\n", (long) dp);
+
+	            FREE(dp->db_base/*, dp->db_size*/);
+		    SPLSTR(psw);
+	            lis_strcount -= dp->db_size;
+	            LisDownCount(DATABS);
+		    LisDownCounter(DBLKMEM, dp->db_size);
+		    SPLX(psw);
+	        }
+		else if (bp->b_datap->db_base != (void*)
+			 ((struct mdbblock *)bp)->databuf)
+		{
+		    mblk_t	*bpdp ;
+
+		    /* The data buffer is not in this message block,
+		       so we free the message block header it is in */
+		    bpdp = (mblk_t *)(bp->b_datap->db_base - HDRSZ);
+		    if ( LIS_DEBUG_FREEMSG && LIS_DEBUG_ADDRS  )
+			printk("lis_freeb: (mblk/dblk) bp/dp = 0x%lx/0x%lx\n",
+				    (long) bpdp, (long) dp);
+		    freehdr(bpdp);
+		}
+
+		if (free_hdr)
+		{
+		    if ( LIS_DEBUG_FREEMSG && LIS_DEBUG_ADDRS  )
+			printk("lis_freeb: (mblk) bp = 0x%lx\n", (long) bp);
+
+		    freehdr(bp); 	/* free the header */
+		}
+	    }
+	    /* if refcnt>0 and data block is in the header, we don't free
+	       the header, as someone else is still using it */
+	    else
+	    if (   free_hdr
+		&& (bp->b_datap->db_base != 
+				     (void*)((struct mdbblock *)bp)->databuf)
+	       )
+	    {
+		if ( LIS_DEBUG_FREEMSG && LIS_DEBUG_ADDRS  )
+		    printk("lis_freeb: (mblk) bp = 0x%lx\n", (long) bp);
+
+        	freehdr(bp);
+	    }
+        }
+        else
+	if (free_hdr)
+	{
+	    if ( LIS_DEBUG_FREEMSG && LIS_DEBUG_ADDRS  )
+		printk("lis_freeb: (mblk) bp = 0x%lx\n", (long) bp);
+
+	    freehdr(bp);	 /* no data block; just free the header */
+	}
+    }
+
+}/*lis_freedb*/
+
+/*  -------------------------------------------------------------------  */
+
+/* freeb - Free data buffer and place message block on free list. Don't
+ *      follow the continuation pointer.
+ */
+void
+lis_freeb(mblk_t *bp)
+{
+    lis_freedb(bp, 1) ;			/* free both hdr and data blk */
+
+}/*lis_freeb*/
+
+/*  -------------------------------------------------------------------  */
+/* freemsg - free a whole message
+ */
+void
+lis_freemsg(mblk_t *mp)
+{
+    while (mp)
+    {
+	mblk_t *now = mp;
+	mp = mp->b_cont;
+	lis_freedb(now, 1);
+    }
+}/*lis_freemsg*/
+
+/*  -------------------------------------------------------------------  */
+/* extract values from a char pointer and advance the pointer */
+int lis_getint(unsigned char **p)
+{
+    int result = *((int*)(*p));
+    *p += sizeof(int);
+    return(result);
+}
+
+/*  -------------------------------------------------------------------  */
+void lis_putbyte(unsigned char **p, unsigned char byte)
+{
+    **p = byte;
+    ++*p;
+}
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/msgutl.c /usr/src/linux/drivers/streams/LiS/head/msgutl.c
--- debug/drivers/streams/LiS/head/msgutl.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/msgutl.c	Wed Jan  1 14:13:03 1997
@@ -0,0 +1,480 @@
+/*                               -*- Mode: C -*- 
+ * msgutl.c --- streams message utilities.
+ * Author          : Graham Wheeler, Francisco J. Ballesteros
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: msgutl.c,v 1.2 1996/01/07 20:46:47 dave Exp $
+ * Purpose         : here you have utilites to handle str messages.
+ * ----------------______________________________________________
+ *
+ *   Copyright (C) 1995  Francisco J. Ballesteros, Graham Wheeler
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    nemo@ordago.uc3m.es, gram@aztec.co.za
+ */
+
+
+/*
+ * The memory allocation mechanism is based on that in SVR4.2.
+ * That is, all memory is allocated dynamically, with freed
+ * message headers being held on a free list. When kernel memory
+ * is low some of these can be reclaimed by calling strgiveback.
+ *
+ * Message headers are 128 bytes in size. The extra space
+ * is used as the data buffer for smallish messages. This
+ * scheme means that in most cases, a call to allocb just
+ * requires unlinking a message header from the free list
+ * and initialising it.
+ *
+ * This scheme does add some complexity, however, with
+ * regard to dupb/dupmsg. In this case the duplicate can
+ * have pointers to a data buffer within some other message
+ * header. Thus, if a message header is freed, we have to
+ * check if its internal data buffer is still in use by
+ * someone else, in which case we defer freeing the header;
+ * on the other hand, if we are freeing the last reference
+ * to some other data buffer in a message header, we have two
+ * headers to free. All of this logic is nicely hidden in freeb()
+ * (with a little bit of it leaking into pullupmsg).
+ *
+ * NB: This does rely on the fact that if a message block
+ * has a data buffer of FASTBUF or less in size and no special
+ * free function (i.e. it wasn't an esballoc), then that data
+ * buffer lives internally within some (not necessarily the same)
+ * message header, and was *not* allocated elsewhere.
+ *
+ * To put it another way, if you don't completely understand
+ * the memory management scheme, don't fiddle with any of
+ * the following code, and don't ever directly modify data
+ * block elements like db_base, db_lim and db_size.
+ */
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#include <sys/stream.h>
+
+/*  -------------------------------------------------------------------  */
+/*				  Glob. Vars                             */
+
+
+/*  -------------------------------------------------------------------  */
+/*			   Local functions & macros                      */
+
+/* tmsgsize - count sizes of consecutive blocks of the same
+ *	type as the last; i.e. like lis_xmsgsize but measured
+ *	from the back, not the front. For internal use.
+ */
+static int
+tmsgsize(mblk_t *mp, mblk_t **first)
+{
+    int rtn = 0;
+    unsigned char type;
+    if (mp == NULL) return 0;
+    type = mp->b_datap->db_type;
+    *first = mp;
+    while (mp)
+    {
+        if (mp->b_datap->db_type == type)
+	{
+	    short n = (short) (mp->b_wptr - mp->b_rptr);
+	    if (n > 0) rtn += n;
+	}
+	else /* different type; reset counter and count these */
+	{
+    	    type = mp->b_datap->db_type;
+	    *first = mp;
+	    rtn = 0;
+	}
+	mp = mp->b_cont;
+    }
+    return rtn;
+}/*tmsgsize*/
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+/* lis_msgsize - count sizes of blocks of message
+ */
+int
+lis_msgsize(mblk_t *mp)
+{
+    int rtn = 0;
+    while (mp)
+    {
+	rtn += mp->b_datap->db_lim - mp->b_datap->db_base;
+	mp = mp->b_cont;
+    }
+    return rtn;
+}/*lis_msgsize*/
+/*  -------------------------------------------------------------------  */
+/* lis_msgdsize - return number of data bytes in M_DATA blocks in message
+ */
+int
+lis_msgdsize(mblk_t *mp)
+{
+    int rtn = 0;
+    while (mp)
+    {
+	if (mp->b_datap->db_type == M_DATA)
+	{
+	    int n = mp->b_wptr - mp->b_rptr;
+	    if (n > 0) rtn += n;
+	}
+	mp = mp->b_cont;
+    }
+    return rtn;
+}/*lis_msgdsize*/
+/*  -------------------------------------------------------------------  */
+
+/* xmsgsize - count sizes of consecutive blocks of the same
+ *	type as the first
+ */
+int
+lis_xmsgsize(mblk_t *mp)
+{
+    int rtn = 0;
+    unsigned char type;
+    if (mp == NULL) return 0;
+    type = mp->b_datap->db_type;
+    while (mp && mp->b_datap->db_type == type)
+    {
+	short n = (short) (mp->b_wptr - mp->b_rptr) ;
+	if (n > 0) rtn += n;
+	mp = mp->b_cont;
+    }
+    return rtn;
+}/*lis_xmsgsize*/
+
+/*  -------------------------------------------------------------------  */
+
+/* adjmsg - trim abs(len) bytes from a message. If len<0, trim
+ *	from tail; else trim from head. If len is greater than
+ *      the message size or the trim crosses message blocks of
+ *      differing types, adjmsg fails. Any blocks that are
+ *	completely trimmed are not removed, but have their
+ *	rptrs set to their wptrs.
+ *	Returns 1 on success; 0 otherwise.
+ */
+int
+lis_adjmsg(mblk_t *mp, int length)
+{
+    if(mp == NULL) return 0;
+    if (length >= 0)			/* trim from front of msg	*/
+    {
+	mblk_t *bp = mp;
+        int mlen = lis_xmsgsize(mp);	/* bytes of blks of same type	*/
+	if (length > mlen)		/* invalid length, so fail	*/
+	    return 0;
+    	for (;;)
+	{
+	    int n = bp->b_wptr - bp->b_rptr;
+	    if (n > length)		/* partial block		*/
+	    {
+	    	bp->b_rptr += length;	/* adjust it			*/
+		break;			/* we're done			*/
+	    }
+	    else if (n > 0)		/* whole block			*/
+	    {
+	        bp->b_rptr += n;
+	        length -= n;
+	        if (length == 0) break;
+	    }
+	    bp = bp->b_cont;
+	}
+    }
+    else
+    {
+	mblk_t *mp2;
+        int mlen = tmsgsize(mp,&mp2);	/* get message tail byte count	*/
+	length += mlen;			/* length=bytes to skip		*/
+	if (length < 0)			/* invalid length; fail.	*/
+	    return 0;
+        else				/* remove trailing data		*/
+        {
+    	    while (mp2)
+	    {
+	        int n = mp2->b_wptr - mp2->b_rptr;
+		if (length <= 0)	/* whole block			*/
+	       	    mp2->b_rptr = mp2->b_wptr;
+	        else if (n > 0)
+		{
+	            if (n > length)	/* partial block?		*/
+	       	        mp2->b_wptr = mp2->b_rptr + length;
+		    length -= n;
+		}
+	        mp2 = mp2->b_cont;
+	    }
+        }
+    }
+    return 1;
+}/*lis_adjmsg*/
+/*  -------------------------------------------------------------------  */
+/* lis_copyb - create and return a copy of a message block
+ */
+mblk_t *
+lis_copyb(mblk_t *mp)
+{
+    mblk_t *bp;
+    short msglen;
+
+    if (mp == NULL || (msglen = (short) (mp->b_wptr - mp->b_rptr)) < 0)
+	return NULL;
+    if ((bp = allocb(msglen, BPRI_LO)) == NULL)
+	return NULL;
+    MEMCPY(bp->b_wptr, mp->b_rptr, msglen);
+    bp->b_wptr += msglen;
+    return bp;
+}/*lis_copyb*/
+/*  -------------------------------------------------------------------  */
+
+/* lis_copymsg - create and return a copy of a message
+ */
+mblk_t *
+lis_copymsg(mblk_t *mp)
+{
+    mblk_t *rtn, *bp;
+    if(mp == NULL || (rtn = bp = lis_copyb(mp)) == NULL)
+    	return NULL;
+    while (mp->b_cont)
+    {
+	mp = mp->b_cont;
+    	if ((bp->b_cont = lis_copyb(mp)) == NULL)
+	{
+	    lis_freemsg(rtn);
+	    return NULL;
+	}
+	bp = bp->b_cont;
+    }
+    return rtn;
+}/*lis_copymsg*/
+
+/*  -------------------------------------------------------------------  */
+/*
+ * lis_dupb - duplicate a message block, updating the reference count.
+ *	The data block and data buffer are reused.
+ */
+
+mblk_t *
+lis_dupb(mblk_t *mp)
+{
+    if (mp)
+    {
+        mblk_t *bp = allocb(0, BPRI_MED);
+	if (bp)
+	{
+	    *bp = *mp;
+            mp->b_datap->db_ref++;
+            return bp;
+	}
+    }
+    return NULL;
+}/*lis_dupb*/
+
+/*  -------------------------------------------------------------------  */
+/* lis_dupmsg - duplicate a message by duplicating the constituent
+ *	data blocks.
+ */
+mblk_t *
+lis_dupmsg(mblk_t *mp)
+{
+    mblk_t *bp, *rtn = lis_dupb(mp);
+    if (rtn == NULL) return NULL;
+    bp = rtn;
+    while (mp->b_cont)
+    {
+	mp = mp->b_cont;
+	bp->b_cont = lis_dupb(mp);
+	bp = bp->b_cont;
+	if (bp == NULL)
+	{
+	    lis_freemsg(rtn);
+	    return NULL;
+	}
+    }
+    return rtn;
+}/*lis_dupmsg*/	
+
+/*  -------------------------------------------------------------------  */
+/* lis_linkb - concatenate mp1 and mp2.
+ */
+
+void 
+lis_linkb(mblk_t *mp1, mblk_t *mp2)
+{
+    if (mp1 && mp2)
+    {
+	while (mp1->b_cont)
+	    mp1 = mp1->b_cont;
+        mp1->b_cont = mp2;
+    }
+}/*lis_linkb*/
+
+/*  -------------------------------------------------------------------  */
+/* unlinkb - remove first message block from a message. Return the
+ *	next message block pointer, or NULL if no further blocks.
+ */
+mblk_t *
+lis_unlinkb(mblk_t *mp)
+{
+    mblk_t *rtn;
+    if (mp == NULL) return NULL;
+    rtn = mp->b_cont;
+    mp->b_cont = NULL;
+    return rtn;
+}/*lis_unlinkb*/
+
+/*  -------------------------------------------------------------------  */
+/* lis_pullupmsg - attempt to merge the first len data bytes of a
+ *	message into a single block. If len is -1, all leading
+ *	blocks of the same type are merged.
+ *	The message header is reused, but a new data block and
+ *	data buffer are allocated for the first block.
+ *	Only blocks of the same type can be merged.
+ *	Returns 1 on success; 0 otherwise.
+ */
+int 
+lis_pullupmsg(mblk_t *mp, int length)
+{
+    mblk_t *tmpbp, *newbp, *tmpbp2;
+    mblk_t *prev ;
+    int len;
+    int n ;
+
+    if (mp == NULL || length < -1)
+	return 0;
+
+    len = lis_xmsgsize(mp);	/* # bytes in msgs of same type as 1st */
+    if (length == -1)
+	length = len;		/* pull up all bytes */
+
+    if (length == 0)		/* nothing to do */
+	return 1;
+
+    if (length < 0 || length > len) /* do we have that many bytes? */
+        return 0;
+
+    /* try to allocate a new message for merged blocks.
+     * Ensure that the new message has an external data block
+     * for its buffer.
+     */
+    len = length ;
+    if (len <= FASTBUF) len = FASTBUF+1 ;
+
+    if ((newbp = allocb(len, BPRI_MED)) == NULL)
+	return 0;
+
+    newbp->b_datap->db_type = mp->b_datap->db_type;
+    /* copy the data */
+    for (tmpbp = mp, prev = NULL; tmpbp != NULL; )
+    {
+	if (tmpbp->b_datap->db_type != newbp->b_datap->db_type)
+	{				/* not the same type */
+	    prev = tmpbp ;
+	    tmpbp = tmpbp->b_cont ;
+	    continue ;
+	}
+
+    	n = tmpbp->b_wptr - tmpbp->b_rptr;
+
+	if (n > 0)
+	{				/* same type as result msg */
+	    int actual = min(n, length);
+
+	    MEMCPY(newbp->b_wptr, tmpbp->b_rptr, actual);
+	    tmpbp->b_rptr += actual;
+	    newbp->b_wptr += actual;
+	    length -= actual;
+	}
+
+	tmpbp2 = tmpbp;			/* save ptr to this mblk */
+	tmpbp  = tmpbp->b_cont;		/* go to next mblk */
+	if (   prev != NULL		/* not the 1st mblk */
+	    && tmpbp2->b_rptr == tmpbp2->b_wptr	/* bfr is empty */
+	   )
+	{
+	    prev->b_cont = tmpbp ;	/* link around buffer */
+	    tmpbp2->b_cont = NULL ;	/* sever link to nxt bfr */
+	    lis_freeb(tmpbp2);		/* free it */
+	}				/* do not move prev */
+	else				/* 1st mblk or non-empty bfr */
+	    prev = tmpbp2 ;		/* reassign prev */
+    }
+
+    /*
+     * We now have mp pointing to the mblk of the first buffer
+     * of the original message.  We have newbp pointing to the
+     * single buffer result message which contains the entire
+     * message in one block.
+     *
+     * We need to make the data block ptr in *mp point to
+     * the data block of newbp and then free the mblk at *newbp.
+     * If *mp's old data block was external to the header then
+     * we need to free it as well.
+     */
+    lis_freedb(mp, 0) ;			/* free mp's data block (not hdr) */
+					/* decrs ref cnt */
+    mp->b_datap->db_base = newbp->b_datap->db_base ;
+    mp->b_datap->db_lim  = newbp->b_datap->db_lim ;
+    mp->b_datap->db_size = newbp->b_datap->db_size ;
+    mp->b_datap->db_ref++ ;		/* incr ref cnt again */
+    mp->b_rptr 	= newbp->b_rptr ;	/* xfer read/write ptrs */
+    mp->b_wptr 	= newbp->b_wptr ;
+
+    newbp->b_datap = NULL ;		/* sever newbp from its data block */
+    newbp->b_rptr  = NULL ;		/* extra care */
+    newbp->b_wptr  = NULL ;		/* extra care */
+    lis_freedb(newbp, 1) ;		/* free newbp's header */
+
+    return(1) ;				/* success */
+
+}/*lis_pullupmsg*/
+
+
+/*  -------------------------------------------------------------------  */
+/* lis_rmvb - remove message block bp from message mp. Returns a
+ *	pointer to the modified message, or NULL if bp was the
+ *	only block, or -1 if bp wasn't in the message
+ */
+mblk_t *
+lis_rmvb(mblk_t *mp, mblk_t *bp)
+{
+    mblk_t *rtn = mp;
+    if(mp == NULL || bp == NULL) return NULL;
+    if(mp == bp) 
+    	rtn = mp->b_cont;
+    else for (;;)
+    {
+    	if (mp == NULL)
+	    return (mblk_t *)-1;
+    	else if (mp->b_cont == bp)
+    	{
+    	    mp->b_cont = bp->b_cont;
+    	    break;
+    	}
+    	else mp = mp->b_cont;
+    }
+    bp->b_cont = NULL;
+    return rtn;
+}/*lis_rmvb*/
+
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/poll.c /usr/src/linux/drivers/streams/LiS/head/poll.c
--- debug/drivers/streams/LiS/head/poll.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/poll.c	Wed Jan  1 14:13:04 1997
@@ -0,0 +1,399 @@
+/************************************************************************
+*                      poll() System Call				*
+*************************************************************************
+*									*
+* This file does the hard work for the poll() system call.  It handles	*
+* STREAMS files using the AT&T poll mechanism and non-streams files	*
+* by using their select functions.					*
+*									*
+* Author:	David Grothe <dave@gcom.com>				*
+*									*
+************************************************************************/
+#include <sys/stream.h>
+#include <sys/poll.h>
+
+typedef struct semaphore	semaphore_t ;
+typedef struct file		file_t ;
+
+long		lis_poll_sleeping ;	/* # times slept > twice on same poll */
+
+typedef struct
+{
+    int		time_out ;
+    long	target_time ;
+    long	jiffies ;
+    long	time_interval ;
+    long	ticks ;
+
+} poll_trace_t ;
+
+poll_trace_t		lis_poll_trace[5] ;
+
+/*
+ * Routines elsewhere in the Linux kernel
+ */
+extern void	select_free_wait(select_table *p) ;
+extern int	select_check(int flag, select_table *wait, struct file *file) ;
+
+/*
+ * Routines elsewhere in STREAMS
+ */
+extern char	*lis_poll_events(short events) ;
+
+
+/************************************************************************
+*                            lis_poll_wakeup                            *
+*************************************************************************
+*									*
+* Called via the polldat structure to wakeup sleeping poll routine.	*
+*									*
+************************************************************************/
+void	lis_poll_wakeup(long arg)
+{
+    struct wait_queue	**poll_wait_addr_ptr = (struct wait_queue **) arg ;
+
+    wake_up(poll_wait_addr_ptr) ;
+
+} /* lis_poll_wakeup */
+
+/************************************************************************
+*                            poll_do_select                             *
+*************************************************************************
+*									*
+* This routine checks the file descriptor using the select mechanism.	*
+*									*
+* We map the different combinations of poll conditions down to the three*
+* select conditions and use the Linux select mechanism to test the	*
+* file for these conditions.						*
+*									*
+************************************************************************/
+int poll_do_select(select_table *wait, file_t *fp, polldat_t *pdat_ptr)
+{
+    short	events = pdat_ptr->pd_events ;	/* poll events */
+    short	revents = 0 ;
+    short	msk ;
+
+    if (   (msk = (events & (POLLIN | POLLPRI | POLLRDNORM | POLLRDBAND))) != 0
+	&& select_check(SEL_IN, wait, fp) != 0
+       )
+    {
+	revents |= msk ;
+    }
+
+    if (   (msk = (events & (POLLOUT | POLLWRNORM | POLLWRBAND))) != 0
+	&& select_check(SEL_OUT, wait, fp) != 0
+       )
+    {
+	revents |= msk ;
+    }
+
+    if (   (msk = (events & (POLLMSG))) != 0
+	&& select_check(SEL_EX, wait, fp) != 0
+       )
+    {
+	revents |= msk ;
+    }
+
+    if ( LIS_DEBUG_POLL )
+    {
+	struct inode	*i ;
+	kdev_t		 rdev ;
+
+	i = fp->f_inode ;
+	if (i != NULL)
+	    rdev = i->i_rdev ;
+	else
+	    rdev = 0 ;
+
+	printk("poll_do_select:  dev=(%d,%d) events:%s revents:%s\n",
+	      MAJOR(rdev), MINOR(rdev),
+	      lis_poll_events((short)events), lis_poll_events((short)revents)) ;
+    }
+
+    return(revents) ;
+
+} /* poll_do_select */
+
+/************************************************************************
+*                             lis_poll                                  *
+*************************************************************************
+*									*
+* Poll file descriptors for operations.					*
+*									*
+************************************************************************/
+int	lis_poll(struct poll *fds, int nfds, int time_out)
+{
+    volatile int	 err;
+    unsigned long	 size = nfds * sizeof(pollfd_t);
+    long		 target_time ;			/* in ms */
+    int			 timer_id = 0 ;
+    long		 time_interval = time_out ;	/* in ms */
+    long		 ms_per_tick = 1000/HZ ;
+    long		 ticks ;			/* in system ticks */
+    pollfd_t		*pfds;
+    pollfd_t		*pfd_ptr ;
+    polldat_t		*pdat_head;
+    polldat_t		*pdat_ptr ;
+    file_t		*fp ;
+    int			 i;
+    int			 done ;
+    int			 ready_fd_cnt = 0 ;
+    int			 psw ;
+    int			 sleep_cnt ;
+    struct wait_queue	 poll_wait = {current, NULL} ;
+    struct wait_queue   *poll_wait_address ;
+    select_table	 poll_select_wait_table ;
+    select_table	*poll_select_wait = &poll_select_wait_table ;
+    struct select_table_entry	*poll_select_table ;
+    int			 select_table_size ;
+    int			 is_stream = 0 ;
+    extern struct file_operations lis_streams_fops ;
+
+    /*
+     * Round time interval up to a multiple of system ticks.
+     */
+    ticks = (time_interval + ms_per_tick - 1) / ms_per_tick ;
+    target_time = lis_target_time(ticks*ms_per_tick) ;
+
+    if (   (err=lis_check_umem(NULL,VERIFY_WRITE,fds,size))<0
+	|| (err=lis_check_umem(NULL,VERIFY_READ,fds,size))<0
+       )
+	return(err);
+
+    if ((pfds = ALLOCF(size,"poll-fd ")) == NULL) 
+	return(-ENOMEM);
+
+    if ((pdat_head = ALLOCF(nfds * sizeof(polldat_t), "poll-data ")) == NULL)
+    {
+	FREE(pfds);
+	return(-ENOMEM);
+    }
+
+    select_table_size = nfds * 3 * sizeof(struct select_table_entry) ;
+    poll_select_table = ALLOCF(select_table_size, "select-table") ;
+    if (poll_select_table == NULL)
+    {
+	FREE(pfds);
+	FREE(pdat_head);
+	return(-ENOMEM);
+    }
+
+    memset(pdat_head, 0, nfds * sizeof(polldat_t)) ;	/* clear to zero */
+    memset(poll_select_table, 0, select_table_size) ;	/* clear to zero */
+    poll_select_wait_table.nr = 0 ;
+    poll_select_wait_table.entry = poll_select_table ;
+
+    /*
+     * Obtain copy of user's poll descriptor list
+     */
+    lis_copyin(NULL,pfds, fds, size);
+
+    /*
+     * Initialize our wait address pointer
+     */
+    init_waitqueue(&poll_wait_address) ;
+
+    /*
+     * Run through the descriptor list and check each file descriptor
+     * for validity.  Mark the ones that are bad.
+     */
+    for (i = 0, pdat_ptr = pdat_head, pfd_ptr = pfds;
+	 i < nfds;
+	 i++, pdat_ptr++, pfd_ptr++
+	)
+    {
+	if (   pfd_ptr->fd>=NR_OPEN
+	    || (fp=current->files->fd[pfd_ptr->fd]) == NULL
+	    || fp->f_inode == NULL
+	   )
+	{				/* not an open file descriptor */
+	    pfd_ptr->revents = POLLNVAL ;
+	    continue ;
+	}
+
+	pdat_ptr->pd_fn	    = lis_poll_wakeup ;
+	pdat_ptr->pd_arg    = (long) &poll_wait_address ;
+    }
+
+    /*
+     * Loop until we find a valid file descriptor which statisfies the
+     * required conditions.  If there were no good file descriptors
+     * then just fall through and return to the user.
+     *
+     * If no file descriptors are found then wait.  When something
+     * happens on one of the streams then the lis_poll_wakeup function
+     * will get called, which will wake us up.  We then go around and
+     * poll again.
+     *
+     * When we exit the loop we will unlink the polldat entries and
+     * return to the user.
+     *
+     * The file system poll function is called with the file info and
+     * a pointer to a polldat structure.  The file system routine
+     * interrogates the file for the requested conditions according
+     * to the 'pd_events' field in the polldat structure.  It returns
+     * a bit-mask of the events that satisfy the conditions, if any.
+     * The file system also sets the pd_headp pointer to point to
+     * its list head in its stream structure for the polldat list.
+     * We take care of linking the structure into the list.
+     *
+     */
+    add_wait_queue(&poll_wait_address, &poll_wait) ;
+    for (done = 0, sleep_cnt = 0; !done; )
+    {
+	current->state = TASK_INTERRUPTIBLE ;
+	for (i = 0, ready_fd_cnt = 0, pdat_ptr = pdat_head, pfd_ptr = pfds;
+	     i < nfds;
+	     i++, pdat_ptr++, pfd_ptr++
+	    )
+	{
+	    if (pfd_ptr->revents & POLLNVAL)
+		continue ;			/* only look at good ones */
+
+	    pdat_ptr->pd_events = pfd_ptr->events ;
+	    fp = current->files->fd[pfd_ptr->fd] ;
+	    is_stream = fp->f_op == &lis_streams_fops ;
+	    if (is_stream)
+	    {
+		if ( (pfd_ptr->revents =
+			(short) lis_strpoll(fp->f_inode, fp, pdat_ptr)) != 0 )
+		{
+		    done = 1 ;			/* loop breaker */
+		    ready_fd_cnt++ ;		/* another ready descriptor */
+		    continue ;			/* skip list manipulations */
+		}
+	    }
+	    else				/* non-stream file */
+	    {					/* use select */
+		if ( (pfd_ptr->revents =
+		       poll_do_select(poll_select_wait, fp, pdat_ptr)) != 0
+		   )
+		{
+		    done = 1 ;			/* loop breaker */
+		    ready_fd_cnt++ ;		/* another ready descriptor */
+		    poll_select_wait = NULL ;	/* no more waiting */
+		    continue ;			/* skip list manipulations */
+		}
+	    }
+
+	    if (ready_fd_cnt)			/* skip list manipulations */
+		continue ;			/* if have ready fds */
+
+	    if (   !is_stream
+		|| pdat_ptr->pd_headp == NULL
+	        || pdat_ptr->pd_headp->ph_list == pdat_ptr
+	        || pdat_ptr->pd_next != NULL
+	        || pdat_ptr->pd_prev != NULL
+	       )
+		   continue ;		/* no list or already in it */
+
+	    SPLSTR(psw) ;		/* protect streams structures */
+
+	    if (pdat_ptr->pd_headp->ph_list == NULL)
+	    {				/* first entry */
+		pdat_ptr->pd_next =
+		pdat_ptr->pd_prev = NULL ;
+		pdat_ptr->pd_headp->ph_list = pdat_ptr ;
+	    }
+	    else			/* multiple entries */
+	    {
+		pdat_ptr->pd_next = pdat_ptr->pd_headp->ph_list ;
+		pdat_ptr->pd_prev = NULL ;
+
+		pdat_ptr->pd_headp->ph_list->pd_prev = pdat_ptr ;
+		pdat_ptr->pd_headp->ph_list	     = pdat_ptr ;
+	    }
+
+	    SPLX(psw) ;
+	}
+
+	if (done)			/* done */
+	    break ;			/* exit while loop */
+
+	/*
+	 * If signalled then return to caller
+	 */
+	if (current->signal & ~current->blocked)
+	{
+	    err = -EINTR ;
+	    break ;
+	}
+
+	/*
+	 * We recompute the interval until the original time out
+	 * since we may wake up and go around several times before
+	 * we finally decide to return.
+	 *
+	 * A timeout value of -1 means wait forever.
+	 */
+	if (time_out != -1)
+	{
+	    if ( (time_interval = lis_time_till(target_time)) <= 0 )
+		break ;			/* time's up */
+
+	    ticks = (time_interval + ms_per_tick - 1) / ms_per_tick ;
+	    timer_id = timeout((timo_fcn_t *) lis_poll_wakeup,
+			       (caddr_t) &poll_wait_address,
+			       ticks) ;
+	}
+
+	if (sleep_cnt < sizeof(lis_poll_trace)/sizeof(lis_poll_trace[0]))
+	{
+	    lis_poll_trace[sleep_cnt].time_out = time_out ;
+	    lis_poll_trace[sleep_cnt].target_time = target_time ;
+	    lis_poll_trace[sleep_cnt].jiffies = jiffies ;
+	    lis_poll_trace[sleep_cnt].time_interval = time_interval ;
+	    lis_poll_trace[sleep_cnt].ticks = ticks ;
+	}
+
+	if (++sleep_cnt > 2)
+	    lis_poll_sleeping++ ;
+
+	schedule() ;
+
+	if (timer_id != 0)
+	    untimeout(timer_id) ;	/* cancel timer */
+    }
+
+    current->state = TASK_RUNNING ;
+    remove_wait_queue(&poll_wait_address, &poll_wait) ;
+
+    /*
+     * Go through and unlink all the polldat structures
+     */
+    for (i = 0, pdat_ptr = pdat_head;
+	 i < nfds;
+	 i++, pdat_ptr++
+	)
+    {
+	if (pdat_ptr->pd_headp != NULL)	/* have list head specified */
+	{
+	    SPLSTR(psw) ;		/* protect streams structures */
+
+	    if (pdat_ptr->pd_headp->ph_list == pdat_ptr)	/* at head */
+		pdat_ptr->pd_headp->ph_list = pdat_ptr->pd_next ;
+
+	    if (pdat_ptr->pd_next)	/* next element exists */
+		pdat_ptr->pd_next->pd_prev = pdat_ptr->pd_prev ;
+
+	    if (pdat_ptr->pd_prev)	/* previous element exists */
+		pdat_ptr->pd_prev->pd_next = pdat_ptr->pd_next ;
+
+	    SPLX(psw) ;
+	}
+    }
+
+    FREE(pdat_head);			/* done with polldat structures */
+
+    select_free_wait(&poll_select_wait_table) ;	/* undo wait q entries */
+    FREE(poll_select_table) ;			/* done with select table */
+
+    lis_copyout(NULL,pfds, fds, size);	/* update user's poll list */
+    FREE(pfds) ;			/* done with fd list */
+
+    if (err < 0)
+	return(err) ;			/* error return from semaphore */
+    else
+	return(ready_fd_cnt) ;		/* return # of ready fds */
+
+} /* lis_poll */
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/port-mdep.c /usr/src/linux/drivers/streams/LiS/head/port-mdep.c
--- debug/drivers/streams/LiS/head/port-mdep.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/port-mdep.c	Fri Dec 27 15:30:15 1996
@@ -0,0 +1,341 @@
+/************************************************************************
+*                  Portable Machine Dependent Code                      *
+*************************************************************************
+*									*
+* This file contains routines for machine (or O/S) dependent		*
+* functions for the portable version of the streams code.		*
+*									*
+* This file contains some routines that will port to any environment	*
+* and includes a second .c file which will contains routines that are	*
+* unique to a particular environment.					*
+*									*
+************************************************************************/
+
+#include <sys/stream.h>
+#include <sys/LiS/errmsg.h>
+
+
+/************************************************************************
+*                         Global Variables                              *
+************************************************************************/
+
+unsigned long		port_clock ;	/* milli-second clock */
+
+/************************************************************************
+*                           port_init                                   *
+*************************************************************************
+*									*
+* This routine is called from outside to initialize the STREAMS system.	*
+*									*
+************************************************************************/
+void	port_init(void)
+{
+    extern void		lis_init_head(void) ;
+
+    lis_init_head() ;
+
+} /* port_init */
+
+/************************************************************************
+*                         port_copyin_str                               *
+*************************************************************************
+*									*
+* Portable routine to copy a string in from user space to kernel.	*
+*									*
+* ustr		pointer to string in user space.			*
+* kstr		pointer to a pointer that will point to kernel memory	*
+*		where the string is copied.  We allocate this memory	*
+*		and the caller must free it using the FREE macro.	*
+* max		Max length of the string.				*
+*									*
+* Return:	< 0 for error, caller does not free memory.		*
+*		0   for success, caller must free memory.		*
+*									*
+************************************************************************/
+int 
+port_copyin_str(struct file *f, const char *ustr, char **kstr, int max)
+{
+	int    i = max;
+	int    error;
+	char   c;
+	char  *tmp;
+	char  *mem ;
+
+	if (max <= 0)
+	    return(-ENOMEM);
+
+	error = -EFAULT;
+	c = (char) port_get_fs_byte(f, ustr++);
+	if (!c)
+	    return(-EINVAL);
+
+	if ((mem = ALLOCF(max,"copyin-buf ")) == NULL)
+	    return(-ENOMEM);
+
+	*kstr = tmp = mem ;
+	while (--i)
+	{
+	    *(tmp++) = c;
+	    c = (char) port_get_fs_byte(f, ustr++);
+	    if (!c)
+	    {
+		*tmp = '\0';
+		return(0);
+	    }
+	}
+
+	FREE(mem);
+	return(error);
+
+} /* port_copyin_str */
+
+/************************************************************************
+*                            lis_errmsg                                 *
+*************************************************************************
+*									*
+* Return a pointer to a string that will serve as a prefix for the	*
+* standard lis error message.						*
+*									*
+************************************************************************/
+char  *lis_errmsg( int lvl )
+{
+    switch(lvl)
+    {
+    case LIS_PANIC:
+	return("PANIC");
+    case LIS_ERROR:
+	return("ERROR");
+    case LIS_WARN:
+	return("WARNING");
+    case LIS_DEBUG:
+	return("DEBUG");
+    default:
+	return("unknown severity");
+    }
+
+} /*lis_errmsg*/
+
+/************************************************************************
+*                         Timer Mechanism                               *
+*************************************************************************
+*									*
+* This code is borrowed from the Linux kernel and reworked so that	*
+* it maintains time deltas rather than absolute time.  See the comments	*
+* in the individual routines below.					*
+*									*
+* Author:	David Grothe <dave@gcom.com>				*
+*									*
+************************************************************************/
+
+static struct timer_list timer_head =
+			 { &timer_head, &timer_head, 0, 0, NULL };
+
+/*
+ * Add a timer list entry to the list of entries, this effectively
+ * starts the timer.  The list is kept in ascending order of number
+ * of ticks until the timer expires.  As you go down the list the
+ * 'tdelta' fields are cumulative.  Each one specifies the additional
+ * amount of time after the previous entry would expire.
+ */
+void port_add_timer(struct timer_list * timer)
+{
+    int			 flags;
+    struct timer_list	*p;
+
+    if (timer->next != NULL || timer->prev != NULL)
+    {
+	printk("add_timer(%lx) called with non-zero list\n", timer) ;
+	return;
+    }
+
+    p = &timer_head;
+    SPLSTR(flags);
+    do
+    {
+	timer->tdelta -= p->tdelta ;	/* reduce ticks difference */
+	p = p->next;
+
+    } while (p != &timer_head && timer->tdelta > p->tdelta);
+
+    if (p != &timer_head)		/* real entry */
+	p->tdelta -= timer->tdelta;	/* less delta to get to the next one */
+
+    timer->next = p;			/* put timer before 'p' */
+    timer->prev = p->prev;
+    p->prev = timer;
+    timer->prev->next = timer;
+
+    SPLX(flags);
+
+} /* port_add_timer */
+
+/*
+ * Find the timer-list entry and remove it from the linked list
+ */
+int port_del_timer(struct timer_list * timer)
+{
+    int			 flags;
+    struct timer_list	*p;
+
+    p = &timer_head;
+    SPLSTR(flags);
+    while ((p = p->next) != &timer_head)
+    {
+	if (p == timer)
+	{
+	    if (p->next != &timer_head)		/* real timer entry follows */
+	    	p->next->tdelta += timer->tdelta ;	/* add back our time */
+
+	    timer->next->prev = timer->prev;	/* delink our entry */
+	    timer->prev->next = timer->next;
+	    timer->next = timer->prev = NULL;
+
+	    /*
+	     * Clear any residual ticks saved up by the
+	     * announce time routine if the timer list is
+	     * now empty.
+	     */
+	    if (timer_head.next == &timer_head)
+		port_announce_time(0) ;
+
+	    SPLX(flags);
+	    return 1;
+	}
+    }
+
+    if (timer->next || timer->prev)
+	    printk("del_timer(%lx) called from with timer not found in table\n",
+		    timer) ;
+
+    SPLX(flags);
+    return 0;
+
+} /* port_del_timer */
+
+/*
+ * The porting environment must call this routine periodically to
+ * input time into the timeout mechanism.  This routine can be called
+ * from interrupt level or from background.  The entire routine runs
+ * with interrupts disabled.
+ *
+ * Calls to user time out routines will be made from here with the
+ * processor status restored to that of caller.  If you call this
+ * routine from interrupt level then all the timer callout routines
+ * will be called with interrupts disabled.  If you call it from
+ * background then they will be run with interrupts enabled.
+ */
+void port_announce_time(long new_milli_secs)
+{
+    static unsigned long milli_secs ;	/* time interval saved up */
+    static int		 entered ;
+    int			 flags ;
+    struct timer_list	*timer;
+
+    SPLSTR(flags);			/* protect linked list loop */
+
+    milli_secs += new_milli_secs ;	/* add to total nr of milli-secs */
+    port_clock += new_milli_secs ;	/* keep global elapsed time */
+
+    if (timer_head.next == &timer_head)	/* list empty */
+    {
+	milli_secs = 0 ;		/* do not accumulate time */
+	SPLX(flags);			/* re-enable intrs */
+	return ;			/* nested call */
+    }
+
+    if (entered)			/* nested entry */
+    {
+	SPLX(flags);			/* re-enable intrs */
+	return ;			/* nested call */
+    }
+
+    entered = 1 ;			/* prevent nesting */
+
+    /*
+     * Because the table is ordered by time deltas, it is always the
+     * ones at the head of the list that need to be sprung.  Whenever
+     * we spring one we decrement that time's tdelta from our number
+     * of milliseconds that have passed so we can meaningfully compare
+     * against the next entry.
+     */
+    while (   (timer = timer_head.next) != &timer_head	/* list non-empty */
+	   && timer->tdelta <= milli_secs		/* 1st elt expired */
+	  )
+    {
+	void		       (*fn)(unsigned long) = timer->function;
+	unsigned long     	 data = timer->data;
+
+	milli_secs 	     -= timer->tdelta ;	/* less time to nxt ntry */
+
+	timer->next->prev     = timer->prev;	/* delink timer entry */
+	timer->prev->next     = timer->next;
+	timer->next	      =			/* clear links */
+	timer->prev	      = NULL;
+
+	SPLX(flags);
+	if (fn != NULL) fn(data);		/* be careful of NULL ptr */
+	SPLSTR(flags);
+    }
+
+    entered = 0 ;				/* allow calls again */
+
+    SPLX(flags);
+	
+} /* port_announce_time */
+
+/*
+ * This routine is called from dki.c to start a timer. 'ticks' is
+ * in units of HZ (typically 1/100th of a second, or 10ms).
+ */
+void
+lis_tmout(struct timer_list *tl, void (*fn)(ulong), long arg, long ticks)
+{
+    tl->next	= NULL ;
+    tl->prev	= NULL ;
+    tl->function= fn;
+    tl->data	= arg;
+    tl->tdelta	= ticks * (1000/HZ) ;		/* convert to milli-secs */
+    port_add_timer(tl);
+}
+
+/*
+ * This routine is called from dki.c to stop a timer.
+ */
+void
+lis_untmout(struct timer_list *tl)
+{
+    port_del_timer(tl);
+}
+
+/************************************************************************
+*                            port_time_till                             *
+*************************************************************************
+*									*
+* Given a target time in terms of elapsed milli-seconds, in other words,*
+* the same units as the global port_clock, return the number of		*
+* milli-seconds that it will take to reach to target time.		*
+*									*
+* The return is negative if the target time is in the past, zero	*
+* if it is the same as the current target time, and positive if		*
+* target time is in the future.						*
+*									*
+************************************************************************/
+long	port_time_till(long target_time)
+{
+    return( target_time - port_clock ) ;
+
+} /* port_time_till */
+
+/************************************************************************
+*                           port_target_time                            *
+*************************************************************************
+*									*
+* Convert the milli_sec interval to an absolute target time expressed	*
+* in the same manner as the global port_clock.				*
+*									*
+************************************************************************/
+long	port_target_time(long milli_sec)
+{
+    return( port_clock + milli_sec ) ;
+
+} /* port_target_time */
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/qnx-mdep.c /usr/src/linux/drivers/streams/LiS/head/qnx-mdep.c
--- debug/drivers/streams/LiS/head/qnx-mdep.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/qnx-mdep.c	Wed Jan  1 14:13:04 1997
@@ -0,0 +1,39 @@
+/************************************************************************
+*                        QNX Driver Routines 			 	*
+*************************************************************************
+*									*
+* This file contains abstract routine definitions suitable for running	*
+* STREAMS as a QNX driver.						*
+*									*
+* It includes "port-mdep.c" first and then adds in code specific to	*
+* the user level environment.						*
+*									*
+* Author: Mikel Matthews <mikel@gcom.com>				*
+*									*
+************************************************************************/
+
+#include "port-mdep.c"
+
+
+#include <sys/LiS/head.h>		/* for strread, strwrite, etc */
+
+struct file_operations
+lis_streams_fops = {
+	NULL,			/* lseek   -- no lseek  */
+	lis_strread,		/* read    		*/
+	lis_strwrite,		/* write to stream      */
+	NULL,			/* readdir -- no readdir*/
+	NULL,			/* select  		*/
+	lis_strioctl,		/* ioctl   		*/
+	NULL,			/* mmap    -- no mmap   */
+	lis_stropen,		/* open the stream      */
+	lis_strclose,		/* close the stream     */
+	NULL,			/* fsync   -- no fsync  */
+	NULL,			/* fasync  -- no fasync */
+	NULL,			/* check_media_change	*/
+	NULL,			/* revalidate		*/
+	lis_strputpmsg,		/* putpmsg & putmsg	*/
+	lis_strgetpmsg,		/* getpmsg & getmsg	*/
+	lis_strpoll		/* poll			*/
+};
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/qstreams.c /usr/src/linux/drivers/streams/LiS/head/qstreams.c
--- debug/drivers/streams/LiS/head/qstreams.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/qstreams.c	Mon Dec 16 16:36:38 1996
@@ -0,0 +1,144 @@
+#include <sys/types.h>
+#undef GCOM_OPEN
+#include <sys/stropts.h>
+#include <sys/LiS/stats.h>
+#ifdef QNX
+#include <unix.h>
+#define	LOOP_CLONE	"/dev/gcom/loop_clone"
+#else
+#define	LOOP_CLONE	"/dev/loop_clone"
+#endif
+#include <sys/ioctl.h>
+#include <unistd.h>
+
+unsigned long strstats[STRMAXSTAT][4]; /* the stats */
+
+void print_debug_bits(void)
+{
+	printf("DEBUG_OPEN		0x00000001\n");
+	printf("DEBUG_CLOSE		0x00000002\n");
+	printf("DEBUG_READ		0x00000004\n");
+	printf("DEBUG_WRITE		0x00000008\n");
+	printf("DEBUG_IOCTL		0x00000010\n");
+	printf("DEBUG_PUTNEXT		0x00000020\n");
+	printf("DEBUG_STRRPUT		0x00000040\n");
+	printf("DEBUG_SIG		0x00000080\n");
+	printf("DEBUG_PUTMSG		0x00000100\n");
+	printf("DEBUG_GETMSG		0x00000200\n");
+	printf("DEBUG_POLL		0x00000400\n");
+	printf("DEBUG_LINK		0x00000800\n");
+	printf("DEBUG_SAFE		0x00010000\n");
+	printf("DEBUG_TRCE_MSG		0x00020000\n");
+	printf("DEBUG_CLEAN_MSG		0x00040000\n");
+	printf("DEBUG_MP_ALLOC		0x00100000\n");
+	printf("DEBUG_MP_FREEMSG	0x00200000\n");
+	printf("DEBUG_MALLOC		0x00400000\n");
+	printf("DEBUG_MONITOR_MEM	0x00800000\n");
+	printf("DEBUG_DMP_QUEUE		0x01000000\n");
+	printf("DEBUG_DMP_MBLK		0x02000000\n");
+	printf("DEBUG_DMP_DBLK		0x04000000\n");
+	printf("DEBUG_DMP_STRHD		0x08000000\n");
+	printf("DEBUG_ADDRS		0x80000000\n");
+
+} /* print_debug_bits */
+
+void main( int argc, char *argv[])
+{
+    int		fd ;
+    int		rslt ;
+    int		c;
+    unsigned long debug_mask;
+    int		mflag = 0;
+    int		dflag = 0;
+    int		sflag = 0;
+
+    while(( c = getopt(argc, argv, "smhHd:")) != -1)
+    {
+	switch (c)
+	{
+	    case 'd':
+	        dflag = 1;
+	        if ( sscanf(optarg, "%x", &debug_mask) != 1 )
+	        {
+	            printf("need hex argument for -d\n");
+	            exit(1);
+	        }
+		break;
+
+	    case 's':
+	        sflag = 1;
+	        break;
+
+	    case 'm':
+	        mflag = 1;
+	        break;
+
+	    case 'h':
+	    case 'H':
+	    case '?':
+	    default:
+		printf("%s: command line argument error.\n", argv[0]);
+		printf("	-d debug mask (in hex)\n");
+		printf("	-s print streams memory stats\n");
+		printf("	-m print memory allocation to log file\n");
+
+		if (c == 'H')
+		    print_debug_bits() ;
+
+		exit(1);
+	}
+    }
+
+    if ( !mflag && !dflag && !sflag )
+    {
+	printf("%s: command line argument error.\n", argv[0]);
+	printf("	-d debug mask (in hex)\n");
+	printf("	-s print streams memory stats\n");
+	printf("	-m print memory allocation to log file\n");
+	exit(1);
+    }
+
+    fd = open(LOOP_CLONE, 0, 0) ;
+    if (fd < 0)
+    {
+	printf(LOOP_CLONE ": %s\n", strerror(-fd)) ;
+	exit(1) ;
+    }
+
+    if ( dflag )
+    {
+	rslt = ioctl(fd, I_LIS_SDBGMSK, debug_mask) ;
+	if (rslt < 0)
+	{
+	    printf(LOOP_CLONE ": I_LIS_SDBGMSK: %s\n", strerror(-rslt)) ;
+	    exit(1) ;
+	}
+    }
+
+    if ( sflag )
+    {
+	/* printf("sizeof strstats: %d\n", sizeof(strstats)); */
+	rslt = ioctl(fd, I_LIS_GETSTATS, strstats) ;
+	if (rslt < 0)
+	{
+	    printf(LOOP_CLONE ": I_LIS_GETSTATS: %s\n", strerror(-rslt)) ;
+	    exit(1) ;
+	}
+	LisShowStrStats(strstats);
+    }
+
+    if ( mflag )
+    {
+	rslt = ioctl(fd, I_LIS_PRNTMEM, 0) ;
+	if (rslt < 0)
+	{
+	    printf(LOOP_CLONE ": I_LIS_PRNTMEM: %s\n", strerror(-rslt)) ;
+	    exit(1) ;
+	}
+#ifdef QNX
+	printf("The memory dump is in the /usr/lib/gcom/streams.log file\n");
+#endif
+    }
+    close(fd) ;
+
+} /* set_debug_mask */
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/queue.c /usr/src/linux/drivers/streams/LiS/head/queue.c
--- debug/drivers/streams/LiS/head/queue.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/queue.c	Wed Jan  1 14:13:04 1997
@@ -0,0 +1,1203 @@
+/*                               -*- Mode: C -*- 
+ * queue.c --- streams statistics
+ * Author          : Graham Wheeler, Francisco J. Ballesteros
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: queue.c,v 1.9 1996/01/24 19:01:26 dave Exp $
+ * Purpose         : provide some queue for LiS
+ * ----------------______________________________________________
+ *
+ *   Copyright (C) 1995  Graham Wheeler, Francisco J. Ballesteros
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to 
+ *    gram@aztec.co.za, nemo@ordago.uc3m.es
+ *    dave@gcom.com
+ */
+
+/* Incomplete stuff:
+ * lis_flushband()		--- these three ones are for band handling
+ * lis_strqget()		--- not implemented by now (!!)
+ * lis_strqset()
+ *
+ * lis_appq()
+ */
+
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#include <sys/stream.h>
+#include <string.h>
+
+/*  -------------------------------------------------------------------  */
+/*			   Local functions & macros                      */
+
+
+/*  -------------------------------------------------------------------  */
+/* find_qband
+ *
+ * Given a queue and a class number, return a pointer to the
+ * qband structure for that band.
+ *
+ * Return NULL if we had to allocate a band structure and we
+ * could not get the memory.
+ *
+ * This routine assumes that SPLSTR has been done before calling it.
+ */
+static INLINE struct qband *
+find_qband(queue_t *q, int msg_class)
+{
+    struct qband	*qp ;
+    uchar		 msgclass = (uchar) msg_class ;
+
+    if (q == NULL || msgclass > LIS_MAX_BAND) return(NULL) ;
+
+    qp = q->q_bandp;
+    while (qp != NULL)
+    {
+	if ( qp->qb_first != NULL && qp->qb_first->b_band == msgclass )
+	    break;			/* found the band structure */
+
+	qp = qp->qb_next;
+    }
+
+    if (qp == NULL)			/* could not find the band struct */
+    {					/* find an unused one */
+	qp = q->q_bandp;
+	while (qp != NULL)
+	{
+	    if ( qp->qb_first == NULL )
+		break;			/* unused band structure */
+
+	    qp = qp->qb_next;
+	}
+    }
+
+    if (qp == NULL)			/* no such band */
+    {					/* and no unused structures */
+	qp = (qband_t*) ALLOCF(sizeof(struct qband),"qband ");
+	if (qp == NULL) return(NULL) ;	/* could not allocate */
+
+	qp->qb_next = q->q_bandp;
+	q->q_bandp = qp;
+	qp->qb_first = qp->qb_last = NULL;
+    }
+
+    if (qp->qb_first == NULL)
+    {					/* new or resused qband structure */
+	qp->qb_count = 0;
+	qp->qb_flag  = 0 ;
+	qp->qb_hiwat = q->q_hiwat;
+	qp->qb_lowat = q->q_lowat;
+    }
+
+    return(qp) ;			/* rtn ptr to band structure */
+
+} /* find_qband */
+
+/*  -------------------------------------------------------------------  */
+/* updatequeue - update queue info after a message is added
+ *	Assumes that SPLSTR has been done!
+ *
+ * This routine assumes that SPLSTR has been done before calling it.
+ */
+static INLINE void
+updatequeue(queue_t *q, mblk_t *mp)
+{
+    uchar	 msg_class = mp->b_band;
+
+    if (mp->b_datap->db_type >= QPCTL || mp->b_band == 0)
+    {
+        q->q_count += lis_msgsize(mp);
+        if (q->q_count > q->q_hiwat)
+	    q->q_flag |= QFULL;
+    }
+    else
+    {						/* qband considerations */
+	struct qband *qp = find_qband(q, msg_class) ; /* get qband struct */
+
+	if (qp != NULL)
+	{
+	    qp->qb_count += lis_msgsize(mp);	/* qband stats */
+	    if (qp->qb_count > qp->qb_hiwat)
+		qp->qb_flag |= QB_FULL;
+
+	    if (qp->qb_first == NULL)
+		qp->qb_first = mp;		/* this is 1st msg in band */
+
+	    if (qp->qb_last == NULL)		/* new qband */
+		qp->qb_last = mp;
+	}
+    }
+
+    if (mp->b_datap->db_type >= QPCTL ||
+       (lis_canenable(q) && (q->q_flag & QWANTR) != 0))
+         lis_qenable(q);
+
+}/*updatequeue*/
+
+/*  -------------------------------------------------------------------  */
+/* find_q_spot
+ *
+ * Find "the correct spot" in the queue for the message.
+ *
+ * Find the element that we will link this message in front of. 
+ *
+ * find_q_spot_head finds the first message of the proper class.
+ * find_q_spot_tail finds the message beyond the last message of
+ * the given class.
+ *
+ * Return NULL if there is no message that we can link in front of.
+ * This will be the return for an empty queue, or for a message that
+ * needs to be placed on the end of the queue.
+ *
+ * This routine assumes that SPLSTR has been done before calling it.
+ */
+static INLINE mblk_t *
+find_q_spot_head(queue_t *q, mblk_t *mp)
+{
+    uchar	 msg_class ;
+    uchar	 mp_type ;
+    mblk_t	*p_cont ;
+    mblk_t	*firstp ;
+
+    if (q == NULL || (firstp = q->q_first) == NULL) return(NULL) ;
+
+    msg_class = mp->b_band;
+    if ((mp_type = mp->b_datap->db_type) >= QPCTL)
+	mp->b_band = 0 ;			/* AT&T STRMS pgrmrs guide */
+
+    if (mp_type >= QPCTL)			/* msg is high priority */
+	return(firstp) ;			/* goes as the 1st msg */
+
+    if (   firstp->b_datap->db_type < QPCTL	/* 1st is not high prior */
+	&& msg_class >= firstp->b_band		/* greater class than 1st msg */
+       )
+	    return(firstp) ;			/* goes as 1st msg */
+
+    /* find the first non-high-priority message in the queue */
+    for (p_cont = firstp;
+	 (   p_cont != NULL
+	  && p_cont->b_datap->db_type >= QPCTL   /* skip high prior msgs */
+	 );
+	 p_cont = p_cont->b_next
+	) ;
+
+    /* find the first message after that with class <= our msg */
+    for (;
+	 (   (p_cont != NULL)
+	  && (p_cont->b_band > msg_class)	/* skip higher band msgs */
+	 );
+	 p_cont = p_cont->b_next
+	) ;
+
+    return(p_cont) ;			/* insert before here */
+
+} /* find_q_spot_head */
+
+static INLINE mblk_t *
+find_q_spot_tail(queue_t *q, mblk_t *mp)
+{
+    uchar	 msg_class ;
+    uchar	 mp_type ;
+    mblk_t	*p_cont ;
+    mblk_t	*lastp ;
+    mblk_t	*firstp ;
+
+    if (q == NULL || (firstp = q->q_first) == NULL) return(NULL) ;
+
+    msg_class = mp->b_band;
+    if ((mp_type = mp->b_datap->db_type) >= QPCTL)
+	mp->b_band = 0 ;			/* AT&T STRMS pgrmrs guide */
+
+        /* find a spot at the end of a message class */
+    lastp = q->q_last ;
+    if (lastp->b_datap->db_type >= QPCTL)	/* q full of hi-prior msgs */
+	    return(NULL) ;			/* it goes on the end */
+
+    if (   mp_type < QPCTL			/* non-priority msg */
+        && msg_class <= lastp->b_band		/* lower than last msg */
+       )
+	    return(NULL) ;			/* it goes on the end */
+
+    /* have to find a spot in the middle of the queue */
+    /* first, skip over all of the high-priority msgs */
+
+    for (p_cont = firstp;
+	 (   p_cont != NULL
+	  && p_cont->b_datap->db_type >= QPCTL   /* skip high prior msgs */
+	 );
+	 p_cont = p_cont->b_next
+	) ;
+
+    /* if the message is a high priority message then we are done */
+
+    if (mp_type < QPCTL)			/* non-priority msg */
+    {
+    	for (;					/* find end of mp's band */
+    	     (   (p_cont != NULL)
+	      && (p_cont->b_band >= msg_class)	/* skip higher band msgs */
+	     );
+	     p_cont = p_cont->b_next
+	    ) ;
+    }
+
+    return(p_cont) ;				/* insert before here */
+
+} /* find_q_spot_tail */
+
+
+/*  -------------------------------------------------------------------  */
+/* ins_before
+ *
+ * This routine will insert the given message in front of the
+ * message whose ptr is passed in.
+ *
+ * This routine assumes that SPLSTR has been done before calling it.
+ */
+static INLINE void
+ins_before(queue_t *q, mblk_t *before_msg, mblk_t *mp)
+{
+    LisUpCount(MSGSQD) ;			/* one more msg queued */
+    if (q->q_first == NULL)			/* empty queue */
+    {
+    	mp->b_prev = mp->b_next = NULL;		/* quick & easy */
+    	q->q_first = q->q_last = mp;
+    	return ;				/* done */
+    }
+
+    if (before_msg == NULL)			/* add to end of queue */
+    {
+	q->q_last->b_next	= mp;
+	mp->b_prev		= q->q_last;
+	q->q_last		= mp;
+	mp->b_next		= NULL;
+	return ;
+    }
+
+    /* insert in front of 'before_msg' */
+
+    mp->b_next			   = before_msg;
+    mp->b_prev			   = before_msg->b_prev;
+
+    if (before_msg->b_prev != NULL)
+	before_msg->b_prev->b_next = mp;
+    else
+	q->q_first		   = mp;
+
+    before_msg->b_prev		   = mp;
+
+} /* ins_before */
+
+/*  -------------------------------------------------------------------  */
+/* rmv_msg
+ *
+ * Remove a message from a queue.  The message is known to reside in
+ * the queue.
+ *
+ * This routine assumes that SPLSTR has been done before calling it.
+ */
+static INLINE mblk_t *
+rmv_msg(queue_t *q, mblk_t *mp)
+{
+    if (mp == NULL)			/* no message */
+    {					/* empty queue */
+	q->q_flag |= QWANTR | QBACK;	/* note that someone wants to read */
+	lis_backenable(q);
+	return(mp) ;
+    }
+
+    q->q_flag &= ~QWANTR;		/* no implicit qenable now */
+
+    if (mp->b_datap->db_type < QPCTL && mp->b_band > 0)
+    {
+	struct qband *qp = find_qband(q, mp->b_band) ; /* get qband struct */
+
+	if (qp != NULL)
+	{
+	    qp->qb_count -= lis_msgsize(mp);	/* qband stats */
+	    if (qp->qb_count <= qp->qb_hiwat)
+		qp->qb_flag &= ~QB_FULL;
+
+	    if (qp->qb_count <= qp->qb_lowat)	/* below low water?	*/
+	    {
+		/* Does anyone know what it means to back-enable a band? */
+		/* I will assume that we do the same type of processing  */
+		/* as for the whole queue.				 */
+		/* One bug is that nobody ever clears the QB_BACK flag!	 */
+
+		qp->qb_flag |= QB_BACK;		/* must back enable	*/
+		if (qp->qb_flag & QB_WANTW)
+		{				/* xfer flag to main queue */
+		    qp->qb_flag &= ~QB_WANTW;
+		    q->q_flag   |= QWANTW;
+		}
+
+		q->q_flag |= QBACK;
+	    }
+
+	    /* mp may be in the middle or end of a band if this was	*/
+	    /* done via rmvq().						*/
+
+	    if (qp->qb_first == mp)		/* rmving 1st msg of band */
+	    {
+		if (mp->b_next && mp->b_next->b_band == mp->b_band)
+		    qp->qb_first = mp->b_next ;	/* nxt msg in same band */
+		else
+		{
+		    qp->qb_first = NULL ;	/* band now empty */
+		    qp->qb_last  = NULL;	/* band struct available */
+		}
+	    }
+
+	    if (qp->qb_last == mp)		/* rmving last msg of band */
+	    {
+		if (mp->b_prev && mp->b_prev->b_band == mp->b_band)
+		    qp->qb_last = mp->b_prev ;	/* nxt msg in same band */
+		else
+		{
+		    qp->qb_first = NULL ;	/* band now empty */
+		    qp->qb_last  = NULL;	/* band struct available */
+		}
+	    }
+	}
+    }
+    else
+    {
+	q->q_count -= lis_msgsize(mp);
+	if (q->q_count < q->q_hiwat)
+	    q->q_flag &= ~QFULL;
+
+	if (q->q_count <= q->q_lowat)	/* below low water?		*/
+	    q->q_flag |= QBACK;		/* must back enable		*/
+    }
+
+    /* perform q remove here */
+
+    if (mp->b_prev != NULL)
+    	mp->b_prev->b_next = mp->b_next;
+    else
+    	q->q_first = mp->b_next;
+
+    if (mp->b_next != NULL)
+    	mp->b_next->b_prev = mp->b_prev;
+    else
+    	q->q_last = mp->b_prev;
+
+    mp->b_prev = mp->b_next = NULL;
+
+    lis_backenable(q);
+    LisDownCount(MSGSQD) ;		/* one fewer msg queued */
+
+    return(mp) ;			/* return our argument */
+
+} /* rmv_msg */
+
+
+/*  -------------------------------------------------------------------  */
+/*				  Glob. Vars                             */
+
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+/* backq - Return the queue which feeds this one.
+ *
+ * If q is a read queue then return the ptr to the downstream queue.
+ * If q is a write queue then return the ptr to the upstream queue.
+ */
+queue_t *
+lis_backq(queue_t *q)
+{
+    queue_t	*other_q ;
+
+    if (q == NULL || (other_q = LIS_OTHERQ(q)) == NULL)
+    	return NULL;
+
+    if (other_q->q_next == NULL)	/* is there a successor queue */
+	return(NULL) ;			/* no */
+
+    return(LIS_OTHERQ(other_q->q_next)) ;  /* the queue that points to 'q' */
+
+}/*lis_backq*/
+
+/*  -------------------------------------------------------------------  */
+
+/* lis_backenable - enable back queue if QWANTW is set, i.e.
+ *	if a back queue is full.
+ *
+ *	If the queue is marked as closing then do not stop
+ *	at the first queue with a service procedure, keep
+ *	going as long as the queues are empty.  The idea is
+ *	to eventually enable the service procedure for the
+ *	queue head.
+ */
+void 
+lis_backenable(queue_t *q)
+{
+    if (   (   (q->q_flag & (QWANTW|QBACK))==(QWANTW|QBACK)
+            || (q->q_flag & QCLOSING)
+           )
+	&& q->q_count<=q->q_lowat
+       )
+    {
+	/* Someone wants to write and there is space. Find a previous
+	   queue to back-enable and enable it */
+    	q->q_flag &= ~(QWANTW|QBACK);
+        while((q = lis_backq(q)) != NULL)
+	{
+	    if (q->q_qinfo->qi_srvp != NULL)
+	    {
+	     	lis_qenable(q);
+	     	if (!F_ISSET(q->q_flag,QCLOSING) || q->q_count != 0)
+		    break;			/* quit searching */
+	    }
+	}
+    }
+}/*lis_backenable*/
+
+/*  -------------------------------------------------------------------  */
+/* lis_getq - get message from head of queue
+ */
+
+mblk_t *
+lis_getq(queue_t *q)
+{
+    mblk_t *rtn;
+    int     psw;
+
+    if (q == NULL)
+	return NULL;			/* sanity check	*/
+
+    SPLSTR(psw);
+    rtn = rmv_msg(q, q->q_first) ;
+    SPLX(psw);
+    return rtn;
+
+}/*lis_getq*/
+
+/*  -------------------------------------------------------------------  */
+/* putq- put a message into a queue
+ */
+int
+lis_putq(queue_t *q, mblk_t *mp)
+{
+    int psw;
+    if (mp == NULL)
+	return 0;
+    if (q == NULL){
+	lis_freemsg(mp);
+	return 0;
+    }
+    SPLSTR(psw);
+    ins_before(q, find_q_spot_tail(q, mp), mp) ;
+    updatequeue(q, mp);			/* Update queue counts and flags */
+    SPLX(psw);
+    lis_runqueues();				/* schedule queues to run */
+    return 1;					/* success */
+
+}/*lis_putq*/
+
+
+/*  -------------------------------------------------------------------  */
+/* putbq - return a message to a queue
+ */
+int
+lis_putbq(queue_t *q, mblk_t *mp)
+{
+    int psw;
+
+    if (mp == NULL) return 0;
+    if (q == NULL)
+    {
+    	lis_freemsg(mp);
+    	return 0;
+    }
+    SPLSTR(psw);
+    ins_before(q, find_q_spot_head(q, mp), mp) ;
+    updatequeue(q, mp);			/* Update queue counts and flags */
+    SPLX(psw);
+    return 1;					/* success */
+
+}/*lis_putbq*/
+
+/*  -------------------------------------------------------------------  */
+/*insq - insert mp before emp. If emp is NULL, insert at end
+ *	of queue. If the insertion is out-of-order, the insert fails.
+ *	Returns 1 on success; 0 otherwise.
+ */
+int
+lis_insq(queue_t *q, mblk_t *emp, mblk_t *mp)
+{
+    int psw;
+
+    if (mp == NULL) return 0;
+    if (q == NULL)
+    {
+    	lis_freemsg(mp);
+    	return 0;
+    }
+    SPLSTR(psw);
+
+    /* check to see if this insertion is proper */
+
+    if (   mp->b_datap->db_type < QPCTL		/* non-high priority msg */
+        && emp != NULL				/* have emp */
+        && (   emp->b_datap->db_type >= QPCTL	/* emp is high priority */
+            || mp->b_band < emp->b_band		/* too high a class */
+            || (   emp->b_prev != NULL
+                && mp->b_band > emp->b_prev->b_band
+               )
+           )
+       )
+    {
+	LisUpFailCount(MSGSQD) ;		/* error queueing msg */
+	SPLX(psw);
+	return(0) ;				/* failed */
+    }
+
+    ins_before(q, emp, mp) ;
+    updatequeue(q, mp);
+    SPLX(psw);
+    return 1;					/* success */
+
+}/*lis_insq*/
+
+/*  -------------------------------------------------------------------  */
+/* rmvq - remove a message from a queue. If the message
+ *		does not exist, panic.
+ */
+void
+lis_rmvq(queue_t *q, mblk_t *mp)
+{
+    mblk_t *bp;
+    int psw;
+    if (mp == NULL) return;
+    if (q == NULL)
+	PANIC("Null queue in rmvq");
+    SPLSTR(psw);
+    /* check if mesage is in queue */
+    bp = q->q_first;
+    while (bp && bp != mp)
+	bp = bp->b_next;
+    if (bp == NULL)
+    {
+	SPLX(psw);
+	PANIC("rmvq: message not in queue");
+    }
+
+    /* Remove message from queue */
+    rmv_msg(q, bp) ;
+    SPLX(psw);
+
+}/*lis_rmvq*/
+
+/*  -------------------------------------------------------------------  */
+
+/* lis_qenable - schedule a queue for service
+ */
+void 
+lis_qenable(queue_t *q)
+{
+    int psw;
+    SPLSTR(psw);
+    /* is there a service procedure? if not, just return */
+    if (q == NULL || q->q_qinfo == NULL || q->q_qinfo->qi_srvp == NULL)
+	goto done;
+    /* if QNOENAB is set, just return */
+    if ((q->q_flag & QNOENB) != 0)
+	goto done;
+    /* if already enabled, just return */
+    if ((q->q_flag & QENAB) != 0)
+	goto done;
+    /* enable the queue for servicing */
+    q->q_flag |= QENAB;
+    /* link into tail of list of scheduled queues (qtail) */
+    q->q_link = NULL;
+    if (lis_qhead == NULL)
+	lis_qhead = q;
+    else
+    	lis_qtail->q_link = q;
+    lis_qtail = q;		
+    LisUpCount(QSCHEDS) ;
+    lis_setqsched();
+done:
+    SPLX(psw);
+}/*lis_qenable*/
+
+/*  -------------------------------------------------------------------  */
+
+/* lis_setq - Set queue variables
+ */
+void
+lis_setq(queue_t * q, struct qinit *rinit, struct qinit *winit)
+{
+    if (rinit == NULL || winit == NULL)
+    {
+	printk("lis_setq: NULL pointer(s) to qinit structures\n") ;
+	return ;
+    }
+
+    if (q)
+    {
+	int psw;
+
+	SPLSTR(psw);
+
+        q->q_qinfo  = rinit;
+        q->q_lowat  = rinit->qi_minfo->mi_lowat;
+        q->q_hiwat  = rinit->qi_minfo->mi_hiwat;
+        q->q_minpsz = rinit->qi_minfo->mi_minpsz; 
+        q->q_maxpsz = rinit->qi_minfo->mi_maxpsz; 
+
+        q = LIS_WR(q);
+        q->q_qinfo  = winit;
+        q->q_lowat  = winit->qi_minfo->mi_lowat;
+        q->q_hiwat  = winit->qi_minfo->mi_hiwat;
+        q->q_minpsz = winit->qi_minfo->mi_minpsz; 
+        q->q_maxpsz = winit->qi_minfo->mi_maxpsz; 
+
+	SPLX(psw);
+    }
+}/*lis_setq*/
+
+/*  -------------------------------------------------------------------  */
+/* lis_flushband - flush messages in a specified priority band.
+ *	flag can be FLUSHDATA (flush only M_DATA, M_DELAY,
+ *	M_PROTO, M_PCPROTO) or FLUSHALL.
+ */
+void
+lis_flushband(queue_t *q, unsigned char band, int flag)
+{
+    int psw;
+
+    if (q == NULL) return;
+
+    if (band > 0)
+    {
+	struct qband *qp ;
+	mblk_t	     *mp ;
+	mblk_t	     *p_next ;
+
+	SPLSTR(psw);
+	qp = find_qband(q, band) ;			/* get qband struct */
+	for (mp = qp->qb_first; mp != NULL; )
+	{
+	    if (mp->b_band != band)
+	    {
+		printk("flushband: flushing band %d: mp->b_band=%d\n",
+			band, mp->b_band) ;
+		break ;			/* quit */
+	    }
+
+	    p_next = mp->b_next; 
+	    if (flag == FLUSHALL || lis_datamsg(mp->b_datap->db_type))
+	    {
+		lis_freemsg(rmv_msg(q,mp));
+	    }
+
+	    mp = p_next;
+	}
+	SPLX(psw) ;
+    }
+    else
+	lis_flushq(q, flag) ;
+
+}/*lis_flushband*/
+
+/*  -------------------------------------------------------------------  */
+/* lis_flushq - free messages from a queue, enabling upstream/downstream
+ *	service routines if applicable. The flag is the same as for
+ *	lis_flushband.
+ */
+void
+lis_flushq(queue_t *q, int flag)
+{
+    mblk_t *mp, *p_next;
+    int q_flag,psw;
+    struct qband *qp ;
+
+    if (q == NULL) return;
+    SPLSTR(psw);
+    q_flag = q->q_flag;
+    mp = q->q_first;
+    q->q_first = NULL;
+    q->q_last = NULL;
+    q->q_count = 0;
+    q->q_flag &= ~(QFULL|QWANTW);
+    SPLX(psw);
+
+    while (mp != NULL)
+    {
+    	p_next = mp->b_next; 
+	if (flag == FLUSHALL || lis_datamsg(mp->b_datap->db_type))
+	{
+	    LisDownCount(MSGSQD) ;		/* one fewer msg queued */
+	    lis_freemsg(mp);
+	}
+	else
+	    lis_putq(q, mp);
+	mp = p_next;
+    }
+
+    SPLSTR(psw);
+    for (qp = q->q_bandp; qp != NULL; qp = qp->qb_next)
+    {
+	qp->qb_first = NULL ;
+	qp->qb_last  = NULL ;
+    }
+    SPLX(psw);
+
+    SPLSTR(psw);
+    q->q_flag |= q_flag & QWANTW;
+    if (q->q_count <= q->q_lowat)	/* below low water?		*/
+	q->q_flag |= QBACK;		/* must back enable		*/
+    lis_backenable(q);
+    SPLX(psw);
+}/*lis_flushq*/
+
+/*  -------------------------------------------------------------------  */
+/* putctl - allocate a message block, set the type,
+ *	and put it on a queue. Returns 1 on success;
+ *	0 if the allocation failed or type is one of
+ *	M_DATA, M_PROTO or M_PCPROTO
+ */
+int
+lis_putctl(queue_t *q, int type)
+{
+    mblk_t *mp;
+    if (q == NULL ||
+       (type == M_DATA || type == M_PROTO || type == M_PCPROTO) ||
+       (q->q_qinfo == NULL || q->q_qinfo->qi_putp == NULL) ||
+       (mp = allocb(0, BPRI_HI)) == NULL)
+    	   return 0;
+    mp->b_datap->db_type = (uchar) type;
+    (*q->q_qinfo->qi_putp)(q, mp);
+    return 1;
+}/*lis_putctl*/
+
+/*  -------------------------------------------------------------------  */
+/* lis_putctl1 - as for lis_putctl, but with a one byte parameter
+ */
+int
+lis_putctl1(queue_t *q, int type, int param)
+{
+    mblk_t *mp;
+    if (q == NULL ||
+       (type == M_DATA || type == M_PROTO || type == M_PCPROTO) ||
+       (q->q_qinfo == NULL || q->q_qinfo->qi_putp == NULL) ||
+       (mp = allocb(1, BPRI_HI)) == NULL)
+    	   return 0;
+    mp->b_datap->db_type = (uchar) type;
+    *mp->b_wptr++ = (uchar) param;
+    (*(q->q_qinfo->qi_putp))(q, mp);
+    return 1;
+}/*lis_putctl1*/
+
+/*  -------------------------------------------------------------------  */
+/* lis_qsize - returns the number of messages on a queue
+ */
+int
+lis_qsize(queue_t *q)
+{
+    mblk_t *mp;
+    int rtn = 0, psw;
+    if (q == NULL) return 0;
+    SPLSTR(psw);
+    for (mp = q->q_first; mp; mp = mp->b_next)
+	rtn++;
+    SPLX(psw);
+    return rtn;
+}/*lis_qsize*/
+
+/*  -------------------------------------------------------------------  */
+/* lis_strqget - get information about a (band of a) queue.
+ *	Valid values for what are QHIWAT, QLOWAT, QMAXPSZ,
+ *	QMINPSZ, QCOUNT, QFIRST, QLAST, QFLAG.
+ *	Returns 0 on success.
+ */
+int 
+lis_strqget(queue_t *q, qfields_t what, unsigned char band, long *val)
+{
+    struct qband *qp ;
+    int		  psw;
+
+    if (q == NULL || val == NULL) return(EINVAL) ;
+
+    SPLSTR(psw);
+    if (band > 0)
+    {
+	qp = find_qband(q, band) ;			/* get qband struct */
+	if (qp == NULL)
+	{
+	    SPLX(psw) ;
+	    return(EINVAL);
+	}
+
+	switch (what)
+	{
+	case QHIWAT:
+	    *val = qp->qb_hiwat ;
+	    break ;
+	case QLOWAT:
+	    *val = qp->qb_lowat ;
+	    break ;
+	case QCOUNT:
+	    *val = qp->qb_count ;
+	    break ;
+	case QFIRST:
+	    *((mblk_t **)val) = qp->qb_first ;
+	    break ;
+	case QLAST:
+	    *((mblk_t **)val) = qp->qb_last ;
+	    break ;
+	case QFLAG:
+	    *val = qp->qb_flag ;
+	    break ;
+	default:
+	case QMAXPSZ:
+	case QMINPSZ:
+	    SPLX(psw) ;
+	    return(EINVAL) ;
+	}
+
+	SPLX(psw) ;
+	return(0) ;				/* success */
+    }
+
+    switch (what)
+    {
+    case QHIWAT:
+	*val = q->q_hiwat ;
+	break ;
+    case QLOWAT:
+	*val = q->q_lowat ;
+	break ;
+    case QMAXPSZ:
+	*val = q->q_maxpsz ;
+	break ;
+    case QMINPSZ:
+	*val = q->q_minpsz ;
+	break ;
+    case QCOUNT:
+	*val = q->q_count ;
+	break ;
+    case QFIRST:
+	*((mblk_t **)val) = q->q_first ;
+	break ;
+    case QLAST:
+	*((mblk_t **)val) = q->q_last ;
+	break ;
+    case QFLAG:
+	*val = q->q_flag ;
+	break ;
+    default:
+	SPLX(psw) ;
+	return(EINVAL) ;
+    }
+
+    SPLX(psw) ;
+    return(0);				/* return 0 for success */
+
+}/*lis_strqget*/
+
+/*  -------------------------------------------------------------------  */
+/* lis_strqset - change information about a (band of a) queue.
+ *	Valid values for what are QHIWAT, QLOWAT, QMAXPSZ,
+ *	QMINPSZ.
+ *	Returns 0 on success.
+ */
+int
+lis_strqset(queue_t *q, qfields_t what, unsigned char band, long val)
+{
+    struct qband *qp ;
+    int		  psw;
+
+    if (q == NULL) return(EINVAL) ;
+
+    SPLSTR(psw);
+    if (band > 0)
+    {
+	qp = find_qband(q, band) ;			/* get qband struct */
+	if (qp == NULL)
+	{
+	    SPLX(psw) ;
+	    return(EINVAL);
+	}
+
+	switch (what)
+	{
+	case QHIWAT:
+	    qp->qb_hiwat = val ;
+	    break ;
+	case QLOWAT:
+	    qp->qb_lowat = val ;
+	    break ;
+	case QCOUNT:
+	case QFIRST:
+	case QLAST:
+	case QFLAG:
+	    SPLX(psw) ;
+	    return(EPERM) ;
+	default:
+	case QMAXPSZ:
+	case QMINPSZ:
+	    SPLX(psw) ;
+	    return(EINVAL) ;
+	}
+
+	SPLX(psw) ;
+	return(0) ;				/* success */
+    }
+
+    switch (what)
+    {
+    case QHIWAT:
+	q->q_hiwat = val ;
+	break ;
+    case QLOWAT:
+	q->q_lowat = val ;
+	break ;
+    case QMAXPSZ:
+	q->q_maxpsz = val ;
+	break ;
+    case QMINPSZ:
+	q->q_minpsz = val ;
+	break ;
+    case QCOUNT:
+    case QFIRST:
+    case QLAST:
+    case QFLAG:
+	SPLX(psw) ;
+	return(EPERM) ;
+    default:
+	SPLX(psw) ;
+	return(EINVAL) ;
+    }
+
+    SPLX(psw) ;
+    return(0);				/* return 0 for success */
+
+}/*lis_strqset*/
+
+
+/*  -------------------------------------------------------------------  */
+/* Allocate a new NULL-initilized queue pair
+ * return NULL on failure
+ */
+queue_t *
+lis_allocq( const char *name )
+{
+  queue_t *q = (queue_t*)ALLOC(sizeof(queue_t)*2);
+
+  if (q == NULL) return(NULL) ;		/* memset does not null-check */
+
+  LisUpCount(QUEUES) ;			/* one more queue */
+  memset((void*)q,0,2*sizeof(queue_t));
+  lis_mark_mem(q, name, MEM_QUEUE) ;	/* mark memory w/queue name */
+  q->q_flag = QREADR | QUSE ;		/* read side of queue */
+  LIS_WR(q)->q_flag = QUSE ;		/* queue in use */
+  return(q);
+}/*lis_allocq*/
+
+/*  -------------------------------------------------------------------  */
+/* Deallocate a new queue pair
+ * return NULL on failure
+ */
+void
+lis_freeq( queue_t *q )
+{
+    struct qband *qp ;
+    struct qband *qpx ;
+    int psw;
+    int i ;
+
+    SPLSTR(psw);
+    q = LIS_RD(q) ;
+    for (i = 1; i <= 2; i++, q = LIS_WR(q))
+    {
+	for (qp = q->q_bandp; qp != NULL; )
+	{
+	    qpx = qp->qb_next ;
+	    FREE(qp) ;
+	    qp = qpx ;
+	}
+    }
+
+    FREE(LIS_RD(q));
+    LisDownCount(QUEUES) ;			/* one fewer queue */
+    SPLX(psw) ;
+
+}/*lis_freeq*/
+
+/*  -------------------------------------------------------------------  */
+/* Insert mp2 after mp1
+ * This is the same as inserting mp2 just in front of the next
+ * message after mp1.
+ */
+void
+lis_appq(queue_t *q, mblk_t *mp1, mblk_t *mp2)
+{
+    if (mp1 == NULL || mp2 == NULL || q == NULL)
+      return;
+
+    lis_insq(q, mp1->b_next, mp2) ;
+
+}/*lis_appq*/
+
+
+/*  -------------------------------------------------------------------  */
+/* lis_bcanput - search the stream starting from q until a service
+ *	routine is found, if any, and test the found queue for
+ *	flow control at a specified band. Schedule backenabling
+ *	if flow controlled.
+ *	For band==0 this is equivalent to canput. Returns 0 if
+ *	flow controlled; 1 otherwise.
+ */
+int 
+lis_bcanput(queue_t *q, unsigned char band)
+{
+    int		  psw;
+    struct qband *qp ;
+
+    if (q == NULL) return 0; /* sanity check */
+
+    SPLSTR(psw);
+
+    /* search the stream for the next module with a service
+       procedure, and check its high water mark */
+    while (q->q_next != NULL && q->q_qinfo->qi_srvp == NULL)
+	    q = q->q_next;
+    /* if the queue is flow controlled, set the QWANTW flag */
+    if (band > 0)
+    {
+	qp = find_qband(q, band) ;			/* get qband struct */
+	if (qp == NULL)
+	{
+	    LisUpFailCount(CANPUTS) ;
+	    SPLX(psw) ;
+	    return(0);
+	}
+	if (qp->qb_flag & QB_FULL)
+	{
+	    qp->qb_flag |= QB_WANTW ;
+	    LisUpFailCount(CANPUTS) ;
+	    SPLX(psw) ;
+	    return 0;
+	}
+    }
+    else
+    if (q->q_flag & QFULL)
+    {
+    	q->q_flag |= QWANTW;
+	LisUpFailCount(CANPUTS) ;
+	SPLX(psw) ;
+	return 0;
+    }
+
+    LisUpCount(CANPUTS) ;
+    SPLX(psw) ;
+    return 1;
+
+}/*lis_bcanput*/
+
+/*  -------------------------------------------------------------------  */
+/* lis_bcanputnext - search the stream starting from the queue after q
+ * 	until a service	routine is found.  Uses lis_bcanput().
+ *
+ *	This routine shows up in AT&T's MP spec for SVR4.
+ */
+int 
+lis_bcanputnext(queue_t *q, unsigned char band)
+{
+    return(lis_bcanput(q->q_next, band)) ; /* check the next queue */
+
+}/*lis_bcanputnext*/
+
+/*  -------------------------------------------------------------------  */
+/* lis_bcanputnext_anyband - search the stream starting from q->q_next
+ *	until a service	routine is found, if any, and test the found queue
+ *	for flow control on any non-zero band.  This is for the S_WRBAND
+ *	option processing.
+ *
+ *	Note, in particular, that we do not return the band number of
+ *	the band with available space in it.  This actually sounds
+ *	pretty useless to me.  -- DMG
+ */
+int 
+lis_bcanputnext_anyband(queue_t *q)
+{
+    int		  psw;
+    struct qband *qp ;
+
+    if (q == NULL || (q = q->q_next) == NULL) return 0; /* sanity check */
+
+    SPLSTR(psw);
+
+    /* search the stream for the next module with a service procedure */
+    while (q->q_next != NULL && q->q_qinfo->qi_srvp == NULL)
+	    q = q->q_next;
+
+    /* Find any qband that has room in it */
+    /* We even accept non-in-use qband structures, is that correct?  */
+    for (qp = q->q_bandp; qp != NULL; qp = qp->qb_next)
+    {
+	if (!(qp->qb_flag & QB_FULL))
+	    break ;
+    }
+
+    if (qp == NULL)
+    {
+        LisUpFailCount(CANPUTS) ;
+	SPLX(psw) ;
+	return(0);
+    }
+
+    LisUpCount(CANPUTS) ;
+    SPLX(psw) ;
+    return 1;
+
+}/*lis_bcanputnext_anyband*/
+
+/*  -------------------------------------------------------------------  */
+/*  lis_qcountstrm
+ *
+ * Return the q_qcount field from the next queue.
+ */
+int	lis_qcountstrm(queue_t *q)
+{
+    int		psw;
+    int		nbytes = 0 ;
+
+    SPLSTR(psw);
+    while (q != NULL)
+    {
+	q->q_flag |= QCLOSING ;		/* mark the queue as closing */
+	nbytes += q->q_count ;
+	q = q->q_next ;
+    }
+
+    SPLX(psw) ;
+    return(nbytes) ;
+
+} /* lis_qcountstrm */
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/safe.c /usr/src/linux/drivers/streams/LiS/head/safe.c
--- debug/drivers/streams/LiS/head/safe.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/safe.c	Wed Jan  1 14:13:04 1997
@@ -0,0 +1,186 @@
+/*                               -*- Mode: C -*- 
+ * safe.c --- stream safe
+ * Author          : Graham Wheeler
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: safe.c,v 1.4 1996/01/20 17:02:56 dave Exp $
+ * Purpose         : stream safe processing stuff
+ * ----------------______________________________________________
+ *
+ *  Copyright (C) 1995  Graham Wheeler
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach me by email to
+ *    gram@aztec.co.za
+ *    dave@gcom.com
+ */
+
+
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#include <sys/stream.h>
+
+
+/*  -------------------------------------------------------------------  */
+/*				  Glob. Vars                             */
+
+/*  -------------------------------------------------------------------  */
+/*			   Local functions & macros                      */
+
+#define	LOG(fil, line, msg)	printk("%s: called from file %s #%d\n",  \
+					msg, fil, line)
+
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+
+
+void safe_noenable(queue_t *q, char *f, int l)
+{
+    if (q == NULL) LOG(f, l, "NULL q in noenable");
+    else q->q_flag |= QNOENB;
+}
+
+void safe_enableok(queue_t *q, char *f, int l)
+{
+    if (q == NULL) LOG(f, l, "NULL q in enableok");
+    else q->q_flag &= ~QNOENB;
+}
+
+int safe_canenable(queue_t *q, char *f, int l)
+{
+    if (q == NULL) LOG(f, l, "NULL q in canenable");
+    else return !(q->q_flag & QNOENB);
+    return 0;
+}
+
+queue_t *safe_OTHERQ(queue_t *q, char *f, int l)
+{
+    if (q == NULL) LOG(f, l, "NULL q in OTHERQ");
+    else return (q->q_flag&QREADR) ? (q+1) : (q-1);
+    return NULL;
+}
+
+queue_t *safe_RD(queue_t *q, char *f, int l)
+{
+    if (q == NULL) LOG(f, l, "NULL q in RD");
+    else return (q->q_flag&QREADR) ? q : (q-1);
+    return NULL;
+}
+
+queue_t *safe_WR(queue_t *q, char *f, int l)
+{
+    if (q == NULL) LOG(f, l, "NULL q in WR");
+    else return (q->q_flag&QREADR) ? (q+1) : q;
+    return NULL;
+}
+
+int safe_SAMESTR(queue_t *q, char *f, int l)
+{
+    if (q == NULL) LOG(f, l, "NULL q in SAMESTR");
+    else return (q->q_next!=NULL && (q->q_flag&QREADR) == (q->q_next->q_flag&QREADR));
+    return 0;
+}
+
+void safe_putnext(queue_t *q, mblk_t *mp, char *f, int l)
+{
+    if (LIS_DEBUG_SAFE)
+    {
+	if (mp == NULL)
+	{
+	    LOG(f, l, "NULL msg in putnext");
+	    return ;
+	}
+
+	if (q == NULL)
+	{
+	    LOG(f, l, "NULL q in putnext");
+	    freemsg(mp) ;
+	    return ;
+	}
+
+	if (q->q_next == NULL
+	    || q->q_next->q_qinfo == NULL
+	    || q->q_next->q_qinfo->qi_putp == NULL
+	   )
+        {
+	    LOG(f, l, "NULL q_next, q_qinfo or qi_putp in putnext");
+	    freemsg(mp) ;
+	    return ;
+        }
+    }
+
+    if (LIS_DEBUG_TRCE_MSG)
+	lis_mark_mem(mp, lis_queue_name(q->q_next), MEM_MSG) ;
+
+    if (LIS_DEBUG_PUTNEXT)
+    {
+	printk("putnext: %s from \"%s\" to \"%s\" size %d\n",
+			    lis_msg_type_name(mp),
+			    lis_queue_name(q), lis_queue_name(q->q_next),
+			    lis_msgsize(mp)
+	      ) ;
+
+	if (LIS_DEBUG_ADDRS)
+	    printk("        q=%lx, mp=%lx, mp->b_rptr=%lx, wptr=%lx\n",
+		   (long) q, (long) mp, (long) mp->b_rptr, (long) mp->b_wptr);
+    }
+
+    (*(q->q_next->q_qinfo->qi_putp))(q->q_next, mp);
+}
+
+void safe_qreply(queue_t *q, mblk_t *mp, char *f, int l)
+{
+    if (LIS_DEBUG_SAFE)
+    {
+	if (mp == NULL)
+	{
+	    LOG(f, l, "NULL msg in qreply");
+	    return ;
+	}
+
+	if (q == NULL)
+	{
+	    LOG(f, l, "NULL q in qreply");
+	    freemsg(mp) ;
+	    return ;
+	}
+
+	if ((q = LIS_OTHERQ(q)) == NULL)
+	{
+	    LOG(f, l, "NULL OTHERQ(q) in qreply");
+	    freemsg(mp) ;
+	    return ;
+	}
+
+	putnext(q, mp);
+    }
+    else
+    {
+	putnext(LIS_OTHERQ(q), mp) ;
+    }
+}
+
+
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/slog.c /usr/src/linux/drivers/streams/LiS/head/slog.c
--- debug/drivers/streams/LiS/head/slog.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/slog.c	Wed Jan  1 14:13:05 1997
@@ -0,0 +1,69 @@
+#ifdef ANSI
+#include <stdarg.h>
+#else
+# ifdef USE_VARARGS
+# include <varargs.h>
+# endif
+#endif
+
+#include <sys/stream.h>
+#include <sys/cmn_err.h>
+
+#ifndef NULL
+#define NULL		( (void *) 0 )
+#endif
+
+extern       char                    *lis_strm_print_trace_buf;
+
+/************************************************************************
+*                            lis_strm_trace                             *
+*************************************************************************
+*									*
+* printf to the debug/testing output "device".  The tracing may be 	*
+* disabled on installed systems.  This is not a logging mechanism or	*
+* audit trail since the traced events may not be recorded anywhere.	*
+*									*
+* If you want print trace printout to be compatible with the token	*
+* printer, your fmt should begin (not end) with a newline (\n).		*
+*									*
+************************************************************************/
+void
+lis_strm_trace(char *fmt, ...)
+{
+	va_list		arg_ptr ;
+
+	if (lis_print_trace == (lis_print_trace_t) 0)
+	    return;
+
+	va_start(arg_ptr, fmt) ;
+	vsprintf(lis_strm_print_trace_buf, fmt, arg_ptr) ;
+	va_end(arg_ptr) ;
+
+	(*lis_print_trace) (lis_strm_print_trace_buf);
+
+} /* lis_strm_trace */
+
+/************************************************************************
+*                          lis_strm_log                                 *
+*************************************************************************
+*									*
+* The intent of this routine is to be used to log events that would	*
+* likely be of interest to an administrator.				*
+*									*
+************************************************************************/
+void
+lis_strm_log(int log_level, char *fmt, ...)
+{
+	va_list		arg_ptr ;
+
+	if (lis_print_trace == (lis_print_trace_t) 0)
+	    return;
+
+	va_start(arg_ptr, fmt) ;
+	vsprintf(lis_strm_print_trace_buf, fmt, arg_ptr) ;
+	va_end(arg_ptr) ;
+
+	(*lis_print_trace) (lis_strm_print_trace_buf);
+
+} /* lis_strm_log */
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/sputbuf.c /usr/src/linux/drivers/streams/LiS/head/sputbuf.c
--- debug/drivers/streams/LiS/head/sputbuf.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/sputbuf.c	Wed Jan  1 14:13:04 1997
@@ -0,0 +1,208 @@
+/************************************************************************
+*									*
+*                          Rsystem Putbuf                               *
+*									*
+*************************************************************************
+*									*
+*		    (C) Copyright 1995 Gcom, Inc   		      	*
+*									*
+*************************************************************************
+*									*
+* This file contains the code for the Rsystem "putbuf" mechanism.	*
+* This mechanism is a way of capturing debug print strings in a buffer	*
+* and delivering the data to the user for printing or logging.		*
+*									*
+************************************************************************/
+
+#ident "@(#) sputbuf.c 1.2 12/3/95"
+
+#include <sys/stream.h>
+#include <sys/cmn_err.h>
+
+/************************************************************************
+*                      Storage Declarations                             *
+************************************************************************/
+
+static char		*lis_strm_in ;		/* in pointer */
+static char		*lis_strm_out ;		/* out pointer */
+static char		*lis_strm_buf ;		/* pointer to buffer */
+static char		*lis_strm_end ;		/* pointer to one off end of bfr */
+static long		 lis_strm_size ;	/* putbuf size */
+static long		 lis_strm_max_bytes ;	/* max bytes in buffer */
+
+struct semaphore p_sem;
+
+
+#define	USER_BUF	1		/* user's buffer */
+
+#ifndef NULL
+#define NULL		( (void *) 0 )
+#endif
+
+char         lis_strm_print_trace_buf[1024];
+
+
+/************************************************************************
+*                       lis_strm_print_trace                            *
+*************************************************************************
+*									*
+* This routine is suitable for use as an Rsys_print_trace function.	*
+*									*
+* The technique is to put characters into the putbuf until the input	*
+* pointer catches the output pointer.  If the input pointer catches	*
+* the output pointer then we increment the output pointer so that	*
+* the buffer appears to hold the most recent lis_strm_size entries.	*
+*									*
+* This routine may be called from interrupt routines.  It is assumed	*
+* that its execution may interrupt the execution of the lis_strm_readbuf*
+* routine below but not vice versa.					*
+*									*
+************************************************************************/
+void	lis_strm_print_trace(char *msg)
+{
+    char	c ;
+    if (lis_strm_in == NULL)
+    {
+	return ;	/* cheap insurance */
+    }
+
+    lis_down(&p_sem);
+
+    while ( (c = *msg++) != 0 )
+    {
+	if ( (c >= ' ' && c < 0x7F ) || c == '\n' )
+	    *lis_strm_in++ = c ;		/* char to buffer */
+	else
+	    continue;
+
+	if (lis_strm_in == lis_strm_end)  /* need to wrap around in ptr?  */
+	    lis_strm_in = lis_strm_buf ;  /* wrap lis_strm_in to start of bfr */
+
+	if (   lis_strm_in == lis_strm_out	/* buffer full */
+	    && ++lis_strm_out == lis_strm_end	/* lis_strm_out need to wrap */
+	   )
+	    lis_strm_out = lis_strm_buf ;	/* wrap lis_strm_out to start of bfr */
+    }
+
+    lis_up(&p_sem);
+
+} /* lis_strm_print_trace */
+
+/************************************************************************
+*                           lis_strm_putc                               *
+*************************************************************************
+*									*
+* This routine can be called by Gputc to funnel that character stream	*
+* into the putbuf mechanism.						*
+*									*
+************************************************************************/
+void	lis_strm_putc(char c)
+{
+    char	chrs[2] ;
+
+    chrs[0] = c ;			/* make a one-char string */
+    chrs[1] = 0 ;
+
+    lis_strm_print_trace(chrs) ;		/* funnel through putbuf */
+
+} /* lis_strm_putc */
+
+/************************************************************************
+*                          lis_strm_readbuf                             *
+*************************************************************************
+*									*
+* Read characters out of the putbuf into the user's data area.		*
+*									*
+* This routine could be interrupted by the execution of the		*
+* lis_strm_print trace routine.  Therefore, we protect this routine     *
+* with interrupt enables and disables.					*
+*									*
+* Return the number of bytes transferred.				*
+*									*
+************************************************************************/
+long	lis_strm_readbuf(char *usr_ptr, long max_bytes)
+{
+    int 	psw ;
+    long	bytes_in_bfr ;
+    long	bytes_to_end ;
+    long	bytes_from_front ;
+    static	total_bytes;
+
+    if (lis_strm_size <= 0 || lis_strm_in == NULL || lis_strm_out == NULL)
+    {
+	return(0) ;
+    }
+
+    SPLSTR(psw);
+    bytes_in_bfr = (lis_strm_size + (lis_strm_in - lis_strm_out)) % lis_strm_size ;
+
+    if (bytes_in_bfr > lis_strm_max_bytes)		/* keep running max */
+	lis_strm_max_bytes = bytes_in_bfr ;
+
+    if (max_bytes > bytes_in_bfr)		/* we will xfer max_bytes */
+	max_bytes = bytes_in_bfr ;
+
+    bytes_to_end = lis_strm_end - lis_strm_out ;/* bytes to end of buffer */
+
+    if (bytes_to_end > max_bytes)	/* won't get to end of bfr */
+	bytes_to_end = max_bytes ;	/* take it all in one segment */
+
+    lis_copyout(0, lis_strm_out, usr_ptr, bytes_to_end) ;/* move to user's buffer */
+    lis_strm_out += bytes_to_end ;	/* advance lis_strm_out towards end */
+
+    bytes_from_front = max_bytes - bytes_to_end ;	/* wrap around?  */
+
+    if (bytes_from_front > 0)
+    {						/* move from front of bfr */
+	lis_copyout(0, lis_strm_buf, usr_ptr + bytes_to_end, bytes_from_front) ;
+	lis_strm_out = lis_strm_buf + bytes_from_front ; /* set lis_strm_out */
+    }
+
+    SPLX(psw) ;
+total_bytes += max_bytes;
+    return(max_bytes) ;
+
+} /* lis_strm_reabuf */
+
+/************************************************************************
+*                          lis_strm_init                                *
+*************************************************************************
+*									*
+* Initialize putbuf mechanism.						*
+*									*
+************************************************************************/
+int	lis_strm_init(char *bfr, long	size)
+{
+
+    lis_strm_size = 0 ;			/* putbuf size */
+    lis_strm_in = NULL ;		/* in pointer */
+    lis_strm_out = NULL ;		/* out pointer */
+    lis_strm_end = NULL ;		/* pointer to one off end of bfr */
+
+    if (size <= 0) return(-1) ;		/* de-initialize */
+
+    if (bfr == NULL)
+    {
+	return(-1);
+    }
+    else
+    {
+	lis_strm_buf = bfr ;
+    }
+
+    SEM_INIT(&p_sem, 1) ;
+
+
+    lis_strm_size = size ;			/* putbuf size */
+    lis_strm_in = lis_strm_buf ;		/* in pointer */
+    lis_strm_out = lis_strm_buf ;		/* out pointer */
+    lis_strm_end = lis_strm_buf + lis_strm_size ;/* pointer to one off end of bfr */
+
+    if ( lis_print_trace == NULL )
+    {
+        lis_print_trace = lis_strm_print_trace ;
+    }
+    
+    return(0) ;
+
+} /* lis_strm_init */
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/stats.c /usr/src/linux/drivers/streams/LiS/head/stats.c
--- debug/drivers/streams/LiS/head/stats.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/stats.c	Wed Jan  1 14:13:04 1997
@@ -0,0 +1,128 @@
+/*                               -*- Mode: C -*- 
+ * stats.c --- streams statistics
+ * Author          : Graham Wheeler
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: stats.c,v 1.1 1995/12/19 15:50:04 dave Exp $
+ * Purpose         : provide some stats for LiS
+ * ----------------______________________________________________
+ *
+ *   Copyright (C) 1995  Graham Wheeler
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach me by email to
+ *    gram@aztec.co.za
+ */
+
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#include <sys/strport.h>
+#include <sys/strconfig.h>	/* config definitions */
+#include <sys/LiS/share.h>	/* streams shared defs*/
+#include <sys/LiS/stats.h>	/* module interface */
+
+/*  -------------------------------------------------------------------  */
+/*			   Local functions & macros                      */
+
+/*  -------------------------------------------------------------------  */
+/*				  Glob. Vars                             */
+
+/* This are the stats 
+ */
+unsigned long lis_strstats[STRMAXSTAT][4] ;
+
+/* If in user mode, include a stats dump routine 
+ */
+#ifdef MEMPRINT
+
+itemname_t lis_itemnames[] =
+{
+    {MEMALLOCS,		MEMALLOCSSTR},
+    {MEMFREES,		MEMFREESSSTR},
+    {MEMALLOCD,		MEMALLOCDSTR},
+    {MEMLIM,		MEMLIMSTR},
+    {HEADERS,		HEADERSSTR},
+    {FREEHDRS,		FREEHDRSSTR},
+    {DATABS,		DATABSSTR},
+    {DBLKMEM,		DBLKMEMSTR},
+    {MSGMEMLIM,		MSGMEMLIMSTR},
+    {BUFCALLS,		BUFCALLSSTR},
+    {MSGSQD,		MSGSQDSTR},
+    {MSGQDSTRHD,	MSGQDSTRHDSTR},
+    {CANPUTS,		CANPUTSSTR},
+    {QUEUES,		QUEUESSTR},
+    {QSCHEDS,		QSCHEDSSTR}
+};
+char *lis_countnames[] =
+{
+    CURRENTSTR, TOTALSTR, MAXIMUMSTR, FAILURESSTR
+};
+#endif
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+/* increment count for one item
+ * STATUS: complete, untested
+ */
+void 
+LisUpCounter(int item, int n)
+{
+    lis_strstats[item][TOTAL] += n;
+    lis_strstats[item][CURRENT] += n;
+    if (lis_strstats[item][CURRENT] > lis_strstats[item][MAXIMUM])
+	lis_strstats[item][MAXIMUM] = lis_strstats[item][CURRENT];
+}/*LisUpCounter*/
+
+/*  -------------------------------------------------------------------  */
+/* If in USER mode, include a stats dump routine 
+ */
+#ifdef MEMPRINT
+void
+LisShowStrStats(unsigned long (*strstats)[STRMAXSTAT][4])
+{
+    int i;
+    int inx;
+
+    /* Print heading */
+    printf("%-28s  ", "");
+    for (i = 0; i < 4; i++)
+	printf("%12s", lis_countnames[i]) ;
+    printf("\n");
+
+    /* Print statistics */
+    for (i = 0; i < STRMAXSTAT; i++)
+    {
+	int j;
+
+	if (lis_itemnames[i].name == NULL) continue ;
+
+	inx = lis_itemnames[i].stats_inx ;
+	printf("%-28s: ", lis_itemnames[i].name);
+	for (j = 0; j < 4; j++)
+	    printf("%12lu", (*strstats)[inx][j]);
+	printf("\n");
+    }
+}/*LisShowStrStats*/
+#endif /* MEMPRINT */
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/strconf.c /usr/src/linux/drivers/streams/LiS/head/strconf.c
--- debug/drivers/streams/LiS/head/strconf.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/strconf.c	Mon Dec 16 16:36:38 1996
@@ -0,0 +1,1372 @@
+/************************************************************************
+*                       STREAMS Configuration                           *
+*************************************************************************
+*									*
+* This program processes an ASCII configuration file and builds the	*
+* modconf.c file containing basic configuration entries for each	*
+* STREAMS driver or module.						*
+*									*
+* The syntax of the config file is as follows:				*
+*									*
+* Lines beginning with '#' are comments.				*
+* Blank lines are ignored.						*
+*									*
+* Each significant line is introduced by a keyword which describes	*
+* the type of entry it is and determines the syntax of the rest		*
+* of the line.								*
+*									*
+*									*
+* Driver specification:							*
+*									*
+*	driver	<driver-name> <prefix> <major>	<minors>		*
+*									*
+* The keyword "driver" introduces this entry.				*
+*									*
+* <driver-name> is the name of the driver, for example loop-around.	*
+* It is any string of characters not including "white space" chars.	*
+*									*
+* <prefix> is alphanumeric, plus underscore, and will be prefixed	*
+* to any table entries referencing variables within this driver.	*
+* For example, the prefix loop_ will be used to derive the reference	*
+* to the streamtab entry loop_info.  The driver must have a variable	*
+* declared within it by the name <prefix>info of type struct streamtab.	*
+*									*
+* <major> specifies the major device number that will be assigned to	*
+* the device.  The character "*" means that the config program will	*
+* choose the major number.  A numeric value is used as it is given.	*
+*									*
+* <minors> is the number of minors the device has.  If this field is	*
+* omitted, the number 1 will be used.					*
+*									*
+* Example:								*
+*									*
+*	driver loop-around loop_ *					*
+*									*
+*									*
+* Module specification:							*
+*									*
+*	module	<name> <prefix>						*
+*									*
+* The keyword "module" introduces this entry.				*
+*									*
+* <name> is the name of the module, for example relay-mod.		*
+* It is any string of characters not including "white space" chars.	*
+*									*
+* <prefix> is alphanumeric, plus underscore, and will be prefixed	*
+* to any table entries referencing variables within this module.	*
+* For example, the prefix relay_ will be used to derive the reference	*
+* to the streamtab entry relay_info.  The module must have a variable	*
+* declared within it by the name <prefix>info of type struct streamtab.	*
+*									*
+* Example:								*
+*									*
+*	module relay-mod relay_						*
+*									*
+*									*
+* Node specification:							*
+*									*
+*	node	<dev-name> <type> <perm> <major> <minor>		*
+*									*
+* The keyword "node" introduces this entry.				*
+*									*
+* <dev-name> is the full path name of the device file to be created,	*
+* for example, /dev/loop.						*
+*									*
+* <type> is the type of file to create. This consists of a single	*
+* letter as follows:							*
+*									*
+*	b	block special device (S_IFBLK)				*
+*	c	character special device (S_IFCHR)			*
+*	p	pipe device (S_IFIFO)					*
+*									*
+* <perm> is the device permissions to use, 0666 gives everyone		*
+* permission to use the device.  <perm> can be "*" in which case	*
+* default permissions are supplied.					*
+*									*
+* <major> is the major device number to assign to this entry.  It can	*
+* be a number, but is usually the <name> of the associated driver	*
+* entry.  The major specified for the driver is then used.		*
+*									*
+* <minor> is the minor device number to assign to this entry.  It can	*
+* be a number or the name of another driver.  If the name form is used	*
+* then the major number of the other driver is used as the minor number	*
+* of the device being created.						*
+*									*
+* Example:								*
+*									*
+*	node /dev/loop 		c * loop-around 1			*
+*	node /dev/loop_clone	c * clone	loop-around		*
+*									*
+*									*
+* Device specifications:						*
+*									*
+* These entries are used to describe the configuration of each		*
+* physical device or port of a multi-port device on the system.		*
+* The syntax for this type of entry is as follow:			*
+*									*
+*	device <driver-name> <unit> <port> <nports> <irq-share> <irq>	*
+*			     <mem> <mem-size> <dma1> <dma2>		*
+*									*
+* All 11 fields must be on the same line.				*
+*									*
+* <driver-name> is the name of the driver that handles the device.	*
+* It must match the name of a declared driver in this file.		*
+*									*
+* <unit> is the unit number of the device being declared.  A unit	*
+* number means anything that the driver writer wants it to.  It is	*
+* assumed to be a small integer that will index a configuration table	*
+* that is built from #defines generated by running this program.	*
+*									*
+* <port> is the I/O port that the device uses.  Set to -1 if the	*
+* device does not use any I/O ports.					*
+*									*
+* <nports> is the number of consecutive I/O ports used by the driver.	*
+* If <ports> is -1 then <nports> can be any value, zero is suggested.	*
+*									*
+* <irq-share> is a letter-coded field as follows:			*
+*									*
+*	n	No sharing of IRQ					*
+*	s	Sharing of IRQ						*
+*	S	Sharing of IRQ but only with the same driver		*
+*	x	Don't care, the device does not use an IRQ		*
+*									*
+* <irq> is the interrupt number for the device.  The value -1 is used	*
+* when the device does not have an interrupt.  If this value is		*
+* specified then it is assumed that there exists a routine with 	*
+* the name <prefix>intr, where <prefix> is the driver prefix specified	*
+* in the driver section.						*
+*									*
+* <mem> is the shared-memory address used by this device, if any.	*
+* Set to 0 if the device does not use shared memory.			*
+*									*
+* <mem-size> is the amount of shared memory used, in bytes.		*
+*									*
+* <dma1> and <dma2> specify up to two DMA channels used by this		*
+* device.  Set to -1 if no DMA channels are being used.			*
+*									*
+* The device entry causes a set of #defines to be generated into	*
+* the file config.h.  This file may be #included into a driver		*
+* configuration file to load tables, etc.				*
+*									*
+*									*
+* Tunable Parameter Specification:					*
+*									*
+* This type of entry allows you to insert define text into the		*
+* output file (config.h default).  These values can be used as		*
+* parameters for drivers or the streams package itself.			*
+*									*
+* The syntax is:							*
+*									*
+*	define <name> <value>						*
+*									*
+* The <name> is the identifier that is being defined.  It must be	*
+* constructed of characters that comprise a legal C language		*
+* identifier.								*
+*									*
+* The <value> is any text up to the end of the line.			*
+*									*
+* The output for this entry is of the form:				*
+*									*
+*	#define <name> <value>						*
+*									*
+* Example:								*
+*									*
+*	define	MAX_PORTS	16					*
+*									*
+* Generates the following in the output file:				*
+*									*
+*	#define	MAX_PORTS	16					*
+*									*
+* Command line syntax:							*
+*									*
+*	strconf <options> <input-file>					*
+*									*
+* <options>								*
+*									*
+* -b<number>	Set the base major number for automatic assignment	*
+*		of major device numbers.				*
+*									*
+* -h<file>	Set the output header file name to something other than	*
+*		the default "config.h".					*
+*									*
+* -o<file>	Set the output file name rather than the default	*
+*		name "modconf.c".  This is the file that must be	*
+*		linked in with STREAMS.					*
+*									*
+* -m<file>	Set the output file name for the program that will	*
+*		make the nodes to something other than "makenodes.c".	*
+*		This program is compiled and then run at boot time	*
+* 		to create all the /dev entries for the STREAMS drivers.	*
+*									*
+* -M<name>	The name of the mknod() routine to call.  The default	*
+*		is "mknod".						*
+*									*
+* -p<perm>	Set default permissions to something other than 0666.	*
+*									*
+* -r<name>	The name of the routine to build in makenodes.c.	*
+*		The default is "main".					*
+*									*
+*									*
+* Author:	David Grothe <dave@gcom.com>				*
+*									*
+************************************************************************/
+
+#include <sys/stat.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <stdarg.h>
+#include <malloc.h>
+#include <stdlib.h>
+#ifdef QNX
+#include <mem.h>
+#else
+#include <memory.h>
+#include <string.h>
+#endif
+
+
+
+
+/************************************************************************
+*                          Data Structures                              *
+************************************************************************/
+
+typedef struct di
+{
+    struct di	*link ;
+    char	 name[50] ;
+    char	 prefix[50] ;
+    int		 major;
+    int		 nminors ;
+
+} driver_info_t ;
+
+typedef struct mi
+{
+    struct mi	*link ;
+    char	 name[50] ;
+    char	 prefix[50] ;
+
+} module_info_t ;
+
+typedef struct ni
+{
+    struct ni	*link ;
+    char	 name[100] ;
+    int		 type ;			/* I_IFCHR, etc */
+    int		 major;
+    int		 minor ;
+
+} node_info_t ;
+
+typedef struct vi
+{
+    struct vi		*link ;
+    char		 name[50] ;
+    driver_info_t	*drvr ;
+    int			 unit ;
+    long		 port ;
+    int			 nports ;
+    int			 irq_share ;
+    int			 irq ;
+    long		 mem ;
+    long		 mem_size ;
+    int			 dma1 ;
+    int			 dma2 ;
+
+} device_info_t ;
+
+#define	IRQ_SHARE_DC	0		/* x */
+#define	IRQ_NO_SHARE	1		/* n */
+#define	IRQ_SHARE	2		/* s */
+#define	IRQ_SHARE_DEV	3		/* S */
+
+typedef struct lk
+{
+    struct lk	*link ;
+    char	 name[100] ;
+
+} lookup_struct_t ;
+
+
+/************************************************************************
+*                         Storage Declarations                          *
+************************************************************************/
+
+int		next_major = 50 ;	/* larger than dedicated majors */
+
+driver_info_t	*driver_head ;
+module_info_t	*module_head ;
+node_info_t	*node_head ;
+device_info_t	*device_head ;
+int		 ndevices ;
+
+char		*outfile_name = "modconf.c" ;
+char		*mkfile_name  = "makenodes.c" ;
+char		*mknod_name   = "mknod" ;
+char		*func_name    = "main" ;
+char		*infile_name ;
+char		*config_name  = "config.h" ;
+
+FILE		*infile ;
+FILE		*outfile ;
+FILE		*mkfile ;
+FILE		*configfile ;
+
+char		 inbuf[600] ;
+int		 line_nr ;
+char		*nextp ;			/* nxt chr in buffer */
+char		 token[200] ;			/* current input token */
+long		 value ;			/* converted integer */
+int		 class ;			/* token classification */
+#define	NUMBER	1				/* numeric (converted) */
+#define	IDENT	2				/* identifier */
+#define	EOL	3				/* end of line */
+
+int		 dflt_perm = 0666 ;		/* default permissions */
+
+/************************************************************************
+*                            link_on_end                                *
+*************************************************************************
+*									*
+* link item onto the end of the list whose head is pointed to by 'head'	*
+*									*
+************************************************************************/
+void	link_on_end(lookup_struct_t **head, lookup_struct_t *item)
+{
+    lookup_struct_t	*p ;
+
+    item->link = NULL ;
+    if (*head == NULL)
+    {
+	*head = item ;
+	return ;
+    }
+
+    for (p = *head; p->link != NULL; p = p->link) ;
+
+    p->link = item ;
+
+} /* link_on_end */
+
+/************************************************************************
+*                           mk_driver                                   *
+*************************************************************************
+*									*
+* Make an entry for a driver.						*
+*									*
+************************************************************************/
+driver_info_t	*mk_driver(char *name, char *prefix, int maj, int nmin)
+{
+    driver_info_t	*p ;
+
+    p = (driver_info_t *) malloc(sizeof(*p)) ;
+    if (p == NULL)
+    {
+	fprintf(stderr, "Cannot allocate entry for \"%s\"\n", name) ;
+	exit(1) ;
+    }
+
+    strncpy(p->name, name, sizeof(p->name)) ;
+    strncpy(p->prefix, prefix, sizeof(p->prefix)) ;
+    p->major = maj ;
+    p->nminors = nmin ;
+
+    link_on_end((lookup_struct_t **) &driver_head, (lookup_struct_t *) p) ;
+
+    return(p) ;
+
+} /* mk_driver */
+
+/************************************************************************
+*                           mk_module                                   *
+*************************************************************************
+*									*
+* Make an entry for a module.						*
+*									*
+************************************************************************/
+module_info_t	*mk_module(char *name, char *prefix)
+{
+    module_info_t	*p ;
+
+    p = (module_info_t *) malloc(sizeof(*p)) ;
+    if (p == NULL)
+    {
+	fprintf(stderr, "Cannot allocate entry for \"%s\"\n", name) ;
+	exit(1) ;
+    }
+
+    strncpy(p->name, name, sizeof(p->name)) ;
+    strncpy(p->prefix, prefix, sizeof(p->prefix)) ;
+
+    link_on_end((lookup_struct_t **) &module_head, (lookup_struct_t *) p) ;
+
+    return(p) ;
+
+} /* mk_module */
+
+/************************************************************************
+*                             mk_node                                   *
+*************************************************************************
+*									*
+* Make an entry for a node.						*
+*									*
+************************************************************************/
+node_info_t	*mk_node(char *name, int type, int maj, int min)
+{
+    node_info_t	*p ;
+
+    p = (node_info_t *) malloc(sizeof(*p)) ;
+    if (p == NULL)
+    {
+	fprintf(stderr, "Cannot allocate entry for \"%s\"\n", name) ;
+	exit(1) ;
+    }
+
+    strncpy(p->name, name, sizeof(p->name)) ;
+    p->type  = type ;
+    p->major = maj ;
+    p->minor = min ;
+
+    link_on_end((lookup_struct_t **) &node_head, (lookup_struct_t *) p) ;
+
+    return(p) ;
+
+} /* mk_node */
+
+/************************************************************************
+*                             mk_device                                 *
+*************************************************************************
+*									*
+* Make an entry for a device.						*
+*									*
+************************************************************************/
+device_info_t	*mk_device(device_info_t *devp)
+{
+    device_info_t	*p ;
+
+    p = (device_info_t *) malloc(sizeof(*p)) ;
+    if (p == NULL)
+    {
+	fprintf(stderr, "Cannot allocate device entry for \"%s\"\n", devp->name) ;
+	exit(1) ;
+    }
+
+    *p = *devp ;
+
+    link_on_end((lookup_struct_t **) &device_head, (lookup_struct_t *) p) ;
+    ndevices++ ;
+
+    return(p) ;
+
+} /* mk_device */
+
+/************************************************************************
+*                            lookup_name                                *
+*************************************************************************
+*									*
+* This routine takes advantage of the fact that all of the table	*
+* entries have the same first two fields:  a link and a name.		*
+*									*
+* It searches any of the tables for the named item.			*
+*									*
+************************************************************************/
+void	*lookup_name(void *list_head, char *name)
+{
+    lookup_struct_t	*p ;
+
+    for (p = (lookup_struct_t *) list_head; p != NULL; p = p->link)
+	if (strcmp(name, p->name) == 0) return((void *) p) ;
+
+    return(NULL) ;
+
+} /* lookup_name */
+
+/************************************************************************
+*                           find_driver                                 *
+*************************************************************************
+*									*
+* Find the driver by name.						*
+*									*
+************************************************************************/
+driver_info_t	*find_driver(char *name)
+{
+    return((driver_info_t *) lookup_name(driver_head, name)) ;
+
+} /* find_driver */
+
+/************************************************************************
+*                           find_module                                 *
+*************************************************************************
+*									*
+* Find the module by name.						*
+*									*
+************************************************************************/
+module_info_t	*find_module(char *name)
+{
+    return((module_info_t *) lookup_name(module_head, name)) ;
+
+} /* find_module */
+
+/************************************************************************
+*                           find_node                                 *
+*************************************************************************
+*									*
+* Find the node by name.						*
+*									*
+************************************************************************/
+node_info_t	*find_node(char *name)
+{
+    return((node_info_t *) lookup_name(node_head, name)) ;
+
+} /* find_node */
+
+/************************************************************************
+*                             err                                       *
+*************************************************************************
+*									*
+* Print an error message.						*
+*									*
+************************************************************************/
+void	err(char *fmt, ...)
+{
+    va_list args;
+
+    fprintf(stderr, "\"%s\" line %d: ", infile_name, line_nr) ;
+    va_start (args, fmt);
+    vfprintf (stderr, fmt, args);
+    va_end (args);
+
+} /* err */
+
+/************************************************************************
+*                           read_line                                   *
+*************************************************************************
+*									*
+* Read a line from infile.  Skip comment lines and blank lines.		*
+* Return negative for EOF, return zero for success.			*
+*									*
+************************************************************************/
+int	read_line(void)
+{
+    do
+    {
+	line_nr++ ;
+	if (fgets(inbuf, sizeof(inbuf), infile) == NULL)
+	{
+	    strcpy(inbuf, "End-of-file") ;
+	    return(-1) ;
+	}
+
+    } while (inbuf[0] == '#' || inbuf[0] == '\n') ;
+
+    nextp = inbuf ;			/* set global ptr */
+    return(0) ;
+
+} /* read_line */
+
+/************************************************************************
+*                           get_next                                    *
+*************************************************************************
+*									*
+* Get the next blank-delimited token and leave in the global token	*
+* buffer.  Advance global input pointers.				*
+*									*
+* Return the class of the next thing, EOL if end of line.		*
+*									*
+************************************************************************/
+int	get_next(void)
+{
+    char	*p ;
+    int		 n ;
+
+    p = token ;
+    n = 0 ;
+
+    while ( *nextp && *nextp <= ' ' ) nextp++ ;	/* skip white space */
+
+    while ( *nextp && *nextp > ' ' && n < sizeof(token)-1 )
+    {						/* copy token */
+	*p++ = *nextp++ ;
+	n++ ;
+    }
+
+    while ( *nextp && *nextp > ' ' ) nextp++ ;	/* skip excess chars */
+
+    *p = 0 ;					/* NUL terminate the token */
+
+    if (isdigit(token[0]))			/* numeric value */
+    {
+	class = NUMBER ;
+	value = (int) strtol(token, NULL, 0) ;	/* input convert */
+    }
+    else
+    if (token[0] == 0)				/* end of line */
+    {
+	strcpy(token, "End-of-line") ;
+	class = EOL ;
+    }
+    else					/* treat as identifier */
+	class = IDENT ;
+
+    return(class) ;				/* return its class */
+
+} /* get_next */
+
+/************************************************************************
+*                           process_line                                *
+*************************************************************************
+*									*
+* Process one line of input.						*
+*									*
+************************************************************************/
+void	process_line(void)
+{
+    if (get_next() == EOL)
+    {
+	err("Internal error:  empty line\n") ;
+	return ;
+    }
+
+    if (strcmp(token, "driver") == 0)
+    {
+	char	 name[50] ;
+	char	 prefix[50] ;
+	int	 major;
+	int	 nminors ;
+
+	if (get_next() != IDENT)
+	{
+	    err("Driver name must be identifier: %s\n", token) ;
+	    return ;
+	}
+
+	strncpy(name, token, sizeof(name)-1) ;
+	name[sizeof(name)-1] = 0 ;
+
+	if (get_next() != IDENT)
+	{
+	    err("Driver prefix must be identifier: %s\n", token) ;
+	    return ;
+	}
+
+	strncpy(prefix, token, sizeof(prefix)-1) ;
+	name[sizeof(prefix)-1] = 0 ;
+
+	switch (get_next())
+	{
+	case NUMBER:
+	    major = (int) value ;
+	    break ;
+	case IDENT:
+	    if (strcmp(token, "*") == 0)
+	    {
+		major = next_major++ ;
+		break ;
+	    }
+	    /*
+	     * Fall into error case 
+	     */
+	default:
+	    err("Invalid driver major specifier: %s\n", token) ;
+	    return ;
+	}
+
+	switch (get_next())
+	{
+	case NUMBER:
+	    nminors = (int) value ;
+	    break ;
+	case EOL:
+	    nminors = 1 ;
+	    break ;
+	default:
+	    err("Invalid driver n-minors specifier: %s\n", token) ;
+	    return ;
+	}
+
+	mk_driver(name, prefix, major, nminors) ;	/* make the entry */
+    }
+    else
+    if (strcmp(token, "module") == 0)
+    {
+	char	 name[50] ;
+	char	 prefix[50] ;
+
+	if (get_next() != IDENT)
+	{
+	    err("Module name must be identifier: %s\n", token) ;
+	    return ;
+	}
+
+	strncpy(name, token, sizeof(name)-1) ;
+	name[sizeof(name)-1] = 0 ;
+
+	if (get_next() != IDENT)
+	{
+	    err("Module prefix must be identifier: %s\n", token) ;
+	    return ;
+	}
+
+	strncpy(prefix, token, sizeof(prefix)-1) ;
+	name[sizeof(prefix)-1] = 0 ;
+
+	mk_module(name, prefix) ;
+    }
+    else
+    if (strcmp(token, "node") == 0)
+    {
+	char	 	 name[100] ;
+	int	 	 type ;			/* I_IFCHR, etc */
+	int	 	 major;
+	int	 	 minor ;
+	driver_info_t	*dp ;
+
+	if (get_next() != IDENT)
+	{
+	    err("Node name must be identifier: %s\n", token) ;
+	    return ;
+	}
+
+	strncpy(name, token, sizeof(name)-1) ;
+	name[sizeof(name)-1] = 0 ;
+
+	switch (get_next())
+	{
+	case IDENT:
+	    if (strcmp(token, "c") == 0)
+	    {
+		type = S_IFCHR ;
+		break ;
+	    }
+	    else
+	    if (strcmp(token, "b") == 0)
+	    {
+		type = S_IFBLK ;
+		break ;
+	    }
+	    else
+	    if (strcmp(token, "p") == 0)
+	    {
+		type = S_IFIFO ;
+		break ;
+	    }
+	    /*
+	     * Fall into error case 
+	     */
+	case NUMBER:
+	case EOL:
+	default:
+	    err("Invalid device type specifier: %s\n", token) ;
+	    return ;
+	}
+
+	switch (get_next())
+	{
+	case NUMBER:
+	    type |= value ;			/* add permissions */
+	    break ;
+
+	case IDENT:
+	    if (strcmp(token, "*") == 0)
+	    {
+		type |= dflt_perm ;
+		break ;
+	    }
+	    /*
+	     * Fall through to error
+	     */
+	case EOL:
+	default:
+	    err("Invalid permissions specifier: %s\n", token) ;
+	    return ;
+	}
+
+	switch (get_next())
+	{
+	case IDENT:
+	    dp = find_driver(token) ;
+	    if (dp == NULL)
+	    {
+		err("Invalid driver name: %s\n", token) ;
+		return ;
+	    }
+
+	    major = dp->major ;
+	    break ;
+
+	case NUMBER:
+	    major = value ;
+	    break ;
+	case EOL:
+	default:
+	    err("Invalid device major specifier: %s\n", token) ;
+	    return ;
+	}
+
+	switch (get_next())
+	{
+	case IDENT:
+	    dp = find_driver(token) ;
+	    if (dp == NULL)
+	    {
+		err("Invalid driver name: %s\n", token) ;
+		return ;
+	    }
+
+	    minor = dp->major ;
+	    break ;
+
+	case NUMBER:
+	    minor = value ;
+	    break ;
+	case EOL:
+	default:
+	    err("Invalid device minor specifier: %s\n", token) ;
+	    return ;
+	}
+
+	mk_node(name, type, major, minor) ;
+    }
+    else
+    if (strcmp(token, "device") == 0)
+    {
+	device_info_t	 dev ;
+
+	memset(&dev, 0, sizeof(dev)) ;
+	if (get_next() != IDENT)
+	{
+	    err("Driver name must be identifier: %s\n", token) ;
+	    return ;
+	}
+
+	strncpy(dev.name, token, sizeof(dev.name)-1) ;
+	dev.name[sizeof(dev.name)-1] = 0 ;
+	dev.drvr = find_driver(token) ;
+	if (dev.drvr == NULL)
+	{
+	    err("Driver name \"%s\" not found\n") ;
+	    return ;
+	}
+
+	if (get_next() == NUMBER)
+	    dev.unit = value ;
+	else
+	if (class == EOL)
+	    dev.unit = -1 ;
+	else
+	{
+	    err("Unit number must be a number: %s\n") ;
+	    return ;
+	}
+
+	if (get_next() == NUMBER)
+	    dev.port = value ;
+	else
+	if (class == EOL)
+	    dev.port = -1 ;
+	else
+	{
+	    err("Port address must be a number: %s\n") ;
+	    return ;
+	}
+
+
+	if (get_next() == NUMBER)
+	    dev.nports = (int) value ;
+	else
+	if (class == EOL)
+	    dev.nports = 0 ;
+	else
+	{
+	    err("Number of port addresses must be a number: %s\n") ;
+	    return ;
+	}
+
+
+	if (get_next() == IDENT)
+	    switch (token[0])
+	    {
+	    case 'n':
+		dev.irq_share =	IRQ_NO_SHARE ;
+		break ;
+	    case 's':
+		dev.irq_share =	IRQ_SHARE ;
+		break ;
+	    case 'S':
+		dev.irq_share =	IRQ_SHARE_DEV ;
+		break ;
+	    case 'x':
+		dev.irq_share =	IRQ_SHARE_DC ;
+		break ;
+	    default:
+		err("Invalid IRQ sharing code: \"%s\"\n", token) ;
+		return ;
+	    }
+	else
+	if (class == EOL)
+	    dev.irq_share = 0 ;
+	else
+	{
+	    err("IRQ sharing code must be identifier: %s\n", token) ;
+	    return ;
+	}
+
+
+	if (get_next() == NUMBER)
+	    dev.irq = (int) value ;
+	else
+	if (class == EOL)
+	    dev.irq = -1 ;
+	else
+	{
+	    err("IRQ must be a number: %s\n") ;
+	    return ;
+	}
+
+
+	if (get_next() == NUMBER)
+	    dev.mem = value ;
+	else
+	if (class == EOL)
+	    dev.mem = 0 ;
+	else
+	{
+	    err("Memory address must be a number: %s\n") ;
+	    return ;
+	}
+
+
+	if (get_next() == NUMBER)
+	    dev.mem_size = value ;
+	else
+	if (class == EOL)
+	    dev.mem_size = 0 ;
+	else
+	{
+	    err("Memory size must be a number: %s\n") ;
+	    return ;
+	}
+
+
+	if (get_next() == NUMBER)
+	    dev.dma1 = (int) value ;
+	else
+	if (class == EOL)
+	    dev.dma1 = -1 ;
+	else
+	{
+	    err("DMA channel must be a number: %s\n") ;
+	    return ;
+	}
+
+
+	if (get_next() == NUMBER)
+	    dev.dma2 = (int) value ;
+	else
+	if (class == EOL)
+	    dev.dma2 = -1 ;
+	else
+	{
+	    err("DMA channel must be a number: %s\n") ;
+	    return ;
+	}
+
+	mk_device(&dev) ;
+    }
+    else
+    if (strcmp(token, "define") == 0)
+    {
+	fprintf(configfile, "#define %s\n", nextp) ;
+    }
+    else
+	err("Invalid keyword \"%s\"\n", token) ;
+
+} /* process_line */
+
+/************************************************************************
+*                           process_file                                *
+*************************************************************************
+*									*
+* Process the input file.						*
+*									*
+************************************************************************/
+void	process_file(void)
+{
+    while (read_line() == 0)
+    {
+	process_line() ;
+    }
+
+} /* process_file */
+
+/************************************************************************
+*                           build_modconf                               *
+*************************************************************************
+*									*
+* Build the modconf.c file.						*
+*									*
+************************************************************************/
+void	build_modconf(void)
+{
+    driver_info_t	*dp ;
+    module_info_t	*mp ;
+
+#define	p0(f)	fprintf(outfile, f)
+#define	p1(f,y)	fprintf(outfile, f,y)
+
+    p0("/* WARNING:  THIS FILE IS PROGRAMATICALLY GENERATED. */\n");
+    p0("/*           DO NOT MODIFY BY HAND.                  */\n");
+    p0("\n") ;
+    p0("#include <sys/stream.h>\n") ;
+    p0("\n") ;
+
+    for (dp = driver_head; dp != NULL; dp = dp->link)
+    {
+	p1("extern struct streamtab		%sinfo ;\n", dp->prefix) ;
+    }
+    p0("\n") ;
+
+    p0("driver_config_t		lis_driver_config[] =\n") ;
+    p0("{\n") ;
+    for (dp = driver_head; dp != NULL; dp = dp->link)
+    {
+	p1("	{\"%s\",", dp->name) ;
+	p1(" &%sinfo,", dp->prefix) ;
+	p1(" %d,", dp->major) ;
+	p1(" %d},\n", dp->nminors) ;
+    }
+    p0("\n") ;
+    p0("	{\"\", NULL, 0, 0}	/* always the final element */\n") ;
+    p0("} ;\n") ;
+    p0("\n") ;
+
+    for (mp = module_head; mp != NULL; mp = mp->link)
+    {
+	p1("extern struct streamtab		%sinfo ;\n", mp->prefix) ;
+    }
+    p0("\n") ;
+
+    p0("module_config_t		lis_module_config[] =\n") ;
+    p0("{\n") ;
+    for (mp = module_head; mp != NULL; mp = mp->link)
+    {
+	p1("	{\"%s\",", mp->name) ;
+	p1(" &%sinfo},\n", mp->prefix) ;
+    }
+    p0("\n") ;
+    p0("	{\"\", NULL}		/* always the final element */\n") ;
+    p0("} ;\n") ;
+
+    fclose(outfile) ;
+
+#undef p0
+#undef p1
+
+} /* build_modconf */
+
+/************************************************************************
+*                           build_mknods				*
+*************************************************************************
+*									*
+* Build the makenodes.c file.						*
+*									*
+************************************************************************/
+void	build_mknods(void)
+{
+    node_info_t	*dp ;
+
+#define	p0(f)	fprintf(mkfile, f)
+#define	p1(f,y)	fprintf(mkfile, f,y)
+
+    p0("/* WARNING:  THIS FILE IS PROGRAMATICALLY GENERATED. */\n");
+    p0("/*           DO NOT MODIFY BY HAND.                  */\n");
+    p0("\n") ;
+    p0("#include <sys/types.h>\n") ;
+    p0("#include <sys/stat.h>\n") ;
+    p0("#include <sys/stream.h>\n") ;
+    p0("#include <stdio.h>\n") ;
+    p0("#include <fcntl.h>\n") ;
+    p0("#include <unistd.h>\n") ;
+    p0("\n") ;
+
+    p1("void %s(void)\n", func_name) ;
+    p0("{\n") ;
+
+    p0("	int	rslt ;\n") ;
+    p0("\n") ;
+    for (dp = node_head; dp != NULL; dp = dp->link)
+    {
+	p1("	rslt = %s(", mknod_name) ;
+	p1("\"%s\", ", dp->name) ;
+	p1("0%o, ", dp->type) ;
+	p1("makedevice(%d,", dp->major) ;
+	p1("%d)) ;\n", dp->minor) ;
+	p1("	if (rslt < 0) printf(\"%s: %%s\\n\", strerror(-rslt));\n",
+			    dp->name) ;
+	p0("\n") ;
+    }
+
+    p0("}\n") ;
+
+    fclose(mkfile) ;
+
+#undef p0
+#undef p1
+
+} /* build_mknods */
+
+/************************************************************************
+*                            raise                                      *
+*************************************************************************
+*									*
+* Return the upper-case equivalent of the passed-in string.		*
+*									*
+************************************************************************/
+char	*raise(char *p)
+{
+    static char		 uc[200] ;
+    char		*ucp ;
+
+
+    for (ucp = uc; *p; p++, ucp++) *ucp = toupper(*p) ;
+    *ucp = 0 ;
+
+    return(uc) ;
+
+} /* raise */
+
+/************************************************************************
+*                             build_config                              *
+*************************************************************************
+*									*
+* Build the file config.h.						*
+*									*
+************************************************************************/
+
+#define	p0(f)		fprintf(configfile, f)
+#define	p1(f,y)		fprintf(configfile, f,y)
+#define	p2(f,y,z)	fprintf(configfile, f,y,z)
+
+void	start_config(void)
+{
+    p0("/* WARNING:  THIS FILE IS PROGRAMATICALLY GENERATED. */\n");
+    p0("/*           DO NOT MODIFY BY HAND.                  */\n");
+    p0("\n") ;
+
+} /* start_config */
+
+void	build_config(void)
+{
+    driver_info_t	*drp ;
+    device_info_t	*dp ;
+    int			 devnr = 0 ;
+
+    for (drp = driver_head; drp != NULL; drp = drp->link)
+    {
+	if (strcmp(drp->prefix, "-") == 0)	/* no name */
+	    continue ;				/* no defines */
+
+	p1("#define\t%s\t\t1\n", raise(drp->prefix));
+	p2("#define\t%s_CNTLS\t%d\n", raise(drp->prefix), drp->nminors);
+	p2("#define\t%s_UNITS\t%d\n", raise(drp->prefix), drp->nminors);
+	p2("#define\t%s_CMAJORS\t%d\n", raise(drp->prefix), 1);
+	p2("#define\t%s_CMAJOR_0\t%d\n", raise(drp->prefix), drp->major);
+	/* TBD: calculate SVR4 compatible type */
+	p2("#define\t%s_TYPE\t%d\n", raise(drp->prefix), -1);
+	p0("\n") ;
+    }
+
+    for (dp = device_head; dp != NULL; dp = dp->link)
+    {
+	if (strcmp(dp->drvr->prefix, "-") == 0)	/* no name */
+	    continue ;				/* no defines */
+
+	devnr = dp->unit ;
+	p2("#define\t%s_%u\t1\n", raise(dp->drvr->prefix), devnr);
+
+	if (dp->port > 0)
+	{
+	    p2("#define\t%s_%u_SIOA\t", raise(dp->drvr->prefix), devnr);
+	    p1("0x%lx\n", dp->port) ;
+	}
+	else
+	    p2("#define\t%s_%u_SIOA\t0\n", raise(dp->drvr->prefix), devnr);
+
+	if (dp->nports > 0)
+	{
+	    p2("#define\t%s_%u_EIOA\t", raise(dp->drvr->prefix), devnr);
+	    p1("0x%lx\n", dp->port+dp->nports-1) ;
+	}
+	else
+	{
+	    p2("#define\t%s_%u_EIOA\t", raise(dp->drvr->prefix), devnr);
+	    p1("0x%lx\n", dp->port) ;
+	}
+
+	p2("#define\t%s_%u_VECT\t", raise(dp->drvr->prefix), devnr);
+	p1("%d\n", dp->irq) ;
+
+	if (dp->mem > 0)
+	{
+	    p2("#define\t%s_%u_SCMA\t", raise(dp->drvr->prefix), devnr);
+	    p1("0x%lx\n", dp->mem) ;
+	    p2("#define\t%s_%u_ECMA\t", raise(dp->drvr->prefix), devnr);
+	    p1("0x%lx\n", dp->mem + dp->mem_size - 1) ;
+	}
+	else
+	{
+	    p2("#define\t%s_%u_SCMA\t0\n", raise(dp->drvr->prefix), devnr);
+	    p2("#define\t%s_%u_ECMA\t0\n", raise(dp->drvr->prefix), devnr);
+	}
+
+	p2("#define\t%s_%u_CHAN\t", raise(dp->drvr->prefix), devnr);
+	p1("%d\n", dp->dma1) ;
+	p2("#define\t%s_%u_CHAN2\t", raise(dp->drvr->prefix), devnr);
+	p1("%d\n", dp->dma2) ;
+
+	/* TBD:  come up with something for driver "type" */
+	p0("\n") ;
+    }
+
+   fclose(configfile) ;
+
+#undef p0
+#undef p1
+#undef p2
+
+} /* build_config */
+
+/************************************************************************
+*                            print_options                              *
+************************************************************************/
+void	print_options(void)
+{
+
+#define	p	printf
+
+p("Usage:  strconf <options> <input-file>\n");
+p("\n");
+p("<options>\n") ;
+p("\n");
+p("-b<number>   Set the base major number for automatic assignment\n");
+p("             of major device numbers.\n");
+p("-h<file>     Set the output header file name to something other than\n");
+p("             the default \"config.h\".\n");
+p("-o<file>     Set the output file name rather than the default\n");
+p("             name \"modconf.c\".  This is the file that must be\n");
+p("             linked in with STREAMS.\n");
+p("-m<file>     Set the output file name for the program that will\n");
+p("             make the nodes to something other than \"makenodes.c\".\n");
+p("             This program is compiled and then run at boot time\n");
+p("             to create all the /dev entries for the STREAMS drivers.\n");
+p("-M<name>     The name of the mknod() routine to call.  The default\n");
+p("             is \"mknod\".\n");
+p("-p<perm>     Set default permissions to something other than 0666.\n");
+p("-r<name>     The name of the routine to build in makenodes.c.\n");
+p("             The default is \"main\".\n") ;
+
+#undef p
+
+} /* print_options */
+
+/************************************************************************
+*                          get_options                                  *
+*************************************************************************
+*									*
+* Get command line options.						*
+*									*
+************************************************************************/
+void	get_options(int argc, char **argv)
+{
+    char	*p ;
+
+    for (argc--, argv++; argc > 0; argc--, argv++)
+    {
+	p = *argv ;
+	if (*p == '-')
+	    switch (*++p)
+	    {
+	    case 'b':			/* -b<number> */
+		next_major = (int) strtol(p+1, NULL, 0) ;
+		break ;
+	    case 'h':			/* -h<file> */
+		config_name = p+1 ;
+		break ;
+	    case 'o':			/* -o<file> */
+		outfile_name = p+1 ;
+		break ;
+	    case 'm':			/* -m<file> */
+		mkfile_name = p+1 ;
+		break ;
+	    case 'M':			/* -M<name> */
+		mknod_name = p+1 ;
+		break ;
+	    case 'p':
+		dflt_perm = (int) strtol(p+1, NULL, 0) ;
+		break ;
+	    case 'r':
+	    	func_name = p+1 ;	/* -p<name> */
+		break ;
+	    default:
+		print_options() ;
+		exit(1) ;
+	    }
+	else
+	    infile_name = p ;
+    }
+
+    if (infile_name == NULL || outfile_name == NULL || mkfile_name == NULL ||
+        mknod_name == NULL || config_name == NULL)
+    {
+	print_options() ;
+	exit(1) ;
+    }
+
+} /* get_options */
+
+/************************************************************************
+*                              main                                     *
+************************************************************************/
+void	main(int argc, char **argv)
+{
+    get_options(argc, argv) ;
+
+    /*
+     * Open all the files
+     */
+    infile = fopen(infile_name, "r") ;
+    if (infile == NULL)
+    {
+	perror(infile_name) ;
+	exit(1) ;
+    }
+
+    outfile = fopen(outfile_name, "w") ;
+    if (outfile == NULL)
+    {
+	perror(outfile_name) ;
+	exit(1) ;
+    }
+
+    mkfile = fopen(mkfile_name, "w") ;
+    if (mkfile == NULL)
+    {
+	perror(mkfile_name) ;
+	exit(1) ;
+    }
+
+    configfile = fopen(config_name, "w") ;
+    if (configfile == NULL)
+    {
+	perror(config_name) ;
+	exit(1) ;
+    }
+
+    start_config() ;
+    process_file() ;
+    build_modconf() ;
+    build_mknods() ;
+    build_config() ;
+
+} /* main */
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/stream.c /usr/src/linux/drivers/streams/LiS/head/stream.c
--- debug/drivers/streams/LiS/head/stream.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/stream.c	Wed Jan  1 14:13:04 1997
@@ -0,0 +1,167 @@
+/*                               -*- Mode: C -*- 
+ * stream.c --- STREAMS entry points and main routines 
+ * Author          : Graham Wheeler, Francisco J. Ballesteros
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: stream.c,v 1.4 1996/01/17 18:57:07 dave Exp $
+ * ----------------______________________________________________
+ *
+ *   Copyright (C) 1995  Francisco J. Ballesteros, Graham Wheeler,
+ *                       Denis Froschauer
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    nemo@ordago.uc3m.es, gram@aztec.co.za, 100741.1151@compuserve.com
+ */
+
+
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#include <sys/strport.h>
+#include <sys/stream.h>	/* this will include the whole stuff */
+
+/*  -------------------------------------------------------------------  */
+/*				    Types                                */
+
+
+/*  -------------------------------------------------------------------  */
+/*				  Glob. Vars                             */
+
+extern int	lis_queues_running ;
+
+
+
+/*  -------------------------------------------------------------------  */
+/*			   Local functions & macros                      */
+
+/*  -------------------------------------------------------------------  */
+
+/*  -------------------------------------------------------------------  */
+/* service scheduler
+ */
+static void
+queuerun(void)
+{
+    queue_t	*q;
+    queue_t	*qhead ;
+    stdata_t	*strmhd ;
+    int		 psw;
+
+    if (LIS_DEBUG_MONITOR_MEM)
+	lis_check_mem() ;
+
+    /* Process scan queue head list
+     *
+     * Take the scan queue head and tail pointers away into locals.
+     * Clear the globals.  This allows us to traverse the queue
+     * with interrrupts wide open.  
+     */
+    SPLSTR(psw);
+    qhead = lis_scanqhead ;
+    lis_scanqhead= lis_scanqtail = NULL ;
+    SPLX(psw);
+
+    for (q= qhead; q != NULL; 
+	 qhead= q->q_scnxt, q->q_scnxt=NULL, q=qhead)
+    {
+	F_CLR(q->q_flag,QSCAN);
+	strmhd = (stdata_t *) q->q_ptr ;
+	if (strmhd->sd_wmsg != NULL)		/* held msg waiting */
+	{
+	    lis_putnext(LIS_WR(q),strmhd->sd_wmsg);	/* send it */
+	    strmhd->sd_wmsg = NULL ;		/* don't reuse msg */
+	}
+    }
+
+    if (lis_strbcflag)
+      lis_dobufcall();
+
+    /*
+     * Make local copies of the service procedure queue head and
+     * tail.  We can then traverse this list with interrupts on.
+     */
+    SPLSTR(psw);
+    qhead = lis_qhead ;
+    lis_qhead = lis_qtail = NULL ;
+    SPLX(psw);
+
+    /* for each scheduled queue on the qhead list... */
+    for (q = qhead; q != NULL; q = qhead)
+    {
+	SPLSTR(psw);				/* protect queue fields */
+	/* clear the QENAB flag */
+	q->q_flag &= ~QENAB;
+
+	/* remove it from the list */
+	qhead     = q->q_link ;			/* next queue to examine */
+	q->q_link = NULL ;			/* clear link of this q */
+	LisDownCount(QSCHEDS) ;
+	SPLX(psw);
+
+	/* call its service procedure, if any */
+	if (q->q_qinfo->qi_srvp) 
+	    (*q->q_qinfo->qi_srvp)(q);
+    }
+
+}/*queuerun*/
+
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+/*  -------------------------------------------------------------------  */
+/* lis_run_queues - entry point to the STREAMS scheduler. This is called
+ *		    whenever we want the STREAMS queues to actually
+ *		    be run.
+ */
+void 
+lis_run_queues(void)
+{
+    int		psw;
+    extern int	runq_sched ;
+
+    SPLSTR(psw);			/* intrs off to chk q heads */
+    while (lis_qhead != NULL || lis_scanqhead != NULL || lis_strbcflag)
+    {
+	if (lis_queues_running)		/* recursion protection */
+	{
+	    SPLX(psw);
+	    return;
+	}
+
+	lis_queues_running++;
+	SPLX(psw);
+
+	queuerun();			/* run q's w/intrs enabled */
+
+	SPLSTR(psw);
+	lis_queues_running--;
+    }
+
+    runq_sched = 0 ;			/* OK to V semaphore now */
+    SPLX(psw);				/* intrs enabled upon return */
+
+}/*lis_run_queues*/
+
+/* process a held msg tmout
+ */
+void  lis_scantmout_handler(unsigned long arg) {
+
+  (void)arg;
+  lis_runqueues();
+}
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/strmdbg.c /usr/src/linux/drivers/streams/LiS/head/strmdbg.c
--- debug/drivers/streams/LiS/head/strmdbg.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/strmdbg.c	Fri Dec 27 16:44:08 1996
@@ -0,0 +1,753 @@
+/************************************************************************
+*                       STREAMS Debugging Aids                          *
+*************************************************************************
+*									*
+* Author:	David Grothe	<dave@gcom.com>				*
+*									*
+************************************************************************/
+
+#include <sys/stream.h>
+#include <sys/poll.h>
+#include <string.h>
+
+/************************************************************************
+*                          Memory Links                                 *
+*************************************************************************
+*									*
+* We keep track of who allocates messages and other areas of memory.	*
+* The routine lis_print_mem will print out ownership information about	*
+* all of the memory allocated by streams.				*
+*									*
+************************************************************************/
+
+typedef struct mem_link
+{
+    struct mem_link	*next ;
+    struct mem_link	*prev ;
+
+    long		 size ;
+    const char		*file_name ;
+    int	 		 line_nr ;
+
+} mem_link_t ;
+
+long		 lis_mem_alloced ;	/* keep track of allocated memory */
+long		 lis_max_mem ;		/* maximum to allocate */
+
+mem_link_t	 lis_mem_head = {&lis_mem_head, &lis_mem_head} ;
+
+
+#ifndef DEBUG_MASK
+#define	DEBUG_MASK	0
+#endif
+unsigned long	lis_debug_mask = DEBUG_MASK;	/* debug mask */
+
+
+/************************************************************************
+*                            lis_malloc                                 *
+*************************************************************************
+*									*
+* Allocate nbytes of memory and return a pointer to it.			*
+*									*
+************************************************************************/
+void	*lis_malloc(int nbytes, int class, char *file_name, int line_nr)
+{
+#ifdef MSG_TRACE
+    mem_link_t	*p ;
+    long	*lp ;				/* ptr to guard word */
+    int		 abytes ;			/* # bytes to allocate */
+    int		 psw;
+
+    LisUpCount(MEMALLOCS) ;			/* stats array */
+
+    if (lis_max_mem != 0 && lis_mem_alloced >= lis_max_mem)
+    {
+	LisUpFailCount(MEMALLOCD) ;		/* stats array */
+	LisUpFailCount(MEMALLOCS) ;		/* stats array */
+	return(NULL) ;
+    }
+
+    /*
+     * Round nbytes up to even multiple of 16 bytes.  Then allocate
+     * that much space plus room for the header plus room for the
+     * guard word at the end of the area.
+     */
+    abytes = nbytes + ((16 - (nbytes & 0x0F)) & 0x0F) ;
+    p = (mem_link_t *) KALLOC(abytes + sizeof(*p) + sizeof(long), class) ;
+    if (p == NULL)
+    {
+	LisUpFailCount(MEMALLOCD) ;		/* stats array */
+	LisUpFailCount(MEMALLOCS) ;		/* stats array */
+	return(NULL) ;
+    }
+
+    SPLSTR(psw);
+
+    lis_mem_alloced += abytes ;			/* keep track of memory */
+    LisUpCounter(MEMALLOCD, abytes) ;		/* stats array */
+
+    p->next	  = &lis_mem_head ;		/* we point fwd to head */
+    p->prev	  = lis_mem_head.prev ;		/* we point back to old last */
+    p->prev->next = p ;				/* elt b4 us points to us */
+    lis_mem_head.prev = p ;			/* we are last elt in list */
+
+    p->size	  = abytes ;			/* save # bytes */
+    p->file_name  = file_name ;			/* name of file called from */
+    p->line_nr	  = line_nr;			/* line number called from */
+
+    lp = (long *) (((char *)p) + abytes + sizeof(*p)) ;	/* to guard word */
+    *lp = MEM_GUARD ;				/* plant guard word */
+
+    if (LIS_DEBUG_MALLOC)			/* debugging allocations */
+    {
+	printk("lis_malloc: ") ;
+	lis_print_block(p+1) ;
+    }
+
+    if (LIS_DEBUG_MONITOR_MEM)
+	lis_check_mem() ;			/* check all mem areas */
+
+    SPLX(psw);
+
+    return(p+1) ;				/* rtn area caller can use */
+#else
+    return(KALLOC(nbytes, class)) ;
+#endif
+} /* lis_malloc */
+
+/************************************************************************
+*                          lis_check_guard                              *
+*************************************************************************
+*									*
+* Check the guard word at the end of the area pointed to by 'ptr'.	*
+* Return 0 if bad, 1 if good.  If bad, print a message to that effect	*
+* with "msg" embedded in it.						*
+*									*
+* The argument 'ptr' is the pointer to the usable portion of the area,	*
+* that is, the same value as returned by lis_malloc.			*
+*									*
+************************************************************************/
+int	lis_check_guard(void *ptr, char *msg)
+{
+#ifdef MSG_TRACE
+    mem_link_t	*p ;
+    long	*lp ;
+
+    if (ptr == NULL) return(1) ;		/* "good" */
+
+    p = (mem_link_t *) ptr ;
+    p-- ;					/* go back to link structure */
+    lp = (long *) (((char *)p) + p->size + sizeof(*p)) ; /* to guard word */
+
+    if (*lp == MEM_GUARD) return(1) ;		/* good guard word */
+
+    printk("%s: memory area at 0x%lx: guard word = 0x%lx, should be 0x%lx\n",
+		msg == NULL ? "lis_check_guard" : msg, 
+		(long) ptr, *lp, (long) MEM_GUARD) ;
+    lis_print_block(ptr) ;			/* print the hdr info */
+    return(0);
+#else
+    return(1) ;					/* always "good"  */
+#endif
+
+} /* lis_check_guard */
+
+/************************************************************************
+*                            lis_free                                   *
+*************************************************************************
+*									*
+* Free a block of memory allocated by lis_malloc.			*
+*									*
+************************************************************************/
+void	lis_free(void *ptr, char *file_name, int line_nr)
+{
+#ifdef MSG_TRACE
+    mem_link_t	*p ;
+    int		 psw;
+    int		 rslt ;
+
+    if (ptr == NULL) return ;
+
+    SPLSTR(psw);
+
+    LisUpCount(MEMFREES) ;			/* stats array */
+    if (LIS_DEBUG_MONITOR_MEM)
+	rslt = lis_check_mem() ;		/* check all mem areas */
+    else
+	rslt = lis_check_guard(ptr, file_name) ;/* check the guard word */
+
+    if (rslt == 0)
+	LisUpFailCount(MEMFREES) ;		/* stats array */
+
+    p = (mem_link_t *) ptr ;
+    p-- ;					/* go back to link structure */
+
+    lis_mem_alloced -= p->size ;		/* keep track of memory */
+    LisDownCounter(MEMALLOCD, p->size) ;	/* stats array */
+
+    p->prev->next = p->next ;			/* prev elt links around us */
+    p->next->prev = p->prev ;			/* next elt links around us */
+    p->next	  = NULL ;			/* clobber our links */
+    p->prev	  = NULL ;
+
+    p->file_name  = file_name ;			/* name of file called from */
+    p->line_nr	  = line_nr;			/* line number called from */
+
+    if (LIS_DEBUG_MALLOC)			/* debugging allocations */
+    {
+	printk("lis_free: ") ;
+	lis_print_block(p+1) ;
+    }
+
+    SPLX(psw);
+
+    KFREE(p) ;
+#else
+    KFREE(ptr) ;
+#endif
+
+} /* lis_free */
+
+/************************************************************************
+*                         lis_check_mem                                 *
+*************************************************************************
+*									*
+* Run down the list of allocated memory and check all the guard words.	*
+*									*
+* Return 1 if all areas are OK.  Return 0 if some area is bad.		*
+*									*
+************************************************************************/
+int	lis_check_mem(void)
+{
+#ifdef MSG_TRACE
+    mem_link_t		*p ;
+    int			 rslt = 1 ;
+
+    for (p = lis_mem_head.next; p != &lis_mem_head; p = p->next)
+    {
+	if (!lis_check_guard(p+1, "lis_check_mem")) rslt = 0 ;
+    }
+
+    return(rslt) ;
+#else
+    return(1) ;				/* all OK */
+#endif
+
+} /* lis_check_mem */
+
+/************************************************************************
+*                          lis_mark_mem                                 *
+*************************************************************************
+*									*
+* Given a pointer as returned by lis_malloc, remark the owner of the	*
+* memory in the links.							*
+*									*
+************************************************************************/
+void	lis_mark_mem(void *ptr, const char *file_name, int line_nr)
+{
+#ifdef MSG_TRACE
+    mem_link_t	*p ;
+
+    if (ptr == NULL) return ;
+
+    p = (mem_link_t *) ptr ;
+    p-- ;					/* go back to link structure */
+    p->file_name  = file_name ;			/* name of file called from */
+    p->line_nr	  = line_nr;			/* line number called from */
+#endif
+
+} /* lis_mark_mem */
+
+/************************************************************************
+*                           lis_print_block                             *
+*************************************************************************
+*									*
+* Print a single block of memory.  The pointer passed in is the		*
+* pointer to the user section of the memory.  We back up to the		*
+* link field and print it out in decoded form.				*
+*									*
+************************************************************************/
+void	lis_print_block(void *ptr)
+{
+#ifdef MSG_TRACE
+    mem_link_t		*p ;
+
+    p = ((mem_link_t *) ptr) - 1 ;
+
+    if (p->file_name != NULL)
+    {
+	switch (p->line_nr)
+	{
+	case MEM_QUEUE:
+	    if (LIS_DEBUG_DMP_QUEUE)
+	    {
+		queue_t		*q = (queue_t *) (p+1) ;
+
+		lis_print_queue(RD(q)) ;
+		lis_print_queue(WR(q)) ;
+	    }
+	    else
+		printk("queue: \"%s\", size=%ld\n", p->file_name, p->size);
+	    break ;
+	case MEM_MSG:
+	    if (LIS_DEBUG_DMP_MBLK)
+		lis_print_msg((mblk_t *)(p+1), p->file_name,
+			      (LIS_DEBUG_DMP_DBLK) ? PRINT_DATA_ENTIRE : 0) ;
+	    else
+		printk("mblk: \"%s\", size=%ld\n", p->file_name, p->size);
+	    break ;
+	case MEM_STRMHD:
+	    if (LIS_DEBUG_ADDRS)		/* printing addresses */
+		printk("0x%lx: ", (long) ptr) ;
+
+	    printk("stream-head: \"%s\", size=%ld\n", p->file_name, p->size);
+	    break ;
+	case MEM_TIMER:
+	    if (LIS_DEBUG_ADDRS)		/* printing addresses */
+		printk("0x%lx: ", (long) ptr) ;
+
+	    printk("timer: \"%s\", size=%ld\n", p->file_name, p->size);
+	    break ;
+	case 0:
+	    if (LIS_DEBUG_ADDRS)		/* printing addresses */
+		printk("0x%lx: ", (long) ptr) ;
+
+	    printk("\"%s\", size=%ld\n", p->file_name, p->size);
+	    break ;
+	default:
+	    if (LIS_DEBUG_ADDRS)		/* printing addresses */
+		printk("0x%lx: ", (long) ptr) ;
+
+	    printk("%s #%d, size=%ld\n", p->file_name, p->line_nr, p->size);
+	    break ;
+	}
+    }
+    else
+	printk("unknown file and line number\n") ;
+#else
+    printk("STREAMS was compiled without the MSG_TRACE option set.\n") ;
+#endif
+
+} /* lis_print_block */
+
+/************************************************************************
+*                           lis_print_mem                               *
+*************************************************************************
+*									*
+* Walk the memory link list and print out each element.			*
+*									*
+************************************************************************/
+void	lis_print_mem(void)
+{
+#ifdef MSG_TRACE
+    mem_link_t		*p ;
+
+    for (p = lis_mem_head.next; p != &lis_mem_head; p = p->next)
+    {
+	if (lis_check_guard(p+1, "lis_print_mem"))
+	    lis_print_block(p+1) ;
+    }
+#else
+    printk("STREAMS was compiled without the MSG_TRACE option set.\n") ;
+#endif
+
+} /* lis_print_mem */
+
+/************************************************************************
+*                           lis_strm_name                               *
+*************************************************************************
+*									*
+* Return the name of the stream attached to the stream head or		*
+* the string "(unknown)" if there is no name for this stream.		*
+* Used for debugging printfs.						*
+*									*
+************************************************************************/
+
+const char	*lis_strm_name(stdata_t *head)
+{
+    const char	*name ;
+
+    if (   head != NULL
+        && head->sd_strtab != NULL
+	&& head->sd_strtab->st_rdinit != NULL
+	&& head->sd_strtab->st_rdinit->qi_minfo != NULL
+	&& (name = head->sd_strtab->st_rdinit->qi_minfo->mi_idname) != NULL
+       )
+	return(name);
+
+    return("(unknown)") ;
+
+} /* strm_name */
+
+/************************************************************************
+*                          lis_queue_name				*
+*************************************************************************
+*									*
+* Return the name of the stream attached to the queue or		*
+* the string "(unknown)" if there is no name for this stream.		*
+* Used for debugging printfs.						*
+*									*
+************************************************************************/
+
+const char	*lis_queue_name(queue_t *q)
+{
+    const char	*name ;
+
+    if (   q != NULL
+        && q->q_qinfo != NULL
+	&& q->q_qinfo->qi_minfo != NULL
+	&& (name = q->q_qinfo->qi_minfo->mi_idname) != NULL
+       )
+	return(name);
+
+    return("(unknown)") ;
+
+} /* lis_queue_name */
+
+/************************************************************************
+*                          lis_msg_type_name				*
+*************************************************************************
+*									*
+* Return the ASCII string name of the type of a given message.		*
+*									*
+************************************************************************/
+
+const char	*lis_msg_type_name(mblk_t *mp)
+{
+    if (mp == NULL) return("NULL-MSG") ;
+
+    if (mp->b_datap == NULL) return("NO-DATA-BLK") ;
+
+    switch(lis_btype(mp))
+    {
+    case M_DATA:	return("M_DATA");
+    case M_PROTO:	return("M_PROTO");
+    case M_BREAK:	return("M_BREAK");
+    case M_CTL:		return("M_CTL");
+    case M_DELAY:	return("M_DELAY");
+    case M_IOCTL:	return("M_IOCTL");
+    case M_PASSFP:	return("M_PASSFP");
+    case M_RSE:		return("M_RSE");
+    case M_SETOPTS:	return("M_SETOPTS");
+    case M_SIG:		return("M_SIG");
+    case M_COPYIN:	return("M_COPYIN");
+    case M_COPYOUT:	return("M_COPYOUT");
+    case M_ERROR:	return("M_ERROR");
+    case M_FLUSH:	return("M_FLUSH");
+    case M_HANGUP:	return("M_HANGUP");
+    case M_IOCACK:	return("M_IOCACK");
+    case M_IOCNAK:	return("M_IOCNAK");
+    case M_IOCDATA:	return("M_IOCDATA");
+    case M_PCPROTO:	return("M_PCPROTO");
+    case M_PCRSE:	return("M_PCRSE");
+    case M_PCSIG:	return("M_PCSIG");
+    case M_READ:	return("M_READ");
+    case M_STOP:	return("M_STOP");
+    case M_START:	return("M_START");
+    case M_STARTI:	return("M_STARTI");
+    case M_STOPI:	return("M_STOPI");
+    }
+
+    return("UNKNOWN-MSG") ;
+
+} /* lis_msg_type_name */
+
+/************************************************************************
+*                          lis_maj_min_name			 	*
+*************************************************************************
+*									*
+* Given a pointer to an stdata structure, return an ASCII form		*
+* of the major and minor device numbers associated with it.		*
+*									*
+* By having a small array of static locations we allow for a limited	*
+* amount of nestedness in calling this routine, say from both background*
+* and an interrupt routine or three.					*
+*									*
+************************************************************************/
+
+const char	*lis_maj_min_name(stdata_t *head)
+{
+    int			 inx ;
+    int			 flags ;
+    static char		 name[4][32] ;
+    static int		 index ;
+
+    if ( head == NULL )
+	return("") ;
+
+    SPLSTR(flags) ;
+    inx = index++ & 0x03 ;
+    SPLX(flags) ;
+
+    sprintf(name[inx], "(%ld,%ld)",
+			(long)STR_MAJOR(head->sd_dev),
+			(long)STR_MINOR(head->sd_dev)) ;
+
+    return(name[inx]) ;
+
+} /* lis_maj_min_name */
+
+/************************************************************************
+*                           lis_print_queue                             *
+*************************************************************************
+*									*
+* Print out some of the interesting features about a queue.		*
+*									*
+************************************************************************/
+void	lis_print_queue(queue_t *q)
+{
+    printk("queue \"%s\"", lis_queue_name(q)) ;
+    if (LIS_DEBUG_ADDRS)			/* printing addresses */
+	printk(" @ 0x%lx: q_ptr=0x%lx", (long)q, (long)q->q_ptr) ;
+    printk(", %s queue", F_ISSET(q->q_flag,QREADR) ? "read" : "write");
+    if (q->q_next == NULL)
+	printk(", q_next=NULL\n") ;
+    else
+	printk(", q_next=\"%s\"\n", lis_queue_name(q->q_next)) ;
+
+    printk("      q_flag 0x%lx%s ", q->q_flag, q->q_flag != 0 ? ":" : "") ;
+    if (F_ISSET(q->q_flag,QENAB)) printk(" QENAB");
+    if (F_ISSET(q->q_flag,QWANTR)) printk(" QWANTR");
+    if (F_ISSET(q->q_flag,QWANTW)) printk(" QWANTW");
+    if (F_ISSET(q->q_flag,QFULL)) printk(" QFULL");
+    if (F_ISSET(q->q_flag,QREADR)) printk(" QREADR");
+    if (F_ISSET(q->q_flag,QUSE)) printk(" QUSE");
+    if (F_ISSET(q->q_flag,QNOENB)) printk(" QNOENB");
+    if (F_ISSET(q->q_flag,QBACK)) printk(" QBACK");
+    if (F_ISSET(q->q_flag,QRETRY)) printk(" QRETRY");
+    if (F_ISSET(q->q_flag,QSCAN)) printk(" QSCAN");
+    if (F_ISSET(q->q_flag,QCLOSING)) printk(" QCLOSING");
+    printk("\n") ;
+
+    printk("      q_minpsz=%lu ", q->q_minpsz);
+
+    if (q->q_maxpsz == INFPSZ)
+	printk("q_maxpsz=INFPSZ ") ;
+    else
+	printk("q_maxpsz=%lu ", q->q_maxpsz);
+
+    printk("q_hiwat=%lu q_lowat=%lu", q->q_hiwat, q->q_lowat);
+
+    printk(", %d msg(s), %ld bytes\n", lis_qsize(q), q->q_count) ;
+#if 0
+    printk(" %son queue run list,", q->q_link != NULL ? "" : "not ");
+    printk(" %son queue scan list\n", q->q_scnxt != NULL ? "" : "not ");
+#endif
+} /* lis_print_queue */
+
+/************************************************************************
+*                            lis_print_stream                           *
+*************************************************************************
+*									*
+* Print out the structure of the given stream.  This is not a field-	*
+* by-field printing of the stdata structure but a synopsis of the	*
+* topology of the stream headed by this structure including its		*
+* pushed modules and multiplexor configuration if it is the control	*
+* stream of a multiplexor.						*
+*									*
+************************************************************************/
+/*
+ * Worker routine for recursive printing
+ */
+static void strm_print(stdata_t *hd, int indent)
+{
+    queue_t		*q ;
+    stdata_t		*hp ;
+
+#define	prefix	{ int i; for (i=0; i<indent; i+=2) printk(". ") ;}
+
+    prefix ;
+
+    if (hd->magic != STDATA_MAGIC)
+    {
+	printk("Stream @ %lx: bad magic number 0x%lx, should be 0x%lx\n",
+		(long) hd, hd->magic, STDATA_MAGIC) ;
+	return ;
+    }
+
+    printk("Stream %s%s: ", lis_strm_name(hd), lis_maj_min_name(hd)) ;
+    if (hd->sd_mux.mx_index != 0)
+	printk("muxid=%u ", hd->sd_mux.mx_index) ;
+
+    printk(" %s", lis_queue_name(q = hd->sd_wq)) ;
+    if ( q != NULL )			/* wq is non-NULL (paranoid) */
+    {
+	for (q = q->q_next; q != NULL; q = q->q_next)
+	{
+	    printk("-->%s", lis_queue_name(q)) ;
+	}
+    }
+
+    printk("\n") ;
+
+    if ( (hp = hd->sd_mux.mx_hd) != NULL)	/* is a ctl stream */
+    {
+	indent += 2 ;
+	prefix ;
+	printk("Lower multiplexors:\n") ;
+	for (; hp != NULL; hp = hp->sd_mux.mx_next)
+	{
+	    strm_print(hp, indent+2) ;
+	}
+    }
+
+} /* strm_print */
+
+#undef prefix
+
+void	lis_print_stream(stdata_t *hd)
+{
+    strm_print(hd, 0) ;
+
+} /* lis_print_stream */
+
+/************************************************************************
+*                         lis_print_data                                *
+*************************************************************************
+*									*
+* Print the data buffer of the associated message.			*
+*									*
+************************************************************************/
+
+void	lis_print_data(mblk_t *mp, int opt, int cont)
+{
+    const unsigned char	*p ;
+    unsigned char	*start ;
+    unsigned char	*end ;
+    int			 n ;
+
+    switch (opt)
+    {
+    case PRINT_DATA_ENTIRE:
+	if (mp->b_datap != NULL)
+	{
+	    start = mp->b_datap->db_base;
+	    end	  = mp->b_datap->db_lim;
+	}
+	else
+	{
+	    start = NULL;
+	    end	  = NULL;
+	}
+	break ;
+    case PRINT_DATA_RDWR:
+    default:
+	start	= mp->b_rptr ;
+	end	= mp->b_wptr ;
+	break ;
+    }
+
+    if (start > end)
+    {
+	printk("mblk@%lx: start (%lx) > end (%lx)\n",
+				(long)mp, (long)start, (long)end) ;
+	return ;
+    }
+
+    if (start == NULL || end == NULL)
+    {
+	printk("mblk@%lx: start (%lx) or end (%lx) NULL\n",
+				(long)mp, (long)start, (long)end) ;
+	return ;
+    }
+
+    printk("    ") ;					/* indent 4 */
+    for (p = start, n = 0; p != end; p++, n++)
+    {
+	if (  n && (n & 0x0F) == 0)			/* printed 16th elt */
+	    printk("\n    ") ;				/* indent 4 */
+
+	printk("%c",  (p == mp->b_wptr) ? '>' : ' ') ;
+	printk("%c",  (p == mp->b_rptr) ? '<' : ' ') ;
+	printk("%02X", *p) ;
+    }
+
+    if (n && p == mp->b_wptr)
+	printk(">") ;
+
+    printk("\n") ;
+
+} /* lis_print_data */
+
+/************************************************************************
+*                           lis_print_msg                               *
+*************************************************************************
+*									*
+* Print out an entire message with the given options.			*
+*									*
+* 'opt' is the print format option, or zero for the short form.		*
+*									*
+************************************************************************/
+void	lis_print_msg(mblk_t *mp, const char *prefix, int opt)
+{
+    int		nbytes ;
+    int		prnt_bfr ;
+    int		cont ;
+
+    if (mp == NULL)
+    {
+	printk("NULL message pointer\n") ;
+	return ;
+    }
+
+    printk("mblk: \"%s\"", prefix);
+    if (LIS_DEBUG_ADDRS)			/* printing addresses */
+	printk(" @ 0x%lx: b_next=0x%lx b_prev=0x%lx b_datap=0x%lx",
+	      (long)mp, (long)mp->b_next, (long)mp->b_prev, (long)mp->b_datap) ;
+
+    for (cont = 0; mp != NULL; mp = mp->b_cont, cont++)
+    {
+	nbytes = mp->b_wptr - mp->b_rptr ;
+	prnt_bfr = (opt == PRINT_DATA_ENTIRE) || (opt != 0 && nbytes != 0) ;
+	if (cont)
+	    printk(">>   ") ;
+
+	printk(" %s", lis_msg_type_name(mp)) ;
+	printk(" b_band=%d bytes=%d\n", mp->b_band, nbytes) ;
+
+	if (prnt_bfr)
+	    lis_print_data(mp, opt, cont) ;
+    }
+
+} /* lis_print_msg */
+
+/************************************************************************
+*                           lis_poll_events                             *
+*************************************************************************
+*									*
+* Return the ASCII decoding of a poll event mask.			*
+*									*
+************************************************************************/
+char	*lis_poll_events(short events)
+{
+    static char		 event_names[4][150] ;
+    static int		 index ;
+    char		*ascii_events ;
+    int			 inx ;
+    int			 flags ;
+
+    SPLSTR(flags) ;
+    inx = index++ & 0x03 ;
+    SPLX(flags) ;
+
+    ascii_events = event_names[inx] ;
+    ascii_events[0] = 0 ;
+
+    if (events & POLLIN) strcat(ascii_events, "POLLIN ") ;
+    if (events & POLLRDNORM) strcat(ascii_events, "POLLRDNORM ") ;
+    if (events & POLLRDBAND) strcat(ascii_events, "POLLRDBAND ") ;
+    if (events & POLLPRI) strcat(ascii_events, "POLLPRI ") ;
+    if (events & POLLOUT) strcat(ascii_events, "POLLOUT ") ;
+    if (events & POLLWRNORM) strcat(ascii_events, "POLLWRNORM ") ;
+    if (events & POLLWRBAND) strcat(ascii_events, "POLLWRBAND ") ;
+    if (events & POLLMSG) strcat(ascii_events, "POLLMSG ") ;
+    if (events & POLLERR) strcat(ascii_events, "POLLERR ") ;
+    if (events & POLLHUP) strcat(ascii_events, "POLLHUP ") ;
+    if (events & POLLNVAL) strcat(ascii_events, "POLLNVAL ") ;
+
+    if (ascii_events[0] == 0)
+	sprintf(ascii_events, "0x%x", events) ;
+
+    return(ascii_events) ;
+
+} /* lis_poll_events */
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/syscalls.c /usr/src/linux/drivers/streams/LiS/head/syscalls.c
--- debug/drivers/streams/LiS/head/syscalls.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/syscalls.c	Wed Jan  1 14:13:04 1997
@@ -0,0 +1,124 @@
+/*                               -*- Mode: C -*- 
+ * syscalls.c --- 
+ * Author          : Denis Froschauer
+ * Created On      : 
+ * Last Modified By: David Grothe (dave@gcom.com)
+ * RCS Id          : $Id: syscalls.c,v 1.4 1996/01/23 19:40:13 dave Exp $
+ * ----------------______________________________________________
+ *   Copyright (C) 1995  Denis Froschauer
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Library General Public
+ *    License as published by the Free Software Foundation; either
+ *    version 2 of the License, or (at your option) any later version.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Library General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Library General Public
+ *    License along with this library; if not, write to the Free
+ *    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach me by email to
+ *    100741.1151@compuserve.com
+ */
+
+#ifdef LINUX
+
+#include <sys/stream.h>
+#include <sys/stropts.h>	/* streams config symbols are here */
+#include <sys/poll.h>		/* usr structs */
+
+/*
+ * In head.c
+ */
+extern int
+lis_strputpmsg(struct inode *i, struct file *fp, 
+	       void *ctlp, void *datp, int band, int flags) ;
+extern int
+lis_strgetpmsg(struct inode *i, struct file *fp, 
+	       void *ctlp, void *datp, int *bandp, int *flagsp,
+	       int doit) ;
+
+/*
+ * In poll.c
+ */
+extern int	lis_poll(struct poll *fds, int nfds, int time_out) ;
+
+
+
+/*  -------------------------------------------------------------------  */
+/* sys_poll -  poll() syscall entry point
+ *
+ * STATUS: complete, tested
+ */
+asmlinkage int
+sys_poll(void *ubuff, ulong n, int tmout)
+{
+    return(lis_poll((struct poll *) ubuff, n, tmout)) ;
+
+}/*lis_syspoll*/
+
+
+/*  -------------------------------------------------------------------  */
+/* sys_putpmsg -  putpmsg syscall entry point
+ *
+ * STATUS: complete, tested
+ */
+asmlinkage int
+sys_putpmsg(int fd,
+	    struct strbuf *ctl,
+	    struct strbuf *dat,
+	    int band,
+	    int flags)
+{
+    struct file		* file;
+    struct inode	* inode;
+
+    /*
+     * The following checks are patterned after sys_write
+     */
+    if (fd>=NR_OPEN || !(file=current->files->fd[fd]) || !(inode=file->f_inode))
+	    return -EBADF;
+    if (!(file->f_mode & 2))
+	    return -EBADF;
+    if (!file->f_op || !file->f_op->write)
+	    return -EINVAL;
+
+    return(lis_strputpmsg(inode,file,ctl,dat,band,flags));
+
+}/*sys_putpmsg*/
+
+/*  -------------------------------------------------------------------  */
+/* sys_getpmsg -  getpmsg syscall entry point
+ *
+ * STATUS: complete, tested
+ */
+asmlinkage int
+sys_getpmsg(int fd,
+	    struct strbuf *ctl,
+	    struct strbuf *dat,
+	    int *bandp,
+	    int *flagsp)
+{
+    struct file		* file;
+    struct inode	* inode;
+
+    /*
+     * The following checks are patterned after sys_read
+     */
+    if (fd>=NR_OPEN || !(file=current->files->fd[fd]) || !(inode=file->f_inode))
+	    return -EBADF;
+    if (!(file->f_mode & 1))
+	    return -EBADF;
+    if (!file->f_op || !file->f_op->read)
+	    return -EINVAL;
+
+    return(lis_strgetpmsg(inode,file,ctl,dat,bandp,flagsp,1));
+
+}/*sys_getpmsg*/
+
+
+#endif				/* LINUX */
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/syscalls_libc.c /usr/src/linux/drivers/streams/LiS/head/syscalls_libc.c
--- debug/drivers/streams/LiS/head/syscalls_libc.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/syscalls_libc.c	Mon Dec 16 16:36:38 1996
@@ -0,0 +1,16 @@
+
+#define __LIBRARY__
+#include <linux/unistd.h>
+
+inline _syscall4(int,putmsg,int,fd,void *,ctl,void *,data,int,flags)
+
+inline _syscall5(int,putpmsg,int,fd,void *,ctl,void *,data,int,band,int,flags)
+
+inline _syscall4(int,getmsg,int,fd,void *,ctl,void *,data,int *,flags)
+
+inline _syscall5(int,getpmsg,int,fd,void *,ctl,void *,data,int *,band,int,flags)
+
+inline _syscall3(int,poll,void *,fds,int,nfds,int,timeout)
+
+
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/test.c /usr/src/linux/drivers/streams/LiS/head/test.c
--- debug/drivers/streams/LiS/head/test.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/test.c	Mon Dec 16 16:36:38 1996
@@ -0,0 +1,79 @@
+#include <stdio.h>
+#include <string.h>
+#include "stream.h"
+
+void DumpMsg(char *v, mblk_t *bp)
+{
+    printf("Message %s (addr %X):\n", v, bp);
+    while (bp)
+    {
+        printf("\tBlock size: %d, length %d, refcnt %d  %.*s\n",
+		bp->b_datap->db_lim - bp->b_datap->db_base,
+		bp->b_wptr - bp->b_rptr,
+		bp->b_datap->db_ref,
+		bp->b_wptr - bp->b_rptr,
+		bp->b_rptr);
+	bp = bp->b_cont;
+    }
+}
+
+#define dumpmsg(m)	DumpMsg(#m, m)
+
+extern void ShowStrStats(void);
+
+void my_free(char *data)
+{
+    printf("In my_free(%X:%s)\n", data, data);
+}
+
+void CopyIn(mblk_t *bp, char *msg)
+{
+    while (*msg)
+        *bp->b_wptr++ = *msg++;
+}
+
+int main(int argc, char *argv[])
+{
+    int i;
+    mblk_t *bp, *mp;
+    frtn_t frtn;
+    char data[10];
+    mblk_t *bp1, *bp2, *bp3;
+    bp1 = allocb(1, BPRI_HI);
+    CopyIn(bp1, "A");
+    bp2 = allocb(10, BPRI_HI);
+    CopyIn(bp2, " fat cat s");
+    bp3 = allocb(5, BPRI_HI);
+    CopyIn(bp3, "at!");
+    strcpy(data, "Hello!");
+    frtn.free_func = my_free;
+    frtn.free_arg = data;
+    linkb(bp2, bp3);
+    linkb(bp1, bp2);
+    printf("Testing adjmsg\n");
+    dumpmsg(bp1);
+    for (i = 1; i < argc; i++)
+    {
+        printf("adjmsg(%d) %s\n", atoi(argv[i]),
+		adjmsg(bp1, atoi(argv[i])) ? "OK" : "failed");
+        dumpmsg(bp1);
+        ShowStrStats();
+    }
+    bp = dupmsg(bp1);
+    mp = copymsg(bp1);
+    ShowStrStats();
+    printf("Freeing copy\n");
+    freemsg(mp);
+    ShowStrStats();
+    printf("Freeing original\n");
+    freemsg(bp1);
+    ShowStrStats();
+    printf("Freeing duplicate\n");
+    freemsg(bp);
+    ShowStrStats();
+    printf("Reclaiming memory\n");
+    strgiveback();
+    ShowStrStats();
+    return 0;
+}
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/user/config /usr/src/linux/drivers/streams/LiS/head/user/config
--- debug/drivers/streams/LiS/head/user/config	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/user/config	Mon Dec 30 11:46:51 1996
@@ -0,0 +1,39 @@
+#
+# Configuration file for STREAMS device drivers
+#
+# Driver specifications
+#
+# The clone driver has a fixed major number.  Others can be allocated
+# automatically.
+#
+#	name		prefix	major	n-minors
+driver	clone-drvr	clone_	32
+driver	loop-around	loop_	*
+driver	mini-mux	mux_	*
+driver	printk		printk_	*
+
+#
+# Pushable module specifications
+#
+#	name		prefix
+module	relay		relay_
+module	relay2		relay2_
+
+#
+# Node specifications
+#
+#	name		type	perm	major		minor
+node	loop.1		c	0644	loop-around	1
+node	loop.2		c	*	loop-around	2
+node	loop_clone	c	*	clone-drvr	loop-around
+node	mux_clone	c	*	clone-drvr	mini-mux
+node	clone_drvr	c	*	clone-drvr	0
+node	printk		c	*	printk		0
+
+#
+# Device specifications
+#
+#	drvr-name	unit  port nports share	IRQ     mem M-size DMA1 DMA2
+device	loop-around	   1 0x310     16     S	 10 0xD0000 0x4000
+device	loop-around	   2 0	        0     S	 10 	  0	 0
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/user/linuxio.h /usr/src/linux/drivers/streams/LiS/head/user/linuxio.h
--- debug/drivers/streams/LiS/head/user/linuxio.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/user/linuxio.h	Mon Dec 16 16:36:39 1996
@@ -0,0 +1,90 @@
+#ifndef _USRIO_H_
+#define _USRIO_H_
+/************************************************************************
+*                        Linux I/O Functions				*
+*************************************************************************
+*									*
+* This file is included by strtst.c if -DLINUX is set.  The strtst	*
+* program is built for use in a user-level debugging context in which	*
+* the test program (strtst.o) is linked in with the streams package	*
+* itself plus a "user" I/O library.  When -DLINUX is set then the	*
+* test program is a user level program running against the streams	*
+* package in the kernel.  We have to change some names and the like	*
+* to make this all work out.						*
+*									*
+************************************************************************/
+
+#ifndef _SYS_POLL_H
+#include <sys/poll.h>
+#endif
+
+#ifndef NULL
+#define	NULL		( (void *) 0 )
+#endif
+
+#ifndef _IOW
+#define _IOW(x,y,t)     (((((int)sizeof(t))&0xFFFF)<<16)|(x<<8)|y)
+#endif
+
+
+#define user_stat	stat
+#define user_fstat	fstat
+#define user_mknod	mknod
+#define user_open	open
+#define user_close	close
+#define user_read	read
+#define user_write	write
+#define user_ioctl	ioctl
+#define user_fcntl	fcntl
+#define user_putpmsg	putpmsg
+#define user_getpmsg	getpmsg
+#define user_poll	poll
+#define user_set_ptr	set_ptr
+#define user_get_ptr	get_ptr
+#define user_print_dir	print_dir
+#define user_opendir	opendir
+#define user_readdir	readdir
+#define user_closedir	closedir
+#define user_rewinddir	rewinddir
+
+
+
+/************************************************************************
+*                         fcntl Types                                   *
+*************************************************************************
+*									*
+* The following codes will be defined here for calls to fcntl if they	*
+* have not been defined elsewhere first.  These are SVR4 command codes	*
+* that are not included in every environment's fcntl.h.			*
+*									*
+************************************************************************/
+
+#ifndef F_ALLOCSP
+#define F_ALLOCSP	10
+#endif
+#ifndef F_FREESP
+#define F_FREESP	11
+#endif
+#ifndef F_RSETLK
+#define F_RSETLK	20
+#endif
+#ifndef F_RGETLK
+#define F_RGETLK	21
+#endif
+#ifndef F_RSETLKW
+#define F_RSETLKW	22
+#endif
+#ifndef F_GETOWN
+#define F_GETOWN	23
+#endif
+#ifndef F_SETOWN
+#define F_SETOWN	24
+#endif
+#ifndef F_CHKFL
+#define F_CHKFL		99			/* completely bogus value */
+#endif
+
+
+
+
+#endif /* _USRIO_H_ */
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/user/makefile /usr/src/linux/drivers/streams/LiS/head/user/makefile
--- debug/drivers/streams/LiS/head/user/makefile	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/user/makefile	Mon Dec 30 11:51:40 1996
@@ -0,0 +1,97 @@
+#
+# Environment of USER means the intent is to run the code at user level 
+# for testing.
+#
+ENV	= -DUSER
+SRC	= ..
+LIBDIR	= .
+TMP	= /tmp
+GNU	= -DINLINE=inline
+GNU	= -DINLINE=""
+OG	= -O3 -pg
+OG	= -g
+OG	= -O3
+CCOPT	= $(OG) $(GNU) -DSAFE -DANSI -ansi -Wall -Wshadow -Wstrict-prototypes \
+	  -DDIRECT_USER -I.
+DEBUG_MASK	= -DDEBUG_MASK=0x0FFFFFFF
+DEBUG_MASK	= 
+UTILDIR	= ../../util
+UTILOBJ	= $(UTILDIR)/linux
+DRVRDIR	= $(TOPDIR)/drivers/str/user
+DRVRS	= $(DRVRDIR)/loop.o $(DRVRDIR)/relay.o $(DRVRDIR)/clone.o \
+	    $(DRVRDIR)/minimux.o $(DRVRDIR)/printk.o
+
+#
+# Initial targets
+#
+all:	strms drivers strtst timetst tags
+
+drivers:	
+	cd $(DRVRDIR);make
+
+include $(SRC)/Makefile.standalone
+
+clean:	
+	rm -f *.o *.a strtst timetst tags
+
+
+strtst:	strtst.o usrio.o modconf.o makenodes.o $(LIB) $(DRVRS)
+	$(CC) -o $(TMP)/$@ strtst.o usrio.o		\
+			modconf.o makenodes.o $(DRVRS) $(LIB)
+	mv $(TMP)/$@ .
+	
+strtst.o:	$(UTILDIR)/strtst.c 
+	$(CC) -c -o $(TMP)/$@ $(UTILDIR)/strtst.c
+	mv $(TMP)/$@ .
+
+strtst.E:	$(UTILDIR)/strtst.c 
+	$(CC) -c -E $(UTILDIR)/strtst.c >strtst.E
+
+timetst:	timetst.o usrio.o modconf.o makenodes.o $(LIB) $(DRVRS)
+	$(CC) -o $(TMP)/$@ timetst.o usrio.o		\
+			modconf.o makenodes.o $(DRVRS) $(LIB)
+	mv $(TMP)/$@ .
+
+timetst.o:	$(UTILDIR)/timetst.c
+	$(CC) -c -o $(TMP)/$@ $(UTILDIR)/timetst.c
+	mv $(TMP)/$@ .
+
+usrio.d:	usrio.c
+	$(CPP) -M usrio.c >usrio.d
+
+include usrio.d
+
+usrio.o:
+	$(CC) -c -o $(TMP)/$@ usrio.c
+	mv $(TMP)/$@ .
+
+#
+# module configuration is compiled here so that is can be customized
+# for each installation
+#
+modconf.o:	modconf.c
+	$(CC) -c -o $(TMP)/$@ modconf.c
+	mv $(TMP)/$@ .
+
+#
+# this file is built by the strconf utility program
+#
+modconf.c:	config $(UTILOBJ)/strconf
+	$(UTILOBJ)/strconf -rmake_nodes -Muser_mknod config
+
+#
+# This file contains a subroutine that will make the file nodes.
+#
+makenodes.o:	makenodes.c
+	$(CC) -c -o $(TMP)/$@ makenodes.c
+	mv $(TMP)/$@ .
+
+#
+# this file is built by the strconf utility program
+#
+makenodes.c:	config $(UTILOBJ)/strconf
+	$(UTILOBJ)/strconf	-rmake_nodes -Muser_mknod config
+
+
+tags:	usrio.h usrio.c $(UTILDIR)/strtst.c
+	ctags usrio.h usrio.c $(UTILDIR)/strtst.c
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/user/port.c /usr/src/linux/drivers/streams/LiS/head/user/port.c
--- debug/drivers/streams/LiS/head/user/port.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/user/port.c	Mon Dec 30 11:45:42 1996
@@ -0,0 +1,669 @@
+/************************************************************************
+*                         Porting Routines                              *
+*************************************************************************
+*									*
+* This file contains the routines with the "port_" prefix.  These	*
+* routines are tailored for the USER environment.			*
+*									*
+* Author:	David Grothe	<dave@gcom.com>				*
+*									*
+************************************************************************/
+
+#include <sys/stream.h>
+#include <errno.h>
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <string.h>
+#include <malloc.h>
+#include <time.h>
+
+#include "usrio.h"
+
+/************************************************************************
+*                        Data Structures                                *
+************************************************************************/
+
+
+/************************************************************************
+*                         Global Storage                                *
+************************************************************************/
+
+
+/************************************************************************
+*                           Prototypes                                  *
+************************************************************************/
+
+extern inode_t		*user_inode_of_file(int fd) ;	/* in usrio.c */
+extern inode_t		*user_inode(dev_t dev) ;
+
+
+
+
+
+/************************************************************************
+*                           port_printf                                 *
+*************************************************************************
+*									*
+* This is the printf fuction.  Return is always zero.			*
+*									*
+************************************************************************/
+int	port_printf(char *fmt, ...)
+{
+    va_list args;
+
+    va_start (args, fmt);
+    vprintf (fmt, args);
+    va_end (args);
+
+    return(0) ;
+
+} /* port_printf */
+
+/************************************************************************
+*                            port_panic                                 *
+*************************************************************************
+*									*
+* This is the panic routine.  It is not supposed to return.		*
+*									*
+************************************************************************/
+void	port_panic(char *msg)
+{
+    port_printf("\nPANIC: %s\n", msg) ;
+    exit(1) ;
+
+} /* port_panic */
+
+/************************************************************************
+*                           port_malloc                                 *
+*************************************************************************
+*									*
+* Allocate nbytes of memory and return a pointer to it.			*
+*									*
+************************************************************************/
+void	*port_malloc(int nbytes, int class)
+{
+    (void) class ;			/* memory class */
+
+    return(malloc(nbytes)) ;
+
+} /* port_malloc */
+
+/************************************************************************
+*                           port_free                                   *
+*************************************************************************
+*									*
+* Free a block of memory allocated by port_malloc.			*
+*									*
+************************************************************************/
+void	port_free(void *ptr)
+{
+    free(ptr) ;
+
+} /* port_free */
+
+/************************************************************************
+*                          port_print_mem                               *
+*************************************************************************
+*									*
+* Walk the memory link list and print out each element.			*
+*									*
+************************************************************************/
+void	port_print_mem(void)
+{
+    lis_print_mem() ;
+
+} /* port_print_mem */
+
+/************************************************************************
+*                             port_memcpy                               *
+*************************************************************************
+*									*
+* Copy nbytes from src to dst.						*
+*									*
+************************************************************************/
+void	port_memcpy(void *dst, void *src, int nbytes)
+{
+    memcpy(dst, src, nbytes) ;
+
+} /* port_memcpy */
+
+/************************************************************************
+*                            port_verify_area                           *
+*************************************************************************
+*									*
+* Ensure that the user area pointed to by usr_addr can be accessed	*
+* for reading or writing for lgth bytes.				*
+*									*
+* Return negative for failure.  The absolute value of the return code	*
+* is an "errno" value.  Return 0 for success.				*
+*									*
+************************************************************************/
+int	port_verify_area(struct file *f, int rd_wr_fcn,
+			 const void *usr_addr, int lgth)
+{
+    (void) f ;
+    (void) usr_addr ;
+    (void) lgth ;
+
+    switch (rd_wr_fcn)
+    {
+    case VERIFY_READ:
+	if (   usr_addr == NULL
+	    || lgth > 0x10000
+	   )
+	    return(-EFAULT) ;
+
+	return(0) ;				/* OK */
+    case VERIFY_WRITE:
+	if (   usr_addr == NULL
+	    || lgth > 0x10000
+	   )
+	    return(-EFAULT) ;
+
+	return(0) ;				/* OK */
+    default:
+	return(-1) ;				/* bad fcn code */
+    }
+
+} /* port_verify_area */
+
+/************************************************************************
+*                          port_memcpy_fromfs                           *
+*************************************************************************
+*									*
+* Copy len bytes from user-space memory at ubuf into kernel space	*
+* memory at kbuf.							*
+*									*
+* When porting to a real O/S environment, this routine will have to do	*
+* more than what is coded here.						*
+*									*
+* Caller must guarantee that user addresses are valid before calling	*
+* this routine.								*
+*									*
+************************************************************************/
+void	port_memcpy_fromfs(struct file *f, void *kbuf,
+			    const void *ubuf, int len)
+{
+    (void) f ;
+    memcpy(kbuf, ubuf, len) ;
+
+} /* port_memcpy_fromfs */
+
+/************************************************************************
+*                           port_memcpy_tofs                            *
+*************************************************************************
+*									*
+* Copy len bytes from kernel-space memory at kbuf into user space	*
+* memory at ubuf.							*
+*									*
+* When porting to a real O/S environment, this routine will have to do	*
+* more than what is coded here.						*
+*									*
+* Caller must guarantee that user addresses are valid before calling	*
+* this routine.								*
+*									*
+************************************************************************/
+void	port_memcpy_tofs(struct file *f, const void *kbuf, void *ubuf, int len)
+{
+    (void) f ;
+    memcpy(ubuf, kbuf, len) ;
+
+} /* port_memcpy_tofs */
+
+/************************************************************************
+*                          port_get_fs_byte                             *
+*************************************************************************
+*									*
+* Get a byte from user space and return it.				*
+*									*
+************************************************************************/
+int	port_get_fs_byte(struct file *f, const void *uaddr)
+{
+    char	c ;
+
+    if (port_verify_area(f, VERIFY_READ, uaddr, 1) < 0) return(0) ;
+
+    port_memcpy_fromfs(f, &c, uaddr, 1) ;
+    return( (int) c ) ;
+
+} /* port_get_fs_byte */
+
+/************************************************************************
+*                            port_splstr                                *
+*************************************************************************
+*									*
+* Disable interrupts to protect streams queue processing.  Return	*
+* old CPU state through the pointer save_state.				*
+*									*
+* For user level testing, this is a dummy routine.			*
+*									*
+************************************************************************/
+void	port_splstr(int *save_state)
+{
+    (void) save_state ;
+
+} /* port_splstr */
+
+/************************************************************************
+*                             port_splx                                 *
+*************************************************************************
+*									*
+* Restore the CPU interrupt state according to the saved state		*
+* in the integer pointed to by saved_state.				*
+*									*
+************************************************************************/
+void	port_splx(int *saved_state)
+{
+    (void) saved_state ;
+
+} /* port_splx */
+
+/************************************************************************
+*                             port_spl0                                 *
+*************************************************************************
+*									*
+* Unconditionally enable interrupts and return the previous CPU state	*
+* in the integer pointed to by save_state.				*
+*									*
+************************************************************************/
+void	port_spl0(int *save_state)
+{
+    (void) save_state ;
+
+} /* port_spl0 */
+
+/************************************************************************
+*                          port_sem_P                                   *
+*************************************************************************
+*									*
+* Perform a 'P' operation on the semaphore.				*
+*									*
+* This is a dummy for user-level testing.				*
+*									*
+************************************************************************/
+int	port_sem_P(struct semaphore *sem_addr)
+{
+    int		flags ;
+
+    SPLSTR(flags) ;
+    if (sem_addr->sem_count > 0)
+    {					/* semaphore is available */
+	sem_addr->sem_count-- ;		/* acquire it */
+	SPLX(flags) ;
+	return(0) ;
+    }
+
+    do
+    {
+	SPLX(flags) ;			/* open interrupt window */
+	SPLSTR(flags) ;
+
+	port_announce_time(1) ;		/* make time appear to pass */
+	lis_runqueues() ;		/* run streams scheduler */
+    }
+    while (sem_addr->sem_count <= 0) ;	/* exit when semaphore available */
+
+    sem_addr->sem_count-- ;		/* acquire it */
+    SPLX(flags) ;
+    return(0) ;
+
+} /* port_sem_P */
+
+/************************************************************************
+*                          port_sem_V                                   *
+*************************************************************************
+*									*
+* Perform a 'V' operation on the semaphore.				*
+*									*
+* This is a dummy for user-level testing.				*
+*									*
+************************************************************************/
+void	port_sem_V(struct semaphore *sem_addr)
+{
+    ++sem_addr->sem_count ;		/* give up semaphore */
+
+} /* port_sem_V */
+
+/************************************************************************
+*                            port_sem_init                              *
+*************************************************************************
+*									*
+* Initialize the semaphore.						*
+*									*
+* This is a dummy for user-level testing.				*
+*									*
+************************************************************************/
+void	port_sem_init(struct semaphore *sem_addr, int counter)
+{
+    sem_addr->sem_count = counter ;
+
+} /* port_sem_init */
+
+/************************************************************************
+*                            port_sem_destroy                           *
+*************************************************************************
+*									*
+* De-initialize the semaphore.						*
+*									*
+* This is a dummy for user-level testing.				*
+*									*
+************************************************************************/
+void	port_sem_destroy(struct semaphore *sem_addr)
+{
+    memset(sem_addr, 0, sizeof(*sem_addr)) ;
+
+} /* port_sem_destroy */
+
+/************************************************************************
+*                          port_get_uid                                 *
+*************************************************************************
+*									*
+* Get user id.								*
+*									*
+************************************************************************/
+int	 port_get_uid(struct file *f)
+{
+    (void) f ;
+    return(204) ;
+
+} /* port_get_uid */
+
+/************************************************************************
+*                           port_get_gid                                *
+*************************************************************************
+*									*
+* Get group id.								*
+*									*
+************************************************************************/
+int	 port_get_gid(struct file *f)
+{
+    (void) f ;
+    return(145) ;
+
+} /* port_get_gid */
+
+/************************************************************************
+*                          port_get_euid                                *
+*************************************************************************
+*									*
+* Get effective user id.						*
+*									*
+************************************************************************/
+int	 port_get_euid(struct file *f)
+{
+    (void) f ;
+    return(205) ;
+
+} /* port_get_euid */
+
+/************************************************************************
+*                           port_get_egid                               *
+*************************************************************************
+*									*
+* Get effective group id.						*
+*									*
+************************************************************************/
+int	 port_get_egid(struct file *f)
+{
+    (void) f ;
+    return(146) ;
+
+} /* port_get_egid */
+
+/************************************************************************
+*                             port_get_pgrp                             *
+*************************************************************************
+*									*
+* Get process group id.							*
+*									*
+************************************************************************/
+int	 port_get_pgrp(struct file *f)
+{
+    (void) f ;
+    return(33) ;
+
+} /* port_get_pgrp */
+
+/************************************************************************
+*                              port_get_pid                             *
+*************************************************************************
+*									*
+* Get process id.							*
+*									*
+************************************************************************/
+int	 port_get_pid(struct file *f)
+{
+    (void) f ;
+    return(19) ;
+
+} /* port_get_pid */
+
+/************************************************************************
+*                             port_suser                                *
+*************************************************************************
+*									*
+* Return true if we are running as the super user, false otherwise.	*
+*									*
+************************************************************************/
+int	port_suser(struct file *f)
+{
+    return(port_get_uid(f) == 0) ;
+
+} /* port_suser */
+
+/************************************************************************
+*                           port_kill_proc                              *
+*************************************************************************
+*									*
+* Send the signal 'sig' to the process 'pid'.  'priv' is true if the	*
+* user is super-user.  Return is negative error number or zero for	*
+* success.								*
+*									*
+************************************************************************/
+int	port_kill_proc(int pid, int sig, int priv)
+{
+    (void) pid ;			/* compiler happiness */
+    (void) sig ;			/* compiler happiness */
+    (void) priv ;			/* compiler happiness */
+    return(0) ;
+
+} /* port_kill_proc */
+
+/************************************************************************
+*                            port_kill_pg                               *
+*************************************************************************
+*									*
+* Send the signal 'sig' to the process group 'pgrp'.  'priv' is true	*
+* if the user is super-user.  Return is negative error number or	*
+* zero for success.							*
+*									*
+************************************************************************/
+int	port_kill_pg(int pgrp, int sig, int priv)
+{
+    (void) pgrp ;			/* compiler happiness */
+    (void) sig ;			/* compiler happiness */
+    (void) priv ;			/* compiler happiness */
+    return(0) ;
+
+} /* port_kill_pg */
+
+/************************************************************************
+*                         port_fd_to_str				*
+*************************************************************************
+*									*
+* Given in integer file desriptor, fd, return a pointer to the stream	*
+* head structure associated with the file.				*
+*									*
+************************************************************************/
+stdata_t	*port_fd_to_str(int fd)
+{
+    inode_t	*ip ;
+
+    ip = user_inode_of_file(fd) ;
+    if (ip == NULL) return(NULL) ;
+
+    return(ip->i_str) ;		/* return ptr to sdtata struct from inode */
+
+} /* port_fd_to_str */
+
+/************************************************************************
+*                            port_session                               *
+*************************************************************************
+*									*
+* Return the session number of the current process.  I do not understand*
+* what this is supposed to be and it may be superfluous.		*
+*									*
+************************************************************************/
+int	port_session(struct file *f)
+{
+    return(port_get_pid(f)) ;
+
+} /* port_session */
+
+/************************************************************************
+*                         port_setqsched                                *
+*************************************************************************
+*									*
+* This routine is supposed to schedule the queues to be run.  In the	*
+* case of the user-mode library we just run the queues right here.	*
+*									*
+************************************************************************/
+void	port_setqsched(void)
+{
+    lis_run_queues() ;
+
+} /* port_setqsched */
+
+/************************************************************************
+*                            port_pick_inode                            *
+*************************************************************************
+*									*
+* This routine is called from stropen().				*
+*									*
+* From the two inodes passed in, choose one of them to return to the	*
+* caller and "dispose" of the other one.				*
+*									*
+* 'old' is the inode passed into stropen by sys_open, 'new' is an	*
+* inode with the same i_rdev that was allocated to a previously opened	*
+* stream (so it's really the "older" of the two).			*
+*									*
+* Alternatively, 'old' is the inode passed to stropen for a clone open	*
+* and 'new' is NULL.  In this case we need to allocate a new inode,	*
+* transfer some attributes into it and return a pointer to it.  We are	*
+* done with the 'old' inode since it was the one that pointed to the	*
+* /dev/clone and the new one points to the actual stream device opened.	*
+*									*
+************************************************************************/
+struct inode *port_pick_inode(struct inode *old, struct inode *new, dev_t dev)
+{
+    file_t	*fp ;
+    dir_t	*dp ;
+    char	 name_buf[MAXNAMLEN];
+    int		 rslt ;
+    int		 cloned = 0 ;
+
+    if (new == NULL)				/* no new inode */
+    {						/* may need to make one */
+	if (old != NULL && old->i_dev == dev)
+	    return(old) ;			/* use old one */
+
+	new = user_inode(dev) ;			/* ptr to inode */
+	if (new == NULL)			/* couldn't allocate one */
+	    goto free_old ;			/* old is wrong dev */
+
+	ULOCK_INO(new) ;
+	if (old != NULL)			/* new is cloned */
+	{
+	    cloned       = 1 ;
+	    new->i_str   = old->i_str ;		/* xfer stream ptr */
+	    new->i_mode  = old->i_mode ;	/* inherit mode */
+	    new->i_ftime = old->i_ftime;
+	    new->i_ctime = old->i_ctime;
+	    new->i_atime = old->i_atime;
+	    new->i_mtime = old->i_mtime;
+	    goto free_old ;
+	}
+	else
+	{
+	    new->i_ftime = time(NULL);
+	    new->i_ctime = new->i_ftime;
+	    new->i_atime = new->i_ftime;
+	    new->i_mtime = new->i_ftime;
+	}
+    }
+
+    /*
+     * We have both old and new.  Use the "new" one and free up the
+     * "old" one.
+     */
+
+free_old:					/* free old and return new */
+    if (old != NULL)
+	fp = user_file_of_inode(old) ;
+    else
+	fp = user_alloc_file() ;
+
+    if (fp != NULL)
+    {						/* needs a name */
+	dp = user_search_dir_inode(new) ;
+	if (dp != NULL)
+	    strncpy(name_buf, dp->d_name, sizeof(name_buf)) ;
+	else
+	    sprintf(name_buf, "%s%s",
+		    lis_strm_name(new->i_str),
+		    lis_maj_min_name(new->i_str)) ;
+
+	if (fp->f_name != NULL)			/* free any old name */
+	    FREE(fp->f_name) ;
+
+	fp->f_name = ALLOCF(strlen(name_buf) + 1, "clone-name ") ;
+	if (fp->f_name == NULL)
+	    fp->f_name = "Anonymous-File" ;
+	else
+	    strcpy(fp->f_name, name_buf) ;	/* save new name */
+
+	if (dp == NULL)				/* no directory entry */
+	{
+	    rslt = user_add_dir_entry(name_buf, new->i_mode, dev) ;
+	    if (rslt != 0)
+	    {
+		printk("port_pick_inode: error %d adding '%s' to directory\n",
+			rslt, name_buf) ;
+	    }
+	}
+
+	if ( (dp = user_search_dir(name_buf)) == NULL)
+	{
+	    printk("port_pick_inode: could not find '%s' in directory\n",
+		    name_buf) ;
+	}
+	else
+	{
+	    new->i_inum = dp->d_inum  ;		/* assign inode nr */
+	    dp->d_refcnt++ ;
+	}
+    }
+
+    if (old != NULL)
+    {
+	old->i_use-- ;
+	old->i_str = NULL ;
+	if (old->i_use == 0)
+	    lis_mark_mem(old, "unused inode: ", major(old->i_dev)) ;
+    }
+
+    return(new) ;				/* use new one */
+
+} /* port_pick_inode */
+
+/************************************************************************
+*                         port_select_wakeup                            *
+*************************************************************************
+*									*
+* A dummy for select mechanism (which we don't implement).		*
+*									*
+************************************************************************/
+void port_select_wakeup(stdata_t *hd)
+{
+} /* port_select_wakeup */
Binary files debug/drivers/streams/LiS/head/user/strtst and /usr/src/linux/drivers/streams/LiS/head/user/strtst differ
Binary files debug/drivers/streams/LiS/head/user/timetst and /usr/src/linux/drivers/streams/LiS/head/user/timetst differ
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/user/usrio.c /usr/src/linux/drivers/streams/LiS/head/user/usrio.c
--- debug/drivers/streams/LiS/head/user/usrio.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/user/usrio.c	Mon Dec 30 10:04:58 1996
@@ -0,0 +1,1720 @@
+/************************************************************************
+*                         User I/O Routines                             *
+*************************************************************************
+*									*
+* This file contains I/O routines implementing a simple in-memory	*
+* user-level I/O system.  The routines are:				*
+*									*
+*		user_open()						*
+*		user_close()						*
+*		user_read()						*
+*		user_write()						*
+*		user_ioctl()						*
+*		user_fcntl()						*
+*		user_mknod()						*
+*		user_getmsg()						*
+*		user_getpmsg()						*
+*		user_putmsg()						*
+*		user_putpmsg()						*
+*		user_poll()						*
+*		user_get_ptr()						*
+*		user_set_ptr()						*
+*									*
+*		user_opendir()						*
+*		user_readdir()						*
+*		user_closedir()						*
+*		user_rewinddir() 					*
+*									*
+*		user_stat()						*
+*		user_fstat()						*
+*									*
+* Author:	David Grothe	<dave@gcom.com>				*
+*									*
+************************************************************************/
+
+#include <sys/stream.h>
+#include <errno.h>
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <sys/fcntl.h>
+#include <string.h>
+#include <malloc.h>
+#include <time.h>
+
+#include "usrio.h"
+
+
+/************************************************************************
+*                         Global Storage                                *
+************************************************************************/
+
+#if 0
+
+static dir_t		 directory[NDIR] ;	/* pseudo-directory */
+static maj_t		 majors[NMAJOR] ;	/* major device table */
+static file_t		*files ;		/* file descriptors */
+static inode_t		*inodes ;		/* head of list of inodes */
+static int		 last_fd ;		/* last used file number */
+static file_t	       **file_tbl ;		/* ptrs to file descrs */
+static int		 file_tbl_size ;	/* # entries in file tbl */
+static int		 user_next_inum = 10;	/* next inode number */
+
+#else
+
+dir_t		 directory[NDIR] ;	/* pseudo-directory */
+maj_t		 majors[NMAJOR] ;	/* major device table */
+file_t		*files ;		/* file descriptors */
+inode_t		*inodes ;		/* head of list of inodes */
+int		 last_fd ;		/* last used file number */
+file_t	       **file_tbl ;		/* ptrs to file descrs */
+int		 file_tbl_size ;	/* # entries in file tbl */
+int		 user_next_inum = 10;	/* next inode number */
+
+#endif
+
+/************************************************************************
+*                           Prototypes                                  *
+************************************************************************/
+dir_t		*user_search_dir(char *name) ;
+inode_t		*user_inode(dev_t dev) ;
+void		 user_print_inode(inode_t *ip) ;
+void		 user_print_dir_entry(dir_t *dp, int optns) ;
+
+
+/************************************************************************
+*                             user_mknod                                *
+*************************************************************************
+*									*
+* Add a name to the directory.  Allocate an inode and fill in the	*
+* major and minor device numbers.					*
+*									*
+* Return 0 for success, negative for error.				*
+*									*
+************************************************************************/
+int	user_mknod(char *name, int mode, dev_t dev)
+{
+    int		 d ;
+    int		 m ;
+    inode_t	*ip;
+    dir_t	*dp ;
+
+    if ( user_search_dir(name) != NULL )
+	return(-EEXIST) ;			/* entry exists already */
+
+    if ((m = major(dev)) > NMAJOR) return(-EBADF) ;	/* range check major */
+    if (lis_fstr_sw[m].f_str == NULL) return(-ENXIO) ;	/* ensure streamtab */
+
+    for (d = 1; d < NDIR; d++)
+    {
+	if ((dp = &directory[d])->d_name == NULL)	/* available dir slot */
+	{
+	    memset(dp, 0, sizeof(dir_t)) ;
+	    dp->d_name  = ALLOCF(strlen(name) + 1, "directory/node name ") ;
+	    if (dp->d_name == NULL) return(-ENOMEM) ;
+	    dp->d_dev   = dev ;
+	    dp->d_mode  = mode ;
+	    strcpy(dp->d_name, name) ;
+	    dp->d_ftime = time( NULL ) ;	/* time created */
+	    dp->d_inode = 0;
+	    dp->d_ctime = dp->d_ftime ;
+	    dp->d_mtime = dp->d_ftime ;
+	    dp->d_atime = dp->d_ftime ;
+	    dp->d_refcnt= 1 ;
+    
+	    ip = user_inode(dev);
+	    if (ip == NULL)				/* out of inodes */
+	    {
+	    	FREE(dp->d_name);
+	    	dp->d_name = NULL;
+		return(-EMFILE) ;
+	    }
+	    ip->i_ftime = time(NULL) ;
+	    ip->i_ctime = ip->i_ftime ;
+	    ip->i_mtime = ip->i_ftime ;
+	    ip->i_atime = ip->i_ftime ;
+	    ip->i_mode  = mode ;
+	    ip->i_flags = REFERENCE_INODE ;
+
+	    dp->d_inode = ip;
+	    if (ip->i_inum != 0)			/* inode has number */
+		dp->d_inum = ip->i_inum;
+	    else					/* give inode number */
+	    {					/* assign inode number */
+		dp->d_inum = user_next_inum++ ;
+		ip->i_inum = dp->d_inum ;
+	    }
+
+	    /*
+	     * we leave ip hanging around since we do have have a valid
+	     * inode now.  No not decrement the ip->i_use counter.
+	     * Need to unlock inode so others may use it.
+	     */
+	    ULOCK_INO(ip) ;				/* unlock inode */
+	    return(0) ;				/* success */
+	}
+    }
+
+    return(-ENFILE) ;
+
+} /* user_mknod */
+
+/************************************************************************
+*                          user_add_dir_entry                           *
+*************************************************************************
+*									*
+* Add an entry into the directory structure				*
+*									*
+************************************************************************/
+
+int	user_add_dir_entry(char *name, int mode, dev_t dev)
+{
+
+    int		 d ;
+    int		 m ;
+    dir_t	*dp ;
+
+    if ( user_search_dir(name) != NULL )
+	return(-EEXIST) ;			/* entry exists already */
+
+    if ((m = major(dev)) > NMAJOR) return(-EBADF) ;	/* range check major */
+
+    for (d = 1; d < NDIR; d++)
+    {
+	if ((dp = &directory[d])->d_name == NULL)	/* available dir slot */
+	{
+	    memset(dp, 0, sizeof(dir_t)) ;
+	    dp->d_name  = ALLOCF(strlen(name) + 1, "directory/node name ") ;
+	    if (dp->d_name == NULL) return(-ENOMEM) ;
+	    strcpy(dp->d_name, name) ;
+
+	    dp->d_dev   = dev ;
+	    dp->d_mode  = mode ;
+	    dp->d_ftime = time( NULL ) ;	/* time created */
+	    dp->d_inode = 0;
+	    dp->d_ctime = dp->d_ftime ;
+	    dp->d_mtime = dp->d_ftime ;
+	    dp->d_atime = dp->d_ftime ;
+	    dp->d_inum  = user_next_inum++ ;	/* assign inode number */
+    
+	    return(0) ;				/* success */
+	}
+    }
+    return(-ENFILE) ;
+}
+
+int
+user_remove_dir_entry(dev_t dev)
+{
+    int		 d;
+    dir_t	*dp ;
+
+    for (d = 1; d < NDIR; d++)
+    {
+	if ((dp = &directory[d])->d_dev == dev)	/* available dir slot */
+	{
+	    if (--dp->d_refcnt > 0)
+		return(0) ;			/* done enough */
+
+	    if ( dp->d_name )
+		FREE(dp->d_name);
+
+	    dp->d_name  = 0 ;
+	    dp->d_dev   = 0 ;
+	    dp->d_mode  = 0 ;
+	    dp->d_ftime = 0 ;
+	    dp->d_inode = 0 ;
+	    dp->d_ctime = 0 ;
+	    dp->d_mtime = 0 ;
+	    dp->d_atime = 0 ;
+	    dp->d_inum  = 0 ;
+    
+	    return(0) ;				/* success */
+	}
+    }
+    return(-1);
+}
+/************************************************************************
+*                          user_search_dir                              *
+*************************************************************************
+*									*
+* Search the directory for the given name, return inode number.		*
+*									*
+************************************************************************/
+dir_t	*user_search_dir(char *name)
+{
+    int		 d ;
+    dir_t	*dp ;
+
+    for (d = 0, dp = &directory[0]; d < NDIR; d++, dp++)
+    {
+	if (   dp->d_name != NULL		/* name valid */
+	    && strcmp(dp->d_name, name) == 0	/* name match */
+	   )
+	    return( dp ) ;
+    }
+
+    return(NULL) ;
+
+} /* user_search_dir */
+
+/************************************************************************
+*                        user_search_dir_inode                          *
+*************************************************************************
+*									*
+* Search the directory for an entry that has the same inumber as this	*
+* inode.								*
+*									*
+************************************************************************/
+dir_t	*user_search_dir_inode(inode_t *i)
+{
+    int		 d ;
+    dir_t	*dp ;
+
+    for (d = 0, dp = &directory[0]; d < NDIR; d++, dp++)
+    {
+	if (dp->d_refcnt != 0 && dp->d_inode == i)
+	    return( dp ) ;
+    }
+
+    return(NULL) ;
+
+} /* user_search_dir_inode */
+
+/************************************************************************
+*                             alloc_file_tbl                            *
+*************************************************************************
+*									*
+* Allocate the file table pointer array.  If one exists already then	*
+* allocate a bigger one and copy the old pointers into the new array.	*
+*									*
+* Return 1 for success, 0 for failure.					*
+*									*
+************************************************************************/
+#if 0
+static int	alloc_file_tbl(void)
+#else
+int	alloc_file_tbl(void)
+#endif
+{
+    file_t	**new_tbl ;
+    file_t	**old_tbl ;
+    int		  new_size ;
+
+    if (last_fd < file_tbl_size) return(1) ;
+
+    new_size = file_tbl_size + 32 ;
+    new_tbl = ALLOCF(new_size * sizeof(*new_tbl), "file_tbl: ") ;
+    if (new_tbl == NULL)
+	return(0) ;				/* couldn't */
+    memcpy(new_tbl, file_tbl, file_tbl_size * sizeof(*new_tbl)) ;
+    old_tbl = file_tbl ;
+    file_tbl = new_tbl ;
+    file_tbl_size = new_size ;
+    FREE(old_tbl) ;
+
+    return(1) ;
+
+} /* alloc_file_tbl */
+
+/************************************************************************
+*                           user_alloc_file                             *
+*************************************************************************
+*									*
+* Allocate a file structure and return a pointer to it.  Use an old	*
+* one if possible.							*
+*									*
+* Return with the structure locked and usage count incremented.		*
+*									*
+************************************************************************/
+file_t		*user_alloc_file(void)
+{
+    file_t	*fp ;
+
+    for (fp = files; fp != NULL; fp = fp->f_link)
+    {
+	LOCK_FILE(fp) ;					/* lock the file */
+	if (fp->f_count == 0)				/* is a free file */
+	{
+	    fp->f_count++ ;				/* incr in-use cnt */
+	    lis_mark_mem(fp, "file: ", fp->f_fdnr) ;
+	    return(fp) ;
+	}
+
+	ULOCK_FILE(fp) ;				/* unlock it */
+    }
+
+    fp = ALLOC(sizeof(*fp)) ;
+    if (fp == NULL) return(NULL) ;		/* out of memory */
+
+    memset(fp, 0, sizeof(*fp)) ;		/* clear entry */
+    fp->f_fdnr = ++last_fd ;			/* assign next file number */
+    lis_mark_mem(fp, "file: ", fp->f_fdnr) ;
+    if (!alloc_file_tbl())			/* ensure index slot */
+    {						/* ooops, couldn't  */
+	FREE(fp) ;
+	return(NULL) ;
+    }
+
+    SEM_INIT(&fp->f_sem, 1) ;			/* file lock */
+    LOCK_FILE(fp) ;				/* lock the file */
+    file_tbl[fp->f_fdnr] = fp ;			/* load index slot */
+
+    fp->f_link = files ;			/* link into list */
+    files = fp ;
+
+    fp->f_count++ ;				/* incr usage count */
+    return(fp) ;
+
+} /* user_alloc_file */
+
+/************************************************************************
+*                            user_inode                                 *
+*************************************************************************
+*									*
+* Return a pointer to an inode structure for the given device.		*
+*									*
+* We return with the inode structure locked and the use count incremented*
+*									*
+************************************************************************/
+inode_t		*user_inode(dev_t dev)
+{
+    inode_t	*ip ;
+
+    for (ip = inodes; ip != NULL; ip = ip->i_link)
+    {
+	if (ip->i_use != 0 && ip->i_dev == dev)
+	{
+	    LOCK_INO(ip) ;				/* lock it */
+	    if (ip->i_use == 0 || ip->i_dev != dev)
+	    {						/* lost race */
+		ULOCK_INO(ip) ;
+		continue ;
+	    }
+
+	    lis_mark_mem(ip, "inode: ", major(dev)) ;
+	    ip->i_use++ ;				/* incr use count */
+	    return(ip) ;				/* found the inode */
+	}
+    }
+
+    for (ip = inodes; ip != NULL; ip = ip->i_link)
+    {
+	if (ip->i_use == 0)				/* is a free inode */
+	{
+	    LOCK_INO(ip) ;				/* lock the inode */
+	    if (ip->i_use != 0)
+	    {						/* lost race */
+		ULOCK_INO(ip) ;
+		continue ;
+	    }
+
+	    ip->i_dev	= dev ;				/* set dev */
+	    ip->i_mode	= 0 ;				/* clear mode */
+	    ip->i_str	= NULL ;			/* clr strms ptr */
+	    ip->i_use++ ;				/* incr in-use cnt */
+
+	    ip->i_ftime = time(NULL) ;
+	    ip->i_ctime = ip->i_ftime ;
+	    ip->i_atime = ip->i_ftime ;
+	    ip->i_mtime = ip->i_ftime ;
+
+	    lis_mark_mem(ip, "inode: ", major(dev)) ;
+	    return(ip) ;				/* rtn w/inode locked */
+	}
+    }
+
+    ip = ALLOC(sizeof(*ip)) ;
+    if (ip == NULL) return(NULL) ;		/* out of memory */
+
+    memset(ip, 0, sizeof(*ip)) ;		/* clear entry */
+    lis_mark_mem(ip, "inode: ", major(dev)) ;
+    ip->i_dev = dev ;				/* set dev */
+    SEM_INIT(&ip->i_sem, 1) ;			/* inode lock */
+    LOCK_INO(ip) ;				/* lock the inode */
+    ip->i_link = inodes ;			/* link into list */
+    inodes = ip ;
+#if 0
+    ip->i_inum = user_next_inum++ ;		/* assign inode number */
+#endif
+
+    ip->i_ftime = time(NULL) ;
+    ip->i_ctime = ip->i_ftime ;
+    ip->i_atime = ip->i_ftime ;
+    ip->i_mtime = ip->i_ftime ;
+
+    ip->i_use++ ;				/* incr usage count */
+    return(ip) ;
+
+} /* user_inode */
+
+/************************************************************************
+*                            user_open                                  *
+*************************************************************************
+*									*
+* This is like the system open() routine.  It looks up the file in	*
+* the directory and returns a file handle for it.			*
+*									*
+************************************************************************/
+int	user_open(char *name, int flags, int mode)
+{
+    int		 m ;
+    int		 fd ;
+    int		 rslt = -1;
+    dir_t	*dp ;
+    inode_t	*ip ;
+    file_t	*fp ;
+    maj_t	*mp ;
+    dev_t	 odev ;
+    char	 name_buf[MAXNAMLEN];
+
+#define	RTN(e)		{rslt = e; goto return_point; }
+    dp = user_search_dir(name) ;		/* find name in directory */
+    if (dp == NULL)
+	return(-ENOENT) ;		/* not found */
+    ip = user_inode(dp->d_dev) ;		/* ptr to inode */
+    if (ip == NULL)				/* out of inodes */
+	return(-EMFILE) ;
+
+    /*
+     * Inode returned locked and usage count bumped up
+     */
+    ip->i_mode = dp->d_mode ;			/* file's mode */
+
+    if ( dp->d_inode == 0 )
+    {
+	dp->d_inode = ip;
+	ip->i_ctime = dp->d_ftime ;
+	ip->i_ftime = ip->i_ctime ;
+	ip->i_mtime = ip->i_ctime ;
+	ip->i_atime = ip->i_ctime ;
+    }
+
+    ip->i_inum  = dp->d_inum  ;
+
+    m = major(ip->i_dev) ;			/* get major number */
+    if (m <= 0 || m >= NMAJOR)
+    {
+	ip->i_use-- ;
+	ULOCK_INO(ip) ;
+	return(-ENXIO) ;			/* no device */
+    }
+
+    mp = &majors[m] ;				/* to maj device entry */
+
+    fp = user_alloc_file() ;
+    if (fp == NULL)
+    {
+	ip->i_use-- ;
+	ULOCK_INO(ip) ;
+	return(-EMFILE) ;			/* out of file descrs */
+    }
+
+    /*
+     * Use RTN() macro below here
+     */
+
+    fd = fp->f_fdnr ;				/* file number */
+    fp->f_flags = flags ;			/* save flags */
+    fp->f_inode = ip ;				/* tie to inode */
+    fp->f_ptr   = NULL ;			/* null out pointer */
+    fp->f_op    = mp->m_op ;			/* xfer file open/close ops */
+    fp->f_name	= ALLOCF(strlen(name) + 1, "filename 1 ") ;
+    if (fp->f_name == NULL)
+	RTN(-ENOMEM) ;
+    strcpy(fp->f_name, name) ;			/* save name */
+
+    if (fp->f_op->open != NULL)			/* is there an open proc?  */
+    {
+	odev = ip->i_dev ;			/* original device */
+	rslt = fp->f_op->open(ip, fp) ;		/* call it */
+	if (rslt < 0)				/* open error */
+	{
+	    if ( odev != ip->i_dev )
+	        ip->i_dev = odev;
+	    RTN(rslt) ;
+	}
+#if 0				/* pretend this doesn't happen */
+	if (odev != ip->i_dev)			/* clone changed dev */
+	{
+	    dev_t	 newdev ;
+	    inode_t	*newip ;
+	    newdev = ip->i_dev ;		/* new device */
+	    ip->i_dev = odev ;			/* restore old device */
+	    newip = user_inode(newdev) ;	/* find inode for new device */
+	    if (newip == NULL)
+		RTN(-EMFILE) ;			/* out of inodes */
+
+	    if (   newip->i_use == 1		/* we are 1st users */
+		|| newip->i_str == NULL		/* no stream ptr */
+	       )
+	    {
+		newip->i_str = ip->i_str ;	/* xfer stream ptr */
+		newip->i_mode = ip->i_mode ;	/* inherit mode */
+		newip->i_ftime = time(NULL);
+		newip->i_ctime = newip->i_ftime;
+		newip->i_atime = newip->i_ftime;
+		newip->i_mtime = newip->i_ftime;
+	    }
+
+	    fp->f_inode = newip ;		/* tie file to new inode */
+
+	    if (newip->i_use == 1)
+	    {					/* we are only users of inode */
+		sprintf(name_buf, "%s.%ld_%ld",
+			name, major(newdev), minor(newdev));
+
+		FREE(fp->f_name) ;		/* delete old name */
+		fp->f_name = ALLOCF(strlen(name_buf) + 1, "filename 1 ") ;
+		if (fp->f_name == NULL)
+		    RTN(-ENOMEM) ;
+
+		strcpy(fp->f_name, name_buf) ;		/* save new name */
+
+		rslt = user_add_dir_entry(name_buf, newip->i_mode, newdev) ;
+		if (rslt != 0)
+		{
+		    RTN(rslt);
+		}
+
+		if ( (dp = user_search_dir(name_buf)) == NULL)
+		{
+		    RTN(-ENOENT);
+		}
+
+		newip->i_inum = dp->d_inum  ;	/* assign inode nr */
+	    }
+
+	    dp->d_inode = newip ;
+	    /* dp->d_inum = newip->i_inum ; */
+	    /* newip->i_flags = 0; */
+
+	    if (   (--ip->i_use == 0)
+		|| (   (ip->i_use == 1)
+		    && (ip->i_flags & REFERENCE_INODE)
+		   )
+	       )
+	    {					/* give up old inode */
+		ip->i_str = NULL ;
+		if (ip->i_use == 0)
+		    lis_mark_mem(ip, "unused inode: ", major(ip->i_dev)) ;
+	    }
+	    ULOCK_INO(ip) ;
+	    ip = newip ;			/* use new inode */
+	}
+#endif
+	RTN(fd) ;				/* return file descr */
+    }
+    else					/* no open routine */
+	RTN(-ENXIO) ;
+
+return_point:
+
+    if (rslt < 0)
+    {
+	ip->i_use-- ;				/* give up inode */
+	fp->f_inode = NULL ;
+	fp->f_count-- ;				/* give up file struct */
+	if (fp->f_name != NULL)
+	{
+	    FREE(fp->f_name) ;
+	    fp->f_name = NULL ;
+	}
+    }
+
+    ULOCK_INO(ip) ;				/* unlock inode */
+    ULOCK_FILE(fp) ;				/* unlock file */
+
+    return(rslt) ;
+
+} /* user_open */
+
+/************************************************************************
+*                          user_file_of_inode                           *
+*************************************************************************
+*									*
+* Find a file that points to the given inode.				*
+*									*
+************************************************************************/
+file_t *
+user_file_of_inode(inode_t * i)
+{
+    file_t	*fp ;
+
+    for (fp = files; fp != NULL; fp = fp->f_link)
+    {
+	if (fp->f_count != 0 && fp->f_inode == i)
+	{
+	    return(fp) ;
+	}
+    }
+
+    return(NULL) ;
+
+} /* user_file_of_inode */
+
+/************************************************************************
+*                           user_inode_of_file                          *
+*************************************************************************
+*									*
+* Given a numerical file descriptor, return a pointer to the inode	*
+* structure for it, or NULL if the fd is invalid.			*
+*									*
+************************************************************************/
+inode_t	*
+user_inode_of_file(int fd)
+{
+    file_t	*fp ;
+
+    if (fd < 0 || fd > last_fd || (fp = file_tbl[fd]) == NULL)
+	return(NULL) ;			/* no device */
+
+    return(fp->f_inode) ;
+
+} /* user_inode_of_file */
+
+/************************************************************************
+*                          user_close                                   *
+*************************************************************************
+*									*
+* LIke the system close() routine.					*
+*									*
+************************************************************************/
+int	user_close(int fd)
+{
+    inode_t	*ip ;
+    file_t	*fp ;
+
+    if (fd < 0 || fd > last_fd || (fp = file_tbl[fd]) == NULL)
+	return(-ENXIO) ;			/* no device */
+
+    ip = fp->f_inode ;
+    if (ip == NULL) return(-EBADF) ;		/* file not open */
+
+    LOCK_FILE(fp) ;
+    if (fp->f_count > 0)			/* be cautious */
+	fp->f_count-- ;				/* keep use count */
+
+    if (fp->f_count == 0)			/* done with file */
+    {
+	if (fp->f_op->release != NULL)
+	    fp->f_op->release(ip, fp) ;		/* call close proc */
+
+	if (fp->f_name != NULL) FREE(fp->f_name) ;
+	fp->f_inode = NULL ;			/* done with file */
+	lis_mark_mem(fp, "unused file: ", fp->f_fdnr) ;
+    }
+
+    ULOCK_FILE(fp) ;
+
+    LOCK_INO(ip) ;
+    if (ip->i_use > 0)				/* inode usage count */
+    {
+	ip->i_use-- ;
+
+	if ( ( ip->i_use == 1 ) && ( ip->i_flags & REFERENCE_INODE ) )
+	{
+	    ip->i_str = NULL ;
+	}
+	else if (ip->i_use == 0)
+	{
+	    ip->i_str = NULL ;
+	    lis_mark_mem(ip, "unused inode: ", major(ip->i_dev)) ;
+	    if ( user_remove_dir_entry(ip->i_dev) != 0 )
+	    {
+	    	printk("user_close: directory entry was not found\n");
+	    }
+	}
+    }
+
+    ULOCK_INO(ip) ;
+
+    return(0) ;					/* success */
+
+} /* user_close */
+
+/************************************************************************
+*                            user_read                                  *
+*************************************************************************
+*									*
+* Read bytes from the file.						*
+*									*
+************************************************************************/
+int	user_read(int fd, void *buf, int nbytes)
+{
+    inode_t	*ip ;
+    file_t	*fp ;
+    int		 err ;
+
+    if (fd < 0 || fd > last_fd || (fp = file_tbl[fd]) == NULL)
+	return(-ENXIO) ;			/* no device */
+
+    ip = fp->f_inode ;
+    if (ip == NULL || fp->f_count == 0)
+	return(-EBADF) ;			/* file not open */
+
+    if (fp->f_op->read != NULL)
+	err = fp->f_op->read(ip, fp, buf, nbytes) ;
+    else
+	err = EINVAL ;				/* no ioctl routine */
+
+    return(err) ;
+
+} /* user_read */
+
+/************************************************************************
+*                            user_write                                 *
+*************************************************************************
+*									*
+* Write bytes to the file.						*
+*									*
+************************************************************************/
+int	user_write(int fd, void *buf, int nbytes)
+{
+    inode_t	*ip ;
+    file_t	*fp ;
+    int		 err ;
+
+    if (fd < 0 || fd > last_fd || (fp = file_tbl[fd]) == NULL)
+	return(-ENXIO) ;			/* no device */
+
+    ip = fp->f_inode ;
+    if (ip == NULL || fp->f_count == 0)
+	return(-EBADF) ;			/* file not open */
+
+    if (fp->f_op->write != NULL)
+	err = fp->f_op->write(ip, fp, buf, nbytes) ;
+    else
+	err = -EINVAL ;				/* no ioctl routine */
+
+    return(err) ;
+
+} /* user_write */
+
+/************************************************************************
+*                            user_ioctl                                 *
+*************************************************************************
+*									*
+* Issue an ioctl to the file.						*
+*									*
+************************************************************************/
+int	user_ioctl(int fd, int cmd, ...)
+{
+    inode_t	*ip ;
+    file_t	*fp ;
+    int		 err ;
+    long	 arg ;
+    va_list	 args ;
+
+    va_start(args, cmd) ;
+    arg = va_arg(args, long) ;
+    va_end(args) ;
+
+    if (fd < 0 || fd > last_fd || (fp = file_tbl[fd]) == NULL)
+	return(-ENXIO) ;			/* no device */
+
+    ip = fp->f_inode ;
+    if (ip == NULL || fp->f_count == 0)
+	return(-EBADF) ;			/* file not open */
+
+    if (fp->f_op->ioctl != NULL)
+	err = fp->f_op->ioctl(ip, fp, cmd, arg) ;
+    else
+	err = EINVAL ;				/* no ioctl routine */
+
+    return(err) ;
+
+} /* user_ioctl */
+
+/************************************************************************
+*                          user_fcntl                                   *
+*************************************************************************
+*									*
+* Implement SVR4 compatible fcntl functions.				*
+*									*
+************************************************************************/
+
+#define	FC_FLAGS	(O_APPEND | O_NDELAY | O_NONBLOCK | O_SYNC)
+
+int	user_fcntl(int fd, int cmd, ...)
+{
+    inode_t	*ip ;
+    file_t	*fp ;
+    int		 err ;
+    int		 argi ;
+    va_list	 args ;
+
+    if (fd < 0 || fd > last_fd || (fp = file_tbl[fd]) == NULL)
+	return(-ENXIO) ;			/* no device */
+
+    ip = fp->f_inode ;
+    if (ip == NULL || fp->f_count == 0)
+	return(-EBADF) ;			/* file not open */
+
+    va_start(args, cmd) ;
+
+    switch (cmd)
+    {
+    case F_DUPFD:
+      {
+	file_t	*xfp ;
+	file_t	*nfp = NULL ;
+	int	 nfnr = 10000 ;
+
+	argi = va_arg(args, int) ;
+	for (xfp = files; xfp != NULL; xfp = xfp->f_link)
+	{
+	    LOCK_FILE(xfp) ;			/* lock the file */
+
+	    if (   xfp->f_count == 0		/* is a free file */
+		&& xfp->f_fdnr >= argi		/* file nr geq arg */
+		&& xfp->f_fdnr < nfnr		/* smaller than b4 */
+	       )
+	    {
+		nfnr = xfp->f_fdnr ;
+		nfp = xfp ;
+	    }
+
+	    ULOCK_FILE(xfp) ;			/* unlock it */
+	}
+
+	if (nfp != NULL)			/* found one */
+	{
+	    nfp->f_count++ ;			/* incr in-use cnt */
+	    lis_mark_mem(nfp, "file: ", nfp->f_fdnr) ;
+	}
+	else					/* get one */
+	{
+	    nfp = user_alloc_file() ;
+	    if (nfp != NULL)
+		nfnr = nfp->f_fdnr ;
+	}
+
+	if (nfp == NULL)			/* couldn't do it */
+	{
+	    err = -ENXIO ;
+	    nfp->f_count-- ;			/* did not use file after all */
+	    break ;
+	}
+
+	nfp->f_name = ALLOCF(strlen(fp->f_name) + 1, "filename 2 ") ;
+	if (nfp->f_name == NULL)
+	{
+	    err = -ENOMEM ;
+	    break ;
+	}
+
+	strcpy(nfp->f_name, fp->f_name) ;	/* save name */
+
+	nfp->f_flags  = fp->f_flags ;		/* save flags */
+	nfp->f_inode  = fp->f_inode ;		/* tie to inode */
+	ip->i_use++ ;				/* another use of i-node */
+	nfp->f_op     = fp->f_op ;		/* xfer file open/close ops */
+
+	ULOCK_FILE(nfp) ;			/* unlock new file */
+
+	err = nfnr ;				/* return file number */
+      }
+      break ;
+
+    case F_GETFD:				/* close-on-exec flag */
+	err = 0 ;				/* pretend zero */
+	break ;
+
+    case F_SETFD:				/* close-on-exec flag */
+	err = 0 ;				/* pretend OK */
+	break ;
+
+    case F_GETFL:				/* get flags */
+	err = fp->f_flags & FC_FLAGS ;
+	break ;
+
+    case F_SETFL:				/* set flags */
+	argi = va_arg(args, int) ;
+	fp->f_flags &= ~FC_FLAGS ;
+	fp->f_flags |= argi & FC_FLAGS ;
+	break ;
+
+    case F_GETOWN:				/* get owner */
+	err = 0 ;				/* pretend root is owner */
+	break ;
+
+    case F_SETOWN:				/* set owner */
+	err = 0 ;				/* pretend OK */
+	break ;
+
+    case F_FREESP:				/* free space */
+    case F_SETLK:				/* set lock */
+    case F_SETLKW:
+    case F_RSETLK:
+    case F_RSETLKW:
+    case F_GETLK:
+	err = -EINVAL ;				/* disk files only */
+	break ;
+
+    default:
+    case F_CHKFL:				/* reserved */
+    case F_ALLOCSP:				/* reserved */
+	err = -EINVAL ;
+    }
+
+    va_end(args) ;
+
+    return(err) ;
+
+} /* user_fcntl */
+
+/************************************************************************
+*                           user_putpmsg                                *
+*************************************************************************
+*									*
+* Interface routine to streams putpmsg() routine.			*
+*									*
+************************************************************************/
+int	user_putpmsg(int fd, struct strbuf *ctlptr,
+			     struct strbuf *dataptr,
+			     int band,
+			     int flags)
+{
+    inode_t	*ip ;
+    file_t	*fp ;
+    int		 err ;
+
+    if (fd < 0 || fd > last_fd || (fp = file_tbl[fd]) == NULL)
+	return(-ENXIO) ;			/* no device */
+
+    ip = fp->f_inode ;
+    if (ip == NULL || fp->f_count == 0)
+	return(-EBADF) ;			/* file not open */
+
+    if (fp->f_op->putpmsg != NULL)
+	err = fp->f_op->putpmsg(ip, fp, ctlptr, dataptr, band, flags) ;
+    else
+	err = EINVAL ;				/* no ioctl routine */
+
+    return(err) ;
+
+} /* user_putpmsg */
+
+/************************************************************************
+*                             user_getpmsg                              *
+*************************************************************************
+*									*
+* Interface routine to streams getpmsg() routine.			*
+*									*
+************************************************************************/
+int	user_getpmsg(int fd, struct strbuf *ctlptr,
+			     struct strbuf *dataptr,
+			     int *bandp,
+			     int *flagsp)
+{
+    inode_t	*ip ;
+    file_t	*fp ;
+    int		 err ;
+
+    if (fd < 0 || fd > last_fd || (fp = file_tbl[fd]) == NULL)
+	return(-ENXIO) ;			/* no device */
+
+    ip = fp->f_inode ;
+    if (ip == NULL || fp->f_count == 0)
+	return(-EBADF) ;			/* file not open */
+
+    if (fp->f_op->getpmsg != NULL)
+	err = fp->f_op->getpmsg(ip, fp, ctlptr, dataptr, bandp, flagsp, 1) ;
+    else
+	err = -EINVAL ;				/* no ioctl routine */
+
+    return(err) ;
+
+} /* user_getpmsg */
+
+/************************************************************************
+*                           user_poll_wakeup                            *
+*************************************************************************
+*									*
+* Called via the polldat structure to wakeup sleeping poll routine.	*
+*									*
+************************************************************************/
+void	user_poll_wakeup(long arg)
+{
+    semaphore_t		*sem = (semaphore_t *) arg ;
+
+    lis_up(sem) ;
+
+} /* user_poll_wakeup */
+
+/************************************************************************
+*                            user_poll                                  *
+*************************************************************************
+*									*
+* Poll file descriptors for operations.					*
+*									*
+************************************************************************/
+int	user_poll(struct poll *fds, int nfds, int time_out)
+{
+    int			 err;
+    unsigned long	 size = nfds * sizeof(pollfd_t);
+    long		 target_time ;			/* in ms */
+    int			 timer_id = 0 ;
+    long		 time_interval = time_out ;	/* in ms */
+    long		 ms_per_tick = 1000/HZ ;
+    long		 ticks ;			/* in system ticks */
+    pollfd_t		*pfds;
+    pollfd_t		*pfd_ptr ;
+    polldat_t		*pdat_head;
+    polldat_t		*pdat_ptr ;
+    file_t		*fp ;
+    int			 i;
+    int			 done ;
+    int			 ready_fd_cnt = 0 ;
+    int			 psw ;
+    semaphore_t		 poll_sem ;
+
+    /*
+     * Round time interval up to a multiple of system ticks.
+     */
+    ticks = (time_interval + ms_per_tick - 1) / ms_per_tick ;
+    target_time = lis_target_time(ticks*ms_per_tick) ;
+
+    if (   (err=lis_check_umem(NULL,VERIFY_WRITE,fds,size))<0
+	|| (err=lis_check_umem(NULL,VERIFY_READ,fds,size))<0
+       )
+	return(err);
+
+    if ((pfds = ALLOCF(size,"poll-fd ")) == NULL) 
+	return(-ENOMEM);
+
+    if ((pdat_head = ALLOCF(nfds * sizeof(polldat_t), "poll-data ")) == NULL)
+    {
+	FREE(pfds);
+	return(-ENOMEM);
+    }
+
+    memset(pdat_head, 0, nfds * sizeof(polldat_t)) ;	/* clear to zero */
+
+    /*
+     * Obtain copy of user's poll descriptor list
+     */
+    lis_copyin(NULL,pfds, fds, size);
+
+    SEM_INIT(&poll_sem, 0) ;			/* initialize semaphore */
+
+    /*
+     * Run through the descriptor list and check each file descriptor
+     * for validity.  Mark the ones that are bad.
+     */
+    for (i = 0, pdat_ptr = pdat_head, pfd_ptr = pfds;
+	 i < nfds;
+	 i++, pdat_ptr++, pfd_ptr++
+	)
+    {
+	if (pfd_ptr->fd < 0 || pfd_ptr->fd > last_fd
+	    || (fp = file_tbl[pfd_ptr->fd]) == NULL
+	    || fp->f_op->pollfd == NULL
+	   )
+	{				/* not an open file descriptor */
+	    pfd_ptr->revents = POLLNVAL ;
+	    continue ;
+	}
+
+	pdat_ptr->pd_fn	    = user_poll_wakeup ;
+	pdat_ptr->pd_arg    = (long) &poll_sem ;
+    }
+
+    /*
+     * Loop until we find a valid file descriptor which statisfies the
+     * required conditions.  If there were no good file descriptors
+     * then just fall through and return to the user.
+     *
+     * If no file descriptors are found then P(poll_sem).  When something
+     * happens on one of the streams then the user_poll_wakeup function
+     * will get called, which will V(poll_sem).  We then go around and
+     * poll again.
+     *
+     * When we exit the loop we will unlink the polldat entries and
+     * return to the user.
+     *
+     * The file system poll function is called with the file info and
+     * a pointer to a polldat structure.  The file system routine
+     * interrogates the file for the requested conditions according
+     * to the 'pd_events' field in the polldat structure.  It returns
+     * a bit-mask of the events that satisfy the conditions, if any.
+     * The file system also sets the pd_headp pointer to point to
+     * its list head in its stream structure for the polldat list.
+     * We take care of linking the structure into the list.
+     *
+     */
+    for (done = 0; !done; )
+    {
+	for (i = 0, ready_fd_cnt = 0, pdat_ptr = pdat_head, pfd_ptr = pfds;
+	     i < nfds;
+	     i++, pdat_ptr++, pfd_ptr++
+	    )
+	{
+	    if (pfd_ptr->revents & POLLNVAL)
+		continue ;			/* only look at good ones */
+
+	    pdat_ptr->pd_events = pfd_ptr->events ;
+	    fp = file_tbl[pfd_ptr->fd] ;
+	    if ( (pfd_ptr->revents =
+		    (short) fp->f_op->pollfd(fp->f_inode, fp, pdat_ptr)) != 0 )
+	    {
+		done = 1 ;			/* loop breaker */
+		ready_fd_cnt++ ;		/* another ready descriptor */
+		continue ;			/* skip list manipulations */
+	    }
+
+	    if (ready_fd_cnt)			/* skip list manipulations */
+		continue ;			/* if have ready fds */
+
+	    if (   pdat_ptr->pd_headp == NULL
+	        || pdat_ptr->pd_headp->ph_list == pdat_ptr
+	        || pdat_ptr->pd_next != NULL
+	        || pdat_ptr->pd_prev != NULL
+	       )
+		   continue ;		/* no list or already in it */
+
+	    SPLSTR(psw) ;		/* protect streams structures */
+
+	    if (pdat_ptr->pd_headp->ph_list == NULL)
+	    {				/* first entry */
+		pdat_ptr->pd_next =
+		pdat_ptr->pd_prev = NULL ;
+		pdat_ptr->pd_headp->ph_list = pdat_ptr ;
+	    }
+	    else			/* multiple entries */
+	    {
+		pdat_ptr->pd_next = pdat_ptr->pd_headp->ph_list ;
+		pdat_ptr->pd_prev = NULL ;
+
+		pdat_ptr->pd_headp->ph_list->pd_prev = pdat_ptr ;
+		pdat_ptr->pd_headp->ph_list	     = pdat_ptr ;
+	    }
+
+	    SPLX(psw) ;
+	}
+
+	if (done)			/* done */
+	    break ;			/* exit while loop */
+
+	/*
+	 * We recompute the interval until the original time out
+	 * since we may wake up and go around several times before
+	 * we finally decide to return.
+	 *
+	 * A timeout value of -1 means wait forever.
+	 */
+	if (time_out != -1)
+	{
+	    if ( (time_interval = lis_time_till(target_time)) <= 0 )
+		break ;			/* time's up */
+
+	    ticks = (time_interval + ms_per_tick - 1) / ms_per_tick ;
+	    timer_id = timeout((timo_fcn_t *) user_poll_wakeup,
+			       (caddr_t) &poll_sem,
+			       ticks) ;
+	}
+
+	err = lis_down(&poll_sem) ;		/* wait on semaphore */
+	if (err < 0) break ;
+
+	if (timer_id != 0)
+	    untimeout(timer_id) ;	/* cancel timer */
+    }
+
+    /*
+     * Go through and unlink all the polldat structures
+     */
+    for (i = 0, pdat_ptr = pdat_head;
+	 i < nfds;
+	 i++, pdat_ptr++
+	)
+    {
+	if (pdat_ptr->pd_headp != NULL)	/* have list head specified */
+	{
+	    SPLSTR(psw) ;		/* protect streams structures */
+
+	    if (pdat_ptr->pd_headp->ph_list == pdat_ptr)	/* at head */
+		pdat_ptr->pd_headp->ph_list = pdat_ptr->pd_next ;
+
+	    if (pdat_ptr->pd_next)	/* next element exists */
+		pdat_ptr->pd_next->pd_prev = pdat_ptr->pd_prev ;
+
+	    if (pdat_ptr->pd_prev)	/* previous element exists */
+		pdat_ptr->pd_prev->pd_next = pdat_ptr->pd_next ;
+
+	    SPLX(psw) ;
+	}
+    }
+
+    SEM_DESTROY(&poll_sem) ;		/* de-initialize semaphore */
+    FREE(pdat_head);			/* done with polldat structures */
+
+    lis_copyout(NULL,pfds, fds, size);	/* update user's poll list */
+    FREE(pfds) ;			/* done with fd list */
+
+    if (err < 0)
+	return(err) ;			/* probably semaphore error */
+    else
+	return(ready_fd_cnt) ;		/* return # of ready fds */
+
+} /* user_poll */
+
+/************************************************************************
+*                            user_set_ptr                               *
+*************************************************************************
+*									*
+* Our file descriptors have a field 'f_ptr' that the user can use for	*
+* his/her own purposes.  This routine stores the user's pointer into	*
+* that field.								*
+*									*
+* The fd must designate an open file.					*
+*									*
+* Return is negative errno for error, zero for success.			*
+*									*
+************************************************************************/
+int	user_set_ptr(int fd, void *ptr)
+{
+    file_t	*fp ;
+
+    if (fd < 0 || fd > last_fd || (fp = file_tbl[fd]) == NULL)
+	return(-ENXIO) ;			/* no device */
+
+    if (fp->f_inode == NULL || fp->f_count == 0)
+	return(-EBADF) ;			/* file not open */
+
+    fp->f_ptr = ptr ;
+    return(0) ;					/* success */
+
+} /* user_set_ptr */
+
+/************************************************************************
+*                            user_get_ptr                               *
+*************************************************************************
+*									*
+* Retrieve the user pointer set by user_set_ptr() and return it to	*
+* the user.  Return NULL if fd does not designate an open file.		*
+*									*
+************************************************************************/
+void	*user_get_ptr(int fd)
+{
+    file_t	*fp ;
+
+    if (fd < 0 || fd > last_fd || (fp = file_tbl[fd]) == NULL)
+	return(NULL) ;				/* no device */
+
+    if (fp->f_inode == NULL || fp->f_count == 0)
+	return(NULL) ;				/* file not open */
+
+    return(fp->f_ptr) ;
+
+} /* user_get_ptr */
+
+
+
+
+/************************************************************************
+*                        port_register_chrdev                           *
+*************************************************************************
+*									*
+* Called to register a streams driver with the filing system.		*
+* If 'major' is non-zero then this is the major device to attach to.	*
+* if 'major' is zero, then we choose the major device number.		*
+*									*
+* 'name' is the name of the streams driver.
+*									*
+* Return negative err number or positive major device number.		*
+*									*
+************************************************************************/
+int	port_register_chrdev(unsigned major, char *name, 
+				struct file_operations *fops)
+{
+    maj_t	*m ;
+
+    if (major == 0)
+    {
+	for (major = 1; major < NMAJOR; major++)
+	    if (majors[major].m_op == NULL) break ;	/* available */
+    }
+
+    if (major >= NMAJOR)
+	return(-EBADF) ;
+
+    m = &majors[major] ;
+
+    m->m_name = ALLOCF(strlen(name) + 1, "module name ") ;
+    if (m->m_name == NULL) return(-ENOMEM) ;
+    strcpy(m->m_name, name) ;
+    m->m_op = fops ;
+
+    return(major) ;
+
+} /* port_register_chrdev */
+
+/************************************************************************
+*                        port_unregister_chrdev                         *
+*************************************************************************
+*									*
+* Un-register the streams driver whose 'major' number is passed in.	*
+* The driver name is passed in as well as a consistency check item.	*
+* The major slot  must be valid and be associated with this driver.	*
+*									*
+* Return is negative error number, or zero for success.			*
+*									*
+************************************************************************/
+int	port_unregister_chrdev(unsigned major, char *name)
+{
+    maj_t	*m ;
+
+    (void) name ;
+
+    if (major >= NMAJOR)
+	return(-EBADF) ;
+
+    m = &majors[major] ;
+    if (m->m_name != NULL) FREE(m->m_name) ;
+    memset(m, 0, sizeof(*m)) ;		/* clear major entry */
+
+    return(0) ;
+
+} /* port_unregister_chrdev */
+
+/************************************************************************
+*                          user_opendir                                 *
+*************************************************************************
+*									*
+* Open a "file" for reading the directory.  Return a pointer to a	*
+* DIR structure which we then use in future calls to save state info.	*
+*									*
+* The 'name' argument is supposed to name the directory to open. 	*
+* However, since there is only one directory, we ignore this argument.	*
+*									*
+* Return NULL if the open fails.					*
+*									*
+************************************************************************/
+user_DIR	*user_opendir(char *name)
+{
+    user_DIR		*dp ;
+
+    (void) name ;
+
+    dp = ALLOCF(sizeof(*dp), "DIR-search-struct ") ;
+    if (dp == (user_DIR *) NULL)
+	return((user_DIR *) NULL) ;
+
+    memset(dp, 0, sizeof(*dp)) ;		/* clear entry */
+
+    dp->dd_size = NDIR ;
+    dp->dd_buf  = ALLOCF(sizeof(user_dirent_t) + 200, "dirent_t ") ;
+
+    if (dp->dd_buf == NULL)
+    {
+	FREE(dp) ;
+	return((user_DIR *) NULL) ;
+    }
+
+    memset(dp->dd_buf, 0, sizeof(user_dirent_t) + 200) ;
+
+    return(dp) ;
+
+} /* user_opendir */
+
+/************************************************************************
+*                             user_readdir                              *
+*************************************************************************
+*									*
+* Read the next entry from the directory.  Return NULL if at end of	*
+* directory.								*
+*									*
+************************************************************************/
+struct user_dirent	*user_readdir(user_DIR *dp)
+{
+    if (dp == (user_DIR *) NULL)
+	return((struct user_dirent *) NULL) ;
+
+    for (; dp->dd_loc < NDIR; dp->dd_loc++)
+    {
+	dir_t	*dirp ;
+	inode_t	*ip ;
+
+	dirp = &directory[dp->dd_loc] ;
+	if (dirp->d_name != NULL)		/* name valid */
+	{
+	    user_dirent_t	 *dep ;		/* ptr to return value */
+	    if ( dirp->d_inode == NULL )
+	    {
+	    	continue;
+	    }
+	    ip = user_inode(dirp->d_dev) ;	/* ptr to inode */
+	    if (ip == NULL)			/* out of inodes */
+		continue ;			/* no good */
+
+	    dep = (user_dirent_t *) dp->dd_buf ;/* rtn bfr hanging off of dp */
+	    dep->d_ino    = ip->i_inum;		/* phoney inode number */
+	    dep->d_off    = dp->dd_loc ;	/* offset of directory entry */
+	    dep->d_reclen = (unsigned short)
+				(sizeof(*dep) + strlen(dirp->d_name)) ;
+	    strcpy(dep->d_name, dirp->d_name) ;
+	    dp->dd_loc++ ;			/* advance to next entry */
+	    ip->i_use--;
+	    ULOCK_INO(ip) ;
+	    return(dep) ;			/* ptr to dirent structure */
+	}
+    }
+
+    return((struct user_dirent *) NULL) ;	/* no more entries */
+
+} /* user_readdir */
+
+/************************************************************************
+*                           user_rewinddir                              *
+*************************************************************************
+*									*
+* Rewind the search back to the beginning of the directory.		*
+*									*
+************************************************************************/
+void	 user_rewinddir(user_DIR *dp)
+{
+    if (dp != (user_DIR *) NULL)
+	dp->dd_loc = 0 ;
+
+} /* user_rewinddir */
+
+/************************************************************************
+*                           user_closedir                               *
+*************************************************************************
+*									*
+* Close the directory "file".						*
+*									*
+************************************************************************/
+int	 user_closedir(user_DIR *dp)
+{
+    if (dp != (user_DIR *) NULL)
+    {
+	if (dp->dd_buf != NULL)
+	    FREE(dp->dd_buf) ;
+
+	FREE(dp) ;
+    }
+
+    return(0) ;
+
+} /* user_closedir */
+
+/************************************************************************
+*                         user_inode_stat                               *
+*************************************************************************
+*									*
+* Given an inode, build the stat structure corresponding to it.		*
+*									*
+************************************************************************/
+int	user_inode_stat(inode_t *ip, struct user_stat *buf)
+{
+    memset(buf, 0, sizeof(*buf)) ;
+
+    buf->st_dev		= ip->i_dev ;
+    buf->st_ino		= ip->i_inum ;
+    buf->st_mode	= ip->i_mode ;
+    buf->st_nlink	= 1 ;			/* presumably */
+    buf->st_rdev	= ip->i_dev ;
+    strcpy(buf->st_fstype, "STREAMS") ;
+    buf->st_ctime	= ip->i_ctime;
+    buf->st_ftime	= ip->i_ftime;
+    buf->st_mtime	= ip->i_mtime;
+    buf->st_atime	= ip->i_atime;
+    return(0) ;
+
+} /* user_inode_stat */
+
+/************************************************************************
+*                            user_stat                                  *
+*************************************************************************
+*									*
+* Return status of a streams file.					*
+*									*
+************************************************************************/
+int	user_stat(char *name, struct user_stat *buf)
+{
+    dir_t	*dp ;
+    inode_t	*ip ;
+    int		 rslt;
+
+    dp = user_search_dir(name) ;		/* find name in directory */
+    if (dp == NULL)
+	return(-ENOENT) ;			/* not found */
+
+    ip = user_inode(dp->d_dev) ;		/* ptr to inode */
+    if (ip == NULL)				/* out of inodes */
+	return(-EMFILE) ;
+    if (dp->d_inode == NULL )
+	dp->d_inode = ip;
+    ip->i_use--;
+
+    rslt = user_inode_stat(ip, buf) ;
+
+    ULOCK_INO(ip) ;
+
+    return(rslt) ;	/* return status */
+
+} /* user_stat */
+
+
+/************************************************************************
+*                            user_fstat                                 *
+*************************************************************************
+*									*
+* Return status on an open file descriptor.				*
+*									*
+************************************************************************/
+int	user_fstat(int fd, struct user_stat *buf)
+{
+    inode_t	*ip ;
+    file_t	*fp ;
+
+    if (fd < 0 || fd > last_fd || (fp = file_tbl[fd]) == NULL)
+	return(-ENXIO) ;			/* no device */
+
+    ip = fp->f_inode ;
+    if (ip == NULL || fp->f_count == 0)
+	return(-EBADF) ;			/* file not open */
+
+    return(user_inode_stat(ip, buf)) ;		/* return status */
+
+} /* user_fstat */
+
+
+/************************************************************************
+*                          user_print_inode                             *
+*************************************************************************
+*									*
+* Print out the inode structure pointed to by 'ip'.			*
+*									*
+************************************************************************/
+static char	dcf[] = "-fc?d?b?" ;
+
+static char	*rwx[8] = 
+		{
+		 "---"
+		,"--x"
+		,"-w-"
+		,"-wx"
+		,"r--"
+		,"r-x"
+		,"rw-"
+		,"rwx"
+		} ;
+
+void	user_print_inode(inode_t *ip)
+{
+    if (ip == NULL)
+    {
+	printk("user_print_inode: Inode ptr is NULL\n") ;
+	return ;
+    }
+
+    printk("\ti_link     = %s\n", (ip->i_link == NULL ? "NULL" : "Non-NULL")) ;
+    printk("\ti_mode     = %o %c%s%s%s\n", ip->i_mode,
+		dcf[(ip->i_mode >> 12) & 0x07],
+		rwx[(ip->i_mode >> 6) & 0x07],
+		rwx[(ip->i_mode >> 3) & 0x07],
+		rwx[(ip->i_mode     ) & 0x07]) ;
+
+    printk("\ti_dev      = %d,%d\n", major(ip->i_dev), minor(ip->i_dev)) ;
+    printk("\ti_str      = %s\n", (ip->i_str == NULL ? "NULL" : "Non-NULL")) ;
+    printk("\ti_use      = %d\n", ip->i_use) ;
+    printk("\ti_inum     = %d\n", ip->i_inum) ;
+    printk("\ti_ctime    = %s", ctime(&ip->i_ctime)) ;
+    printk("\ti_mtime    = %s", ctime(&ip->i_mtime)) ;
+    printk("\ti_atime    = %s", ctime(&ip->i_atime)) ;
+    printk("\ti_ftime    = %s", ctime(&ip->i_ftime)) ;
+    printk("\ti_flags    = 0x%x\n", ip->i_flags) ;
+#ifdef USER
+    printk("\ti_sem      = %d\n", ip->i_sem.sem_count) ;
+#endif
+} /* user_print_inode */
+
+/************************************************************************
+*                          user_print_inodes                            *
+*************************************************************************
+*									*
+* Run through the chain of inodes and print them all out.		*
+*									*
+************************************************************************/
+void
+user_print_inodes(void)
+{
+    inode_t	*ip ;
+
+    printk("\n") ;
+    for (ip = inodes; ip != NULL; ip = ip->i_link)
+    {
+	user_print_inode(ip) ;
+	printk("\n") ;
+    }
+
+} /* user_print_inodes */
+
+/************************************************************************
+*                        user_print_dir_entry                           *
+*************************************************************************
+*									*
+* Print out a directory entry according to the passed options.		*
+*									*
+************************************************************************/
+void	user_print_dir_entry(dir_t *dp, int optns)
+{
+    char	timbuf[50] ;
+    int		refcnt ;
+
+    strcpy(timbuf, ctime(&dp->d_mtime)) ;
+    timbuf[strlen(timbuf)-1] = 0 ;	/* zot the \n on the end */
+
+    if (dp->d_inode != NULL)
+	refcnt = dp->d_inode->i_use ;
+    else
+	refcnt = dp->d_refcnt ;
+
+    printk("%3d %c%s%s%s %2d %2d,%2d %s  %s\n",
+	    dp->d_inum,
+	    dcf[(dp->d_mode >> 12) & 0x07],
+	    rwx[(dp->d_mode >> 6) & 0x07],
+	    rwx[(dp->d_mode >> 3) & 0x07],
+	    rwx[(dp->d_mode     ) & 0x07],
+	    refcnt,
+	    major(dp->d_dev), minor(dp->d_dev),
+	    timbuf,
+	    dp->d_name) ;
+
+    if (optns & USR_PRNT_INODE)
+	user_print_inode(dp->d_inode) ;
+
+} /* user_print_dir_entry */
+
+/************************************************************************
+*                         user_print_dir                                *
+*************************************************************************
+*									*
+* Print out the directory.						*
+*									*
+* If 'name' is non-null, then just print the entry for the name.	*
+* if 'name' is null then print the whole directory.			*
+*									*
+* 'optns' controls how much info to print out about each entry.		*
+*									*
+************************************************************************/
+void	user_print_dir(char *name, int optns)
+{
+    int		 d ;
+    dir_t	*dp ;
+
+    for (d = 0, dp = &directory[0]; d < NDIR; d++, dp++)
+    {
+	if (   dp->d_name != NULL		/* name valid */
+	    && (   name == NULL
+		|| strcmp(dp->d_name, name) == 0	/* name match */
+	       )
+	   )
+	    user_print_dir_entry(dp, optns) ;
+    }
+
+} /* user_print_dir */
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/user/usrio.h /usr/src/linux/drivers/streams/LiS/head/user/usrio.h
--- debug/drivers/streams/LiS/head/user/usrio.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/user/usrio.h	Mon Dec 30 10:04:59 1996
@@ -0,0 +1,217 @@
+#ifndef _USRIO_H_
+#define _USRIO_H_
+/************************************************************************
+*                        User Functions                                 *
+*************************************************************************
+*									*
+* These are file-system-like funcitons defined in head/user/port.c.	*
+*									*
+************************************************************************/
+
+#ifndef _SYS_POLL_H
+#include <sys/poll.h>
+#endif
+
+#ifndef NULL
+#define	NULL		( (void *) 0 )
+#endif
+
+#ifndef _IOW
+#define _IOW(x,y,t)     (((((int)sizeof(t))&0xFFFF)<<16)|(x<<8)|y)
+#endif
+
+/*
+ * If you define this from the outside, PLEASE do it consistently
+ * in all compiles involving this header file.
+ */
+#ifndef MAXNAMLEN
+#define MAXNAMLEN	100
+#endif
+
+/************************************************************************
+*                        Data Structures                                *
+************************************************************************/
+
+typedef struct dir			/* directory entry */
+{
+    char	*d_name ;		/* file name */
+    dev_t	 d_dev ;		/* device number major/minor */
+    int		 d_mode ;		/* file mode */
+    time_t	 d_ftime ;		/* time file was created */
+    time_t	 d_ctime ;		/* time file was created */
+    time_t	 d_atime ;		/* time file was accessed */
+    time_t	 d_mtime ;		/* time file was modified */
+    int		 d_refcnt;		/* reference count */
+    u_inode_t   *d_inode ;
+    int		 d_inum ;
+
+} dir_t ;
+
+typedef struct maj			/* major device entry */
+{
+    char	*m_name ;		/* device name */
+    struct file_operations *m_op ;	/* open, close,... ptrs */
+
+} maj_t ;
+
+#define	NDIR	1024			/* number of directory entries */
+#define	NMAJOR	100			/* number of major device numbers */
+
+/************************************************************************
+*                      Directory Searching                              *
+*************************************************************************
+*									*
+* The following structures and prototypes are used to define a POSIX-	*
+* like directory searching mechanism.  This allows users to search	*
+* our internal directory.						*
+*									*
+************************************************************************/
+typedef struct
+{
+    int		 dd_fd;			/* file descriptor */
+    int		 dd_loc;		/* offset in block */
+    int		 dd_size;		/* amount of valid data */
+    char	*dd_buf;		/* directory block */
+
+} user_DIR ;
+
+
+/*
+ * Returned by readdir routine
+ */
+typedef struct user_dirent
+{
+    int			d_ino ;		/* inode number */
+    off_t		d_off ;		/* offset of directory entry */
+    unsigned short	d_reclen ;	/* length of this record */
+    char		d_name[1] ;	/* name of file */
+
+} user_dirent_t ;
+
+extern user_DIR			*user_opendir(char *);
+extern struct user_dirent	*user_readdir(user_DIR *);
+extern int			 user_closedir(user_DIR *);
+extern void			 user_rewinddir(user_DIR *) ;
+
+/************************************************************************
+*                          File Status                                  *
+*************************************************************************
+*									*
+* Routines and structures to return the status of a file.		*
+*									*
+* Almost all of these fields are unused.  They are present just to	*
+* give an SVR4 look to the structure.					*
+*									*
+************************************************************************/
+
+typedef struct user_stat
+{
+    int		st_dev ;	/* device which contains the directory */
+    int		st_ino ;	/* inode number of file (phoney) */
+    long	st_mode ;	/* mode of file */
+    int		st_nlink ;	/* number of links */
+    int		st_uid ;	/* owner */
+    int		st_gid ;	/* group */
+    dev_t	st_rdev ;	/* device if special file (ours are) */
+    int		st_size ;	/* file size */
+    long	st_atime ;	/* last access time */
+    long	st_mtime ;	/* last modification */
+    long	st_ctime ;	/* last status change */
+    long	st_ftime ;	/* creation change */
+    long	st_blksize ;	/* preferred block size */
+    long	st_blocks ;	/* number of st_blksize blks allocated */
+    char	st_fstype[16];	/* type of file system */
+    int		st_aclcnt ;	/* number of ACL entries */
+    int		st_level ;	/* MAC level */
+    long	st_flags ;	/* general purpose flags */
+    int		st_cmwlevel ;	/* future MAC level */
+
+} user_stat_t ;
+
+extern int	user_stat(char *name, struct user_stat *buf) ;
+extern int	user_fstat(int fd, struct user_stat *buf) ;
+
+
+/************************************************************************
+*                         fcntl Types                                   *
+*************************************************************************
+*									*
+* The following codes will be defined here for calls to fcntl if they	*
+* have not been defined elsewhere first.  These are SVR4 command codes	*
+* that are not included in every environment's fcntl.h.			*
+*									*
+************************************************************************/
+
+#ifndef F_ALLOCSP
+#define F_ALLOCSP	10
+#endif
+#ifndef F_FREESP
+#define F_FREESP	11
+#endif
+#ifndef F_RSETLK
+#define F_RSETLK	20
+#endif
+#ifndef F_RGETLK
+#define F_RGETLK	21
+#endif
+#ifndef F_RSETLKW
+#define F_RSETLKW	22
+#endif
+#ifndef F_GETOWN
+#define F_GETOWN	23
+#endif
+#ifndef F_SETOWN
+#define F_SETOWN	24
+#endif
+#ifndef F_CHKFL
+#define F_CHKFL		99			/* completely bogus value */
+#endif
+
+
+/************************************************************************
+*                         Printing Options                              *
+*************************************************************************
+*									*
+* Options to control how much the directory print routine prints.	*
+*									*
+************************************************************************/
+#define	USR_PRNT_INODE		0x01	/* print inode structures */
+#define	USR_PRNT_FILE		0x02	/* print file structures */
+
+/************************************************************************
+*                           Prototypes                                  *
+************************************************************************/
+
+#define	user_putmsg(f,c,d,g)	user_putpmsg(f,c,d,-1,g)
+#define	user_getmsg(f,c,d,g)	user_getpmsg(f,c,d,NULL,g)
+
+int	user_mknod(char *name, int mode, dev_t dev) ;
+int	user_open(char *name, int flags, int mode) ;
+int	user_close(int fd) ;
+int	user_read(int fd, void *buf, int nbytes) ;
+int	user_write(int fd, void *buf, int nbytes) ;
+int	user_ioctl(int fd, int cmd, ...) ;
+int	user_fcntl(int fd, int cmd, ...) ;
+int	user_putpmsg(int fd, struct strbuf *ctlptr,
+			     struct strbuf *dataptr,
+			     int band,
+			     int flags) ;
+int	user_getpmsg(int fd, struct strbuf *ctlptr,
+			     struct strbuf *dataptr,
+			     int *bandp,
+			     int *flagsp) ;
+int	user_poll(struct poll *fds, int nfds, int time_out) ;
+int	user_set_ptr(int fd, void *ptr) ;
+void	*user_get_ptr(int fd) ;
+void	 user_print_dir(char *name, int optns) ;
+void	 user_print_inode(inode_t *ip) ;
+void	 user_print_inodes(void) ;
+
+int	 user_add_dir_entry(char *name, int mode, dev_t dev) ;
+dir_t	*user_search_dir(char *name) ;
+dir_t	*user_search_dir_inode(inode_t *i) ;
+file_t	*user_file_of_inode(inode_t * i) ;
+file_t	*user_alloc_file(void) ;
+
+
+#endif /* _USRIO_H_ */
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/user-mdep.c /usr/src/linux/drivers/streams/LiS/head/user-mdep.c
--- debug/drivers/streams/LiS/head/user-mdep.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/user-mdep.c	Fri Dec 27 15:30:15 1996
@@ -0,0 +1,38 @@
+/************************************************************************
+*                     User Level Testing Routines 			*
+*************************************************************************
+*									*
+* This file contains abstract routine definitions suitable for running	*
+* STREAMS as a user-level process.					*
+*									*
+* It includes "port-mdep.c" first and then adds in code specific to	*
+* the user level environment.						*
+*									*
+************************************************************************/
+
+#include "port-mdep.c"
+
+#include <sys/LiS/head.h>		/* for strread, strwrite, etc */
+
+int	runq_sched ;			/* needed to resolve a reference */
+
+struct file_operations
+lis_streams_fops = {
+	NULL,			/* lseek   -- no lseek  */
+	lis_strread,		/* read    		*/
+	lis_strwrite,		/* write to stream      */
+	NULL,			/* readdir -- no readdir*/
+	NULL,			/* select  		*/
+	lis_strioctl,		/* ioctl   		*/
+	NULL,			/* mmap    -- no mmap   */
+	lis_stropen,		/* open the stream      */
+	lis_strclose,		/* close the stream     */
+	NULL,			/* fsync   -- no fsync  */
+	NULL,			/* fasync  -- no fasync */
+	NULL,			/* check_media_change	*/
+	NULL,			/* revalidate		*/
+	lis_strputpmsg,		/* putpmsg & putmsg	*/
+	lis_strgetpmsg,		/* getpmsg & getmsg	*/
+	lis_strpoll		/* poll			*/
+};
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/head/wait.c /usr/src/linux/drivers/streams/LiS/head/wait.c
--- debug/drivers/streams/LiS/head/wait.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/head/wait.c	Wed Jan  1 14:13:04 1997
@@ -0,0 +1,124 @@
+/*                               -*- Mode: C -*- 
+ * wait.c --- wait queues management
+ * Author          : Francisco J. Ballesteros
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: wait.c,v 1.2 1995/12/27 01:02:53 dave Exp $
+ * Purpose         : keep close all the wait related stuff.
+ * ----------------______________________________________________
+ *
+ *   Copyright (C) 1995  Francisco J. Ballesteros
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach me by email to
+ *    nemo@ordago.uc3m.es
+ */
+
+
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#include <sys/strport.h>
+#include <sys/strconfig.h>	/* config definitions */
+#include <sys/LiS/share.h>	/* streams shared defs*/
+#include <sys/LiS/wait.h>	/* interface */
+#include <sys/LiS/head.h>	/* stream head */
+#include <sys/LiS/queue.h>	/* streams queues */
+
+
+/*  -------------------------------------------------------------------  */
+/*				   Symbols                               */
+
+/* Timer tick, this will in be the worst case 
+ */
+#define LIS_TICK	0x00
+
+/*  -------------------------------------------------------------------  */
+/*				 Global vars                             */
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+/* The functions below are to achieve mutual exclusion on the stream
+ * head. They use the sd_wopen wait queue to sleep and the sd_lock char to
+ * flag the lock.
+ * The lock/unlock are the complete ones.
+ * if you just want to wait you may use wait_on/wake_up.
+ *
+ * You can lock(L)/wait(W)/sleep(S) on the following events:
+ * L/W wopen:  the 1st opener completes its job
+ * W/S wwrite: there's room in the write queue to issue a downstream msg.
+ * STATUS: complete(?), untested
+ */
+/*  -------------------------------------------------------------------  */
+int 
+lis_sleep_on_wopen(struct stdata * sd)
+{
+    int		rslt ;
+
+    rslt = lis_down(&sd->sd_wopen);
+    if (rslt < 0) return(rslt) ;
+    F_SET(sd->sd_flag,STWOPEN);
+    return(rslt) ;
+
+}/*lis_sleep_on_wopen*/
+/*  -------------------------------------------------------------------  */
+int 
+lis_sleep_on_wioc(struct stdata * sd)
+{
+    int		rslt ;
+
+    rslt = lis_down(&sd->sd_wioc);
+    if (rslt < 0) return(rslt) ;
+    F_SET(sd->sd_flag,IOCWAIT);
+    return(rslt) ;
+
+}/*lis_sleep_on_wopen*/
+/*  -------------------------------------------------------------------  */
+int 
+lis_sleep_on_wwrite(struct stdata * sd)
+{
+
+    return(lis_down(&sd->sd_wwrite));
+
+}/*lis_sleep_on_wwrite*/
+/*  -------------------------------------------------------------------  */
+int 
+lis_sleep_on_wread(struct stdata * sd)
+{
+
+    return(lis_down(&sd->sd_wread));
+
+}/*lis_sleep_on_wread*/
+
+/*  -------------------------------------------------------------------  */
+int 
+lis_sleep_on_wiocing(struct stdata * sd)
+{
+
+    return(lis_down(&sd->sd_wiocing));
+
+}/*lis_sleep_on_wiocing*/
+
+
+
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/buffcall.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/buffcall.h
--- debug/drivers/streams/LiS/include/sys/LiS/buffcall.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/buffcall.h	Wed Jan  1 13:04:38 1997
@@ -0,0 +1,136 @@
+/*                               -*- Mode: C -*- 
+ * buffcall.h --- buffcall management 
+ * Author          : Francisco J. Ballesteros & Graham Wheeler
+ * Created On      : Tue May 31 21:40:37 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: buffcall.h,v 1.4 1996/01/27 00:40:24 dave Exp $
+ * ----------------______________________________________________
+ *
+ *    Copyright (C) 1995  Graham Wheeler, Francisco J. Ballesteros,
+ *                        Denis Froschauer
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    gram@aztec.co.za, nemo@ordago.uc3m.es, 100741.1151@compuserve.com
+ */
+
+
+
+#ifndef _BUFFCALL_H
+#define _BUFFCALL_H 1
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#ifndef _LIS_CONFIG_H
+#include <sys/strconfig.h>	/* config definitions */
+#endif
+#ifndef _SHARE_H
+#include <sys/LiS/share.h>	/* shared defs */
+#endif
+/*  -------------------------------------------------------------------  */
+/*				    Types                                */
+
+#ifdef __KERNEL__
+/* buffcall list 
+ */
+/* entry */
+typedef struct bcinfo
+{
+    struct bcinfo *next;	/* next node  */
+    struct bcinfo *prev;	/* prev node  */
+    unsigned	   size;	/* size for this node */
+    int		   id ;		/* identifier for user */
+    void	 (*usr_f)(long);/* user callback */
+    long	   usr_arg;	/* arg for user callback */
+} bcinfo_t;
+
+/* list head */
+typedef struct bclist
+{
+    struct bcinfo *first;
+    struct bcinfo *last;
+    int		   n_elts ;
+} bclist_t ;
+
+#endif /* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+/*				 Glob. Vars.                             */
+#ifdef __KERNEL__
+
+/*
+ * A power of 2 hash will do since the bufcall ids are allocated as
+ * sequential numbers.
+ */
+#define	N_BCHASH	128		/* power of 2 */
+#define	BCHASH_MSK	(N_BCHASH - 1)
+extern volatile bclist_t	lis_bchash[N_BCHASH] ;	/* the bufcall table */
+extern volatile bcinfo_t	*lis_bcfreel ;		/* the free list */
+
+extern volatile char lis_strbcflag;	/* the bufcall functions must be run */
+
+/*
+ * Timer ticks -- frequency to run bufcall timer.
+ */
+#define	BUFCALL_N_TICKS	10		/* gives 100ms per timeout */
+
+
+#endif /* __KERNEL__ */
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+/* lis_bufcall - schedule recovery from alloc failure
+ */
+#ifdef __KERNEL__
+extern int 
+lis_bufcall(unsigned size, int priority, void (*function)(long), long arg);
+#endif				/* __KERNEL__ */
+
+/* esbbcall - like bufcall, but for lis_esballoc. The function
+ *	will be called when there is a `good chance' that the
+ *	lis_esballoc will succeed.
+ */
+#ifdef __KERNEL__
+extern int lis_esbbcall(int priority, void (*function)(long), long arg);
+#endif				/* __KERNEL__ */
+
+/* unbufcall - cancels a bufcall/esbbcall
+ */
+#ifdef __KERNEL__
+extern void lis_unbufcall(int bcid);
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+
+#ifdef __KERNEL__
+/* init the bufcall table
+ */
+extern void lis_init_bufcall(void);
+
+extern void lis_dobufcall(void) ;
+
+#endif /* __KERNEL__ */
+
+
+/*  -------------------------------------------------------------------  */
+#endif /*!_BUFFCALL_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/dlpidriver.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/dlpidriver.h
--- debug/drivers/streams/LiS/include/sys/LiS/dlpidriver.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/dlpidriver.h	Mon Dec 16 16:36:39 1996
@@ -0,0 +1,24 @@
+#ifndef _DLPIDRIVER
+#define _DLPIDRIVER
+
+#define MAXDEVICE	1
+
+#define DLDRIOC	('D'<<8)
+#define SETADDR	(DLDRIOC|1)
+#define GETADDR	(DLDRIOC|2)
+
+#ifdef _KERNEL
+
+#undef STATIC
+#ifdef DEBUG
+#define STATIC
+#else
+#define STATIC static
+#endif
+
+#endif /* _KERNEL */
+
+#endif /* _DLPIDRIVER */
+
+
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/dos-mdep.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/dos-mdep.h
--- debug/drivers/streams/LiS/include/sys/LiS/dos-mdep.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/dos-mdep.h	Mon Dec 16 16:36:39 1996
@@ -0,0 +1,84 @@
+/*                               -*- Mode: C -*- 
+ * dos-mdep.c --- Testing environment for LiS under MS-Dog.
+ * Author          : Francisco J. Ballesteros
+ * Created On      : Sat Jun  4 20:56:03 1994
+ * Last Modified By: Francisco J. Ballesteros
+ * Last Modified On: Fri Sep 29 13:25:04 1995
+ * Update Count    : 5
+ * RCS Id          : $Id: dos-mdep.h,v 1.2 1996/01/20 17:01:57 dave Exp $
+ * Usage           : see below :)
+ * Required        : see below :)
+ * Status          : ($State: Exp $) incomplete,untested,compiled
+ * Prefix(es)      : lis
+ * Requeriments    : 
+ * Purpose         : provide Dog <-> LiS entry points.
+ *                 : 
+ * ----------------______________________________________________
+ *
+ *    Copyright (C) 1995  Graham Wheeler
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach me by email to
+ *    gram@aztec.co.za
+ */
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#include <sys/types.h>        /* common system types */
+#include <stdlib.h>	      /* for NULL, malloc, free */
+#include <stdio.h>	      /* for printf */
+#include <mem.h>	      /* for memcpy */
+#include <memory.h>	      /* for memcpy */
+#include <assert.h>
+#include <sys/signal.h>	      /* for signal numbers */
+
+
+/*  -------------------------------------------------------------------  */
+
+#define VOID			void
+#define ALLOC(n)		malloc(n)
+#define FREE(p,n)		free(p)
+#define MEMCPY(dest, src, len)	memcpy(dest, src, len)
+#define INLINE
+#define LOG(f,l,s)		printf("%s (line %d of file %s)\n", s, l, f)
+#define PANIC(msg)		( printf("PANIC: %s\n", msg), exit(0) )
+#define ASSERT(e)		assert(e)
+
+#define splx(s)		((void)s)
+#define splstr()	0
+
+typedef unsigned long	ulong_t;
+typedef unsigned short	ushort_t;
+typedef unsigned char	uchar_t;
+typedef short		o_uid_t;
+typedef short		o_gid_t;
+typedef short		uid_t;
+typedef short		gid_t;
+typedef unsigned	uint;
+typedef unsigned char   uchar;
+typedef unsigned short  ushort;
+typedef unsigned long   ulong;
+typedef char*		caddr_t;
+
+struct inode { char pad; };
+struct wait_queue { char pad; };
+
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/errmsg.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/errmsg.h
--- debug/drivers/streams/LiS/include/sys/LiS/errmsg.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/errmsg.h	Mon Dec 16 16:36:39 1996
@@ -0,0 +1,73 @@
+/*                               -*- Mode: C -*- 
+ * errmsg.h --- streams error messages
+ * Author          : Francisco J. Ballesteros
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: Francisco J. Ballesteros
+ * Last Modified On: Tue Sep 26 15:19:24 1995
+ * Update Count    : 2
+ * RCS Id          : $Id: errmsg.h,v 1.1 1995/12/19 15:58:14 dave Exp $
+ * Usage           : see below :)
+ * Required        : see below :)
+ * Status          : ($State: Exp $) complete, untested, compiled
+ * Prefix(es)      : lis
+ * Requeriments    : 
+ * Purpose         : provide streams errmsg
+ *                 : 
+ * ----------------______________________________________________
+ *
+ *    Copyright (C) 1995  Francisco J. Ballesteros
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach me by email to 
+ *    nemo@ordago.uc3m.es
+ */
+
+#ifndef _ERRMSG_H
+#define _ERRMSG_H 1
+#ifdef __KERNEL__
+
+/*  -------------------------------------------------------------------  */
+/*				   Symbols                               */
+
+enum lis_errclass_t { LIS_PANIC, LIS_ERROR, LIS_WARN, LIS_DEBUG };
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+
+/* This function will report a msg w/ the error condition and take appropriate
+ * actions depending on the error level. 
+ * actions will be:
+ * LIS_PANIC: issue a panic msg and panic the kernel
+ * LIS_ERROR: issue an error.
+ * LIS_WARN:  issue a warning msg.
+ * LIS_DEBUG: issue a debug msg.
+ * msg will be formatted like: 
+ *      "some_msg_prefix (your_function_name): fmt_msg\n"
+ */
+
+extern void
+lis_error( int lvl, const char *fname, const char * fmt, ...);
+
+/*  -------------------------------------------------------------------  */
+#endif /* __KERNEL__ */
+#endif /*!_ERRMSG_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/events.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/events.h
--- debug/drivers/streams/LiS/include/sys/LiS/events.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/events.h	Mon Dec 16 16:36:39 1996
@@ -0,0 +1,131 @@
+/*                               -*- Mode: C -*- 
+ * events.h --- streams events
+ * Author          :  Francisco J. Ballesteros & Graham Wheeler
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: Francisco J. Ballesteros
+ * Last Modified On: Tue Sep 26 15:20:42 1995
+ * Update Count    : 2
+ * RCS Id          : $Id: events.h,v 1.3 1996/01/27 00:40:25 dave Exp $
+ * Usage           : see below :)
+ * Required        : see below :)
+ * Status          : ($State: Exp $) complete, untested, compiled
+ * Prefix(es)      : lis
+ * Requeriments    : 
+ * Purpose         : provide streams events
+ *                 : 
+ * ----------------______________________________________________
+ *
+ *    Copyright (C) 1995  Graham Wheeler, Francisco J. Ballesteros
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    gram@aztec.co.za, nemo@ordago.uc3m.es
+ */
+
+#ifndef _EVENTS_H
+#define _EVENTS_H 1
+
+#ifndef _SYS_TYPES_H
+#include <sys/types.h>
+#endif
+
+#ifdef __KERNEL__
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#include <sys/strconfig.h>	/* config definitions */
+#include <sys/LiS/share.h>	/* generid defs */
+/*  -------------------------------------------------------------------  */
+/*				    Types                                */
+/* Stream event info
+ */
+typedef
+struct strevent {
+    struct strevent *se_next;	/* next event for this stream or NULL*/
+    struct strevent *se_prev;	/* previous event for this stream or last
+				 * event if this is the first one*/
+    pid_t se_pid;		/* process to be signaled */
+    short se_evs;		/* events wanted */
+} strevent_t;
+
+#if 0
+/* I don't know if it's a good idea to keep the strinfo structs around
+ * other structs. It's good to debug memory issues, but we should reimplement
+ * completelly the STREAMS memory management. 
+ * I guess it would be better just to alloc raw memory pages and avoid 
+ * memory fragmentation by using the knowledge of what's likely to be requested
+ * what's likely to be freed and what the sizes are.
+ * When one of those pages get w/ count 0 (i.e., no used chunk inside) we could
+ * just give it back to the kernel.
+ * More on, we could keep initialized structs in a pre-initialized state, so
+ * only the very first time they're use they're filled. Later on, the initial
+ * initialization process could be skipped.
+ * There was an article in UNSENIX (don't remember exactly where) about this.
+ * -- nemo
+ */
+
+struct strinfo {};
+#endif /* 0 */
+
+/*  -------------------------------------------------------------------  */
+/*				 Glob. Vars.                             */
+
+extern struct strevent *lis_sefreelist; /* list of free stream events */
+extern struct strevent *lis_secachep;   /* reserve store of free str events */
+
+#if 0
+/* see long comment above -- nemo */
+extern struct strinfo lis_strinfo[]; /* keeps track of allocated events	*/
+#endif
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+/* get events for pid in list
+ * STATUS: complete, untested
+ */
+extern  short
+lis_get_elist_ent( strevent_t *list, pid_t pid );
+
+/* add event to list
+ * STATUS: complete, untested
+ */
+extern int
+lis_add_to_elist( strevent_t **list, pid_t pid, short events );
+
+/* del event from list
+ * rets non-zero if not-found
+ * STATUS: complete, untested
+ */
+extern int
+lis_del_from_elist( strevent_t **list, pid_t pid, short events );
+
+/*
+ * Free the entire elist
+ */
+extern void
+lis_free_elist( strevent_t **list);
+
+/*  -------------------------------------------------------------------  */
+#endif /* __KERNEL__ */
+#endif /*!_EVENT_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/fifo.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/fifo.h
--- debug/drivers/streams/LiS/include/sys/LiS/fifo.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/fifo.h	Mon Dec 16 16:36:39 1996
@@ -0,0 +1,43 @@
+/*                               -*- Mode: C -*- 
+ * fifo.h --- fifo driver 
+ * Author          : Francisco J. Ballesteros
+ * Created On      : Tue May 31 21:40:37 1994
+ * Last Modified By: 
+ * Last Modified On: 
+ * Update Count    : 0
+ * RCS Id          : $Id: fifo.h,v 1.2 1996/01/27 00:40:25 dave Exp $
+ * Usage           : see below :)
+ * Required        : see below :)
+ * Status          : ($State: Exp $) Unknown, Use with caution!
+ * Prefix(es)      : 
+ * Requeriments    : 
+ * Purpose         : implement STREAMS fifos
+ *                 : 
+ * ----------------______________________________________________
+ */
+
+#ifndef _FIFO_H
+#define _FIFO_H 1
+
+/*  -------------------------------------------------------------------  */
+/*                               Dependencies                            */
+
+#ifndef _LIS_CONFIG_H
+#include <sys/strconfig.h>	/* streams config symbols are here */
+#endif
+#ifndef _MOD_H
+#include <sys/LiS/mod.h>	/* streams module symbols & types */
+#endif
+
+/*  -------------------------------------------------------------------  */
+/*                         Shared global variables                       */
+
+extern struct streamtab lis_fifo_strtab; /* streamtab for streams fifo's */
+
+#endif /*!_FIFO_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/head.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/head.h
--- debug/drivers/streams/LiS/include/sys/LiS/head.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/head.h	Wed Jan  1 13:04:38 1997
@@ -0,0 +1,301 @@
+/*                               -*- Mode: C -*- 
+ * head.h --- streams head handling
+ * Author          : Graham Wheeler, Francisco J. Ballesteros
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: head.h,v 1.13 1996/01/28 21:59:25 dave Exp $
+ * Purpose         : here you have utilites to handle str heads.
+ * ----------------______________________________________________
+ *
+ *    Copyright (C) 1995  Graham Wheeler, Francisco J. Ballesteros,
+ *                        Denis Froschauer
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    gram@aztec.co.za, nemo@ordago.uc3m.es, 100741.1151@compuserve.com
+ *    dave@gcom.com
+ */
+
+#ifndef _HEAD_H
+#define _HEAD_H 1
+
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#ifndef _STRPORT_H
+#include <sys/strport.h>	/* porting environment tailoring */
+#endif
+#ifndef _LIS_CONFIG_H
+#include <sys/strconfig.h>	/* streams config symbols are here */
+#endif
+#ifndef _STR_MSG_H
+#include <sys/strmsg.h>		/* streams msgs */
+#endif
+#ifndef _STR_OPTS_H
+#include <sys/stropts.h>	/* streams operations */
+#endif
+#ifndef _MSG_H
+#include <sys/LiS/msg.h>	/* streams msg symbols & types */
+#endif
+#ifndef _MSGUTL_H
+#include <sys/LiS/msgutl.h>	/* streams msg utilities  */
+#endif
+#ifndef _QUEUE_H
+#include <sys/LiS/queue.h>	/* streams queue symbols & types */
+#endif
+#ifndef _EVENTS_H
+#include <sys/LiS/events.h>	/* streams events  */
+#endif
+#ifndef _MOD_H
+#include <sys/LiS/mod.h>	/* streams module symbols & types */
+#endif
+#ifndef _POLL_H
+#include <sys/LiS/poll.h>	/* streams module symbols & types */
+#endif
+
+/*  -------------------------------------------------------------------  */
+/*				   Symbols                               */
+
+/* Close time max.
+ */
+#define LIS_MAX_CLTIME	1000*60*5	/* in m.seconds -> 5min */
+
+/* Link time, default & max.
+ */
+#define LIS_MAX_LNTIME  1000*60*5
+#define LIS_LNTIME	1000*15
+
+/* str head default high/low water marks
+ */
+#define STRHIGH 5120
+#define STRLOW  1024
+
+/* str head flags 
+ */
+#define STWOPEN		0x00000001L /* someone's opening this */
+#define	RSLEEP		0x00000002L /* someone wants to read/recv msg */
+#define	WSLEEP		0x00000004L /* someone wants to write */
+#define	IOCWAIT		0x00000008L /* someone wants to do ioctl */
+#define	STRCLOSE	0x00000010L /*!wait for a close to complete */
+#define	STRPLUMB	0x00000020L /*!push/pop pending */
+#define STRHOLD		0x00000040L /* use stream hold on write feature */
+#define	STPLEX		0x00001000L /* multiplexed stream */
+#define	STRISTTY	0x00002000L /* stream is a terminal */
+#define	STRTOSTOP	0x00004000L /* block background writes */
+#define	STRSIGPIPE	0x00008000L /* send SIGPIPE on write errors */
+#define	STRPRI		0x00010000L /* An M_PCPROTO is at stream head */
+#define	STRDERR		0x00020000L /* fatal read error from M_ERROR */
+#define	STWRERR		0x00040000L /* fatal write error from M_ERROR */
+#define	STRHUP		0x00080000L /* Device has vanished */
+#define	SNDMREAD	0x00100000L /* used for read notification */
+#define	OLDNDELAY	0x00200000L /* use old TTY semantics for */
+				    /* NDELAY reads and writes */
+#define	STRDELIM	0x00400000L /* generate delimited messages ???*/
+#define STIOCTMR	0x01000000L /* ioctl timer in progress */
+/*  -------------------------------------------------------------------  */
+
+/* Should be in head->magic, it's used to cach 254/255 ;) 
+ * danglind references to a stream heads in critical places
+ */
+#define STDATA_MAGIC (0x11110000L | sizeof(stdata_t))
+
+
+
+/*  -------------------------------------------------------------------  */
+/*				    Types                                */
+
+/*
+ * This structure is embedded in the stdata struct.  It is used for
+ * maintaining the topology of multiplexors.  When the user does
+ * an ioctl(fd, I_LINK, muxfd), the stream represented by muxfd
+ * is linked "below" the stream driver represented by fd.  The
+ * stdata struct of fd uses mx_hd as a list head to thread together
+ * all such streams that were linked below it.  The mx_next field
+ * carries the links.
+ *
+ * The muxfd stream is marked as belonging to a multiplexor and
+ * cannot be operated on with file I/O routines, except close.
+ *
+ * The muxfd stream has its refcnt incremented so that if it is
+ * closed it will not be deallocated.
+ *
+ * When it is time to unlink the stream it is removed from its list.
+ * The refcnt is then decremented and if it reaches zero the stream
+ * is deallocated.
+ *
+ * If you close the stream that heads a list (a so-called "control stream")
+ * then its list is traversed and each stream on the list is unlinked.
+ *
+ * The I_LINK ioctl returns a reference number, l_index, that is used
+ * by the user to unlink the stream with ioctl(fd, I_UNLINK, l_index).
+ * The list of streams headed by fd is scanned and the one with the
+ * mx_index equal to l_index is unlinked.
+ */
+#ifdef __KERNEL__
+typedef 
+struct stmux
+{
+    int            mx_cmd;	/* I_LINK or I_PLINK */
+    int		   mx_index;	/* l_index for this mux */
+    struct stdata *mx_hd;	/* list head for control stream */
+    struct stdata *mx_next;	/* list threaded through here */
+
+} stmux_t;
+#endif
+
+
+/*
+ * The stdata struct. This is the main stream structure and is pointed by
+ * the file system inode for the stream.
+ * It correspond with the STREAM head.
+ */
+
+#ifdef __KERNEL__
+typedef
+struct stdata
+{
+        long              magic; 	/* should be always STDATA_MAGIC */
+	struct stdata	 *sd_next ;	/* all stdatas are linked together */
+	struct stdata	 *sd_prev ;
+        struct streamtab *sd_strtab;    /* pointer to streamtab for stream */
+        struct queue     *sd_wq;        /* write queue */
+	mblk_t           *sd_wmsg;      /* buff for write msg */
+	mblk_t           *sd_iocblk; 	/* data block for ioctl */
+	int  sd_open_flags ;		/* flags that opened stream */
+	int  sd_scantimer;		/* scanq timer handle */
+	int  sd_iocseq;			/* ioc seq # */
+        int  sd_session;                /* controlling session id */
+        int  sd_pgrp;                   /* controlling process group id */
+        long sd_flag;                   /* state/flags */
+        int  sd_pushcnt;                /* number of pushes done on stream */
+        int  sd_sigflags;               /* logical OR of all siglist events */
+        int  sd_events;                 /* logical OR of all eventlist events*/
+        int  sd_rdopt;			/* read options */
+        int  sd_wropt;			/* write options */
+        int  sd_closetime;              /* time to wait to drain q in close */
+        int  sd_close_timer;		/* timer handle for close timer */
+        int  sd_rerror;                 /* read error to set u.u_error */
+        int  sd_werror;                 /* write error to set u.u_error */
+	int  sd_maxpushcnt;	        /* currently there's no limit in 
+					 * # of pushed mods, but let's set up
+					 * an artificial one to aid debugging*/
+        long sd_maxpsz;                 /* max pkt size --should be a cache*/
+        long sd_minpsz;                 /* min pkt size   of below module's */
+	unsigned short     sd_wroff;	/* write offset for downstream data */
+	struct strevent   *sd_siglist;  /* processes to be sent SIGPOLL */
+	struct pollhead    sd_polllist;	/* polling processes*/
+	struct semaphore   sd_wopen;	/* Waiting for open/close to complete*/
+        struct semaphore   sd_wwrite;   /* wait to room for write */
+        struct semaphore   sd_wread;    /* wait for msg to arrive */
+        struct semaphore   sd_wioc;     /* wait for ioctl */
+	struct semaphore   sd_wiocing;  /* wait for iocl response */
+	struct semaphore   sd_closing;	/* waiting to close */
+	unsigned short     sd_refcnt;	/* reference count */
+	unsigned short     sd_linkcnt;	/* # of I_PLINKs done via stream */
+        struct stmux       sd_mux;      /* info for muxing streams */
+        int		   sd_l_index;	/* muxid cntr for stream head */
+        dev_t		   sd_dev ;	/* major/minor from inode */
+	int		   sd_filetbl_size ;	/* size of filetbl */
+	struct file	 **sd_filetbl ;	/* tbl of files using this stream */
+	lis_select_t	   sd_select ;	/* abstract select structure */
+					/* see *-mdep.h */
+
+} stdata_t;
+
+extern stdata_t		*lis_stdata_head ;	/* to list of stdatas */
+
+#endif
+
+#define	SD_FILETBL_DFLT		32	/* default size of file table */
+
+
+/*  -------------------------------------------------------------------  */
+/*				 Glob. Vars.                             */
+
+/* Scheduling  & scan list
+ */
+#ifdef __KERNEL__
+extern volatile queue_t *lis_sched_first, *lis_sched_last; /* sched list */
+extern struct queue	*lis_qhead; /* first scheduled queue	*/
+extern struct queue	*lis_qtail; /* last scheduled queue		*/
+extern struct queue	*lis_scanqhead;	/* head of STREAMS scan queue	*/
+extern struct queue	*lis_scanqtail;	/* tail of STREAMS scan queue	*/
+extern char lis_qrunflag;	/*set if there is at least one enabled queue*/
+extern char lis_queueflag;	/*the function queuerun is running    	*/
+
+/* cfg. opts.
+ */
+extern int lis_nstrpush;	/* maximum # of pushed modules */
+extern int lis_strhold;		/* if not zero str hold feature's activated*/
+extern unsigned long lis_strthresh;	/* configurable STREAMS memory limit */
+extern unsigned long lis_iocseq; /* ioctl id */
+#endif
+
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+
+/* The streams file ops
+ * these are the entry points into the LiS subsystem.
+ * in response to a system call the Linux kernel will dispatch to
+ * one of these entries.
+ * -- see "The design of the unix operating system" (Bach)
+ */
+#ifdef __KERNEL__
+extern int 
+lis_stropen( struct inode *, struct file *);
+extern int
+lis_strwrite(struct inode *, struct file *, const char *,  int);
+extern int
+lis_strread(struct inode *, struct file *, char *,  int);
+extern int
+lis_strioctl(struct inode *, struct file *, unsigned int, unsigned long);
+extern int
+lis_strputpmsg(struct inode *, struct file *, void *, void *, int, int);
+extern int
+lis_strgetpmsg(struct inode *, struct file *, void *, void *, int *,int *,int);
+extern int
+lis_strpoll(struct inode *i, struct file *f, void *ptr) ;
+extern void
+lis_strclose(struct inode *i, struct file *f);
+
+/* Initialize some glob vars...
+ */
+extern void
+ lis_init_head( void );
+
+/*
+ * Hook a new inode onto a stream head.
+ */
+int	lis_new_inode(struct inode *oldi, struct inode *newi) ;
+
+/*
+ * Run the STREAMS queues
+ */
+void	lis_run_queues(void) ;
+
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+#endif /*!_HEAD_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/linux-mdep.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/linux-mdep.h
--- debug/drivers/streams/LiS/include/sys/LiS/linux-mdep.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/linux-mdep.h	Wed Jan  1 13:04:38 1997
@@ -0,0 +1,328 @@
+/*                               -*- Mode: C -*- 
+ * mdep.h --- machine (actually kernel) dependencies.
+ * Author          : Francisco J. Ballesteros
+ * Created On      : Tue May 31 21:40:37 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: linux-mdep.h,v 1.15 1996/01/27 00:40:26 dave Exp $
+ * Purpose         : provide kernel independence as much as possible
+ *                 : This could be also considered to be en embryo for
+ *                 : dki stuff,i.e. linux-dki
+ * ----------------______________________________________________
+ *
+ *    Copyright (C) 1995  Francisco J. Ballesteros, Denis Froschauer
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach su by email to any of
+ *    nemo@ordago.uc3m.es, 100741.1151@compuserve.com
+ *    dave@gcom.com
+ */
+
+#ifndef _LIS_M_DEP_H
+#define _LIS_M_DEP_H 1
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#ifndef _SYS_TYPES_H
+#include <sys/types.h>
+#endif
+
+/* kernel includes go here */
+#ifdef __KERNEL__
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>        /* common system types */
+#include <linux/kdev_t.h>	/* 1.3.xx needs this */
+#include <linux/sched.h>	/* sleep,wake,... */
+#include <linux/wait.h>
+#include <linux/config.h>
+#include <linux/kernel.h>	/* suser,...*/
+#include <linux/interrupt.h>
+#include <linux/major.h>
+#include <linux/fs.h>		/* inodes,... */
+#include <linux/fcntl.h>	/* inodes,... */
+#include <linux/string.h>	/* memcpy,... */
+#include <linux/timer.h>	/* timers */
+#include <linux/mm.h>		/* memory manager, pages,... */
+#include <linux/malloc.h>	/* memory manager, pages,... */
+#include <linux/stat.h>		/* S_ISCHR */
+#include <asm/segment.h>	/* memcpy_{to,from}_fs */
+#include <asm/system.h>		/* sti,cli */
+#include <sys/errno.h>	      /* for errno */
+#include <sys/signal.h>	      /* for signal numbers */
+#endif /* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+
+/* some missing symbols
+ */
+
+#ifdef __KERNEL__
+#define SECS_TO(t)	(t)	/* pass secs to system tmout time units */
+
+extern long lis_time_till(long target_time);
+extern long lis_target_time(long milli_sec);
+#endif				/* __KERNEL__ */
+
+/* some missing generic types 
+ */
+#undef uid 
+#undef gid
+typedef int     o_uid_t;
+typedef int     o_gid_t;
+typedef unsigned   char uchar;
+typedef struct cred {
+	uid_t	cr_uid;			/* effective user id */
+	gid_t	cr_gid;			/* effective group id */
+	uid_t	cr_ruid;		/* real user id */
+	gid_t	cr_rgid;		/* real group id */
+} cred_t;
+
+
+#ifdef __KERNEL__
+#define lis_suser(fp)	suser()
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+
+
+#ifdef __KERNEL__
+#define lis_free_page(cp) free_page((unsigned long)(cp))
+
+#define PRINTK		printk
+
+/* should well-define this...
+ */
+#define ASSERT(x)
+
+/* disable/enable interrupts
+ */
+#define SPLSTR(x)	{ save_flags(x) ; cli() ; }	/* save intr state */
+#define SPLX(x)		restore_flags(x)		/* restore intr state */
+#define	SPL0(x)		sti()				/* ignore arg */
+
+/*
+ * lis_up and lis_down (Linux semaphores)
+ */
+extern int	lis_down(struct semaphore *sem) ;	/* in linux-mdep.c */
+#define	lis_up	up			/* same as system 'up' */
+
+/* lock inodes...
+ */
+#define	LOCK_INO(i)	lis_down(&i->i_sem)
+#define	ULOCK_INO(i)	lis_up(&i->i_sem)
+
+/*
+ * Access inode field of file structure.
+ */
+#define STR_FILE_INODE(f)	(f)->f_inode
+
+/*
+ * Clone driver support
+ */
+extern struct inode 	*lis_pick_inode(struct inode *old,
+					struct inode *new,
+					dev_t         dev);
+
+/*
+ * Initialize a semaphore
+ */
+#ifdef VERSION_2
+#define SEM_INIT(sem_addr,cntr)						\
+			    {						\
+				(sem_addr)->count	= cntr ;	\
+				(sem_addr)->waking	= 0 ;		\
+				(sem_addr)->lock	= 0 ;		\
+				(sem_addr)->wait	= NULL ;	\
+			    }
+#else
+#define SEM_INIT(sem_addr,cntr)						\
+			    {						\
+				(sem_addr)->count	= cntr ;	\
+				(sem_addr)->wait	= NULL ;	\
+			    }
+#endif
+#define	SEM_DESTROY(sem_addr)		/* no such function in Linux */
+
+/* Use Linux system macros for MAJOR and MINOR */
+#define	STR_MAJOR		MAJOR
+#define	STR_MINOR		MINOR
+#endif				/* __KERNEL__ */
+
+/************************************************************************
+*                            major/minor                                *
+*************************************************************************
+*									*
+* Macros to extract the major and minor device numbers from a dev_t	*
+* variable.								*
+*									*
+************************************************************************/
+
+/*
+ * Major and minor macros come from linux ./include/linux/kdev_t.h
+ *
+ * If sysmacros.h has been included it defines major and minor in
+ * the old way.  We want the new way so we undefine them and redefine
+ * them to use the kdev_t style.
+ */
+#ifdef major
+#undef major
+#endif
+#ifdef minor
+#undef minor
+#endif
+#ifdef makedevice
+#undef makedevice
+#endif
+
+#ifndef _SYS_SYSMACROS_H
+#define _SYS_SYSMACROS_H		/* pretend sysmacros.h included */
+#endif
+
+#define	major(dev_t_var)	MAJOR(dev_t_var)
+#define	minor(dev_t_var)	MINOR(dev_t_var)
+#define makedevice(majornum,minornum)	MKDEV(majornum,minornum)
+
+typedef unsigned long	major_t ;	/* mimics SVR4 */
+typedef unsigned long	minor_t ;	/* mimics SVR4 */
+
+/*
+ * There is no STREAMS FIFO implemented as yet.  Therefore, we declare
+ * its major number here as an impossible value.
+ */
+#define	LIS_FIFO	(-1)
+
+
+
+#ifdef __KERNEL__
+
+#ifndef VOID
+#define VOID	void
+#endif
+
+#define UID(fp)	  current->uid
+#define GID(fp)	  current->gid
+#define EUID(fp)  current->euid
+#define EGID(fp)  current->egid
+#define PGRP(fp)  current->pgrp
+#define PID(fp)	  current->pid
+
+#define OPENFILES()	current->files->count
+#define SESSION()	current->session
+#define FILE2INO(fd)	NULL
+#define INO_STR(i)	((struct stdata *) ((i)->u.generic_ip))
+#define DBLK_ALLOC(n,f,l)	lis_malloc(n,GFP_ATOMIC | GFP_DMA,f,l)
+#define ALLOC(n)		lis_malloc(n,GFP_ATOMIC,__FILE__,__LINE__)
+#define ALLOCF(n,f)		lis_malloc(n,GFP_ATOMIC, f __FILE__,__LINE__)
+#define MALLOC(n)		lis_malloc(n,GFP_ATOMIC,__FILE__,__LINE__)
+#define LISALLOC(n,f,l)		lis_malloc(n,GFP_ATOMIC,f,l)
+#define FREE(p)			lis_free(p,__FILE__,__LINE__)
+#define	KALLOC(n,c)		kmalloc(n,c)
+#define	KFREE(p)		kfree(p)
+#define MEMCPY(dest, src, len)	memcpy(dest, src, len)
+#define PANIC(msg)		panic(msg)
+
+struct stdata	*lis_fd2str(int fd) ;	/* file descr -> stream */
+
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+
+/* This should be entry points from the kernel into LiS
+ * kernel should be fixed to call them when appropriate.
+ */
+
+/* some kernel memory has been free'd 
+ * tell STREAMS
+ */
+#ifdef __KERNEL__
+extern void
+lis_memfree( void );
+
+/* Get avail kernel memory size
+ */
+#define lis_kmemavail()	((unsigned long)-1) /* lots of mem avail :) */
+
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+/* This will copyin usr string pointed by ustr and return the result  in
+ * *kstr. It will stop at  '\0' or max bytes copyed in.
+ * caller should call free_page(*kstr) on success.
+ * Will return 0 or errno
+ */
+#ifdef __KERNEL__
+int 
+lis_copyin_str(struct file *fp, const char *ustr, char **kstr, int max);
+
+/* Just another copy in / out
+ */
+#define lis_copyin(fp,kbuf,ubuf,len)	memcpy_fromfs(kbuf,ubuf,len)
+#define lis_copyout(fp,kbuf,ubuf,len)	memcpy_tofs(ubuf,kbuf,len)
+
+/* check a user memory area
+ */
+#define lis_check_umem(fp,f,p,l)	verify_area(f,p,l)
+
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+
+/*
+ * The routine 'lis_runqueues' just requests that the queues be run
+ * at a later time.  A daemon process runs the queus with the help
+ * of a special driver.  This driver has the routine lis_setqsched
+ * in it.  See drivers/str/runq.c.
+ */
+#ifdef __KERNEL__
+extern void	lis_setqsched(void) ;
+#define	lis_runqueues		lis_setqsched
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+
+/*
+ * The routine 'lis_select' handles select calls from the Linux kernel.
+ * The structure 'lis_select_t' is embedded in the stdata structure
+ * and contains the wait queue head.
+ */
+#ifdef __KERNEL__
+
+typedef struct lis_select_struct
+{
+    struct wait_queue	*sel_wait ;
+
+} lis_select_t ;
+
+extern int	lis_select(struct inode *inode, struct file *file,
+			   int sel_type, select_table *wait) ;
+
+extern void	lis_select_wakeup(struct stdata *hd) ;
+
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+
+
+
+
+#endif /*!__LIS_M_DEP_H*/
+
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/log.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/log.h
--- debug/drivers/streams/LiS/include/sys/LiS/log.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/log.h	Mon Dec 16 16:36:39 1996
@@ -0,0 +1,3 @@
+#define LOG_INUSE 01
+#define LOG_WRITE 02
+#define LOG_READ  04
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/loop.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/loop.h
--- debug/drivers/streams/LiS/include/sys/LiS/loop.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/loop.h	Sat Dec 28 12:06:17 1996
@@ -0,0 +1,8 @@
+#define	LOOP_IOCTL(n)	(('l' << 8) | (n))
+#define LOOP_SET	LOOP_IOCTL(1)
+#define LOOP_PUTNXT	LOOP_IOCTL(2)
+#define	LOOP_MSGLVL	LOOP_IOCTL(3)
+#define	LOOP_TIMR	LOOP_IOCTL(4)
+#define	LOOP_MARK	LOOP_IOCTL(5)
+#define	LOOP_GET_DEV	LOOP_IOCTL(6)
+#define	LOOP_BUFCALL	LOOP_IOCTL(7)
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/minimux.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/minimux.h
--- debug/drivers/streams/LiS/include/sys/LiS/minimux.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/minimux.h	Mon Dec 16 16:36:40 1996
@@ -0,0 +1,3 @@
+#define	MINIMUX_IOCTL(n)	(('m' << 8) | (n))
+#define MINIMUX_DOWN		MINIMUX_IOCTL(1)
+#define MINIMUX_UP		MINIMUX_IOCTL(2)
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/mod.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/mod.h
--- debug/drivers/streams/LiS/include/sys/LiS/mod.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/mod.h	Wed Jan  1 13:04:39 1997
@@ -0,0 +1,289 @@
+/*                               -*- Mode: C -*- 
+ * mod.h --- mod management 
+ * Author          : Francisco J. Ballesteros
+ * Created On      : Tue May 31 21:40:37 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : : mod.h,v 1.5 1995/10/13 23:54:13 nemo Exp $
+ * Purpose         : keep close all the mod related stuff.
+ * ----------------______________________________________________
+ *
+ *    Copyright (C) 1995  Francisco J. Ballesteros,  Denis Froschauer
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    nemo@ordago.uc3m.es, 100741.1151@compuserve.com
+ */
+
+#ifndef _MOD_H
+#define _MOD_H 1
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#ifndef _STRPORT_H
+#include <sys/strport.h>
+#endif
+#ifndef _LIS_CONFIG_H
+#include <sys/strconfig.h>	/* config definitions */
+#endif
+#ifndef _SHARE_H
+#include <sys/LiS/share.h>	/* streams shared defs*/
+#endif
+
+/*  -------------------------------------------------------------------  */
+/*                                 Symbols                               */
+
+#ifdef __KERNEL__
+/* module open flags
+ */
+#define DEVOPEN		2	/* device open */
+#define MODOPEN		0       /* plain module open */
+#define CLONEOPEN	1       /* clone open -> pick new minor dev */
+
+/* NOTE! MODOPEN is overloaded: it's used as the clone flag and also as
+ * the open mode :(
+ */
+
+/* Predefined streams drivers are defined in the kernel device major defs.
+ */
+
+/* Null module id
+ */
+
+int	lis_findmod(const char *name) ;
+
+#endif /* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+/*				    Types                                */
+
+/*
+ * Module Configuration
+ *
+ * A table of the following entry types must be linked in with
+ * streams to define all the non-driver type modules that are
+ * present.  There is one entry per module.
+ *
+ * The fields are:
+ *
+ *	cnf_name	The ASCII string name of the module.
+ *	cnf_str		A pointer to the streamtab entry for the module.
+ * 
+ * This table is used at initialization time to register the modules
+ * with streams, thus inserting them into the fmod_sw table.
+ * 
+ * The final entry in the table consists of {"", NULL}.
+ *
+ * The file modconf.c provides such a table and is automatically
+ * generated by the strconf utility.  DO NOT EDIT modconf.c BY HAND.
+ */
+typedef struct module_config
+{
+    char               cnf_name[FMNAMESZ+1];
+    struct streamtab  *cnf_str;
+
+} module_config_t ;
+
+extern module_config_t		lis_module_config[] ;
+
+/*
+ * Driver Configuration
+ *
+ * In order to configure streams drivers a table of the following form
+ * must be linked into the streams code.  The fields are as follows:
+ *
+ *	cnf_name	ASCII string name associated with the driver.
+ *	cnf_str		Pointer to the driver's streamtab entry.
+ *	cnf_major	The major device number to associate with the driver.
+ *			This must correspond with the major device number
+ *			used in a mknod() system call from user level
+ *			to make the device corresponding to this driver.
+ *	cnf_n_minors	The number of minors associated with the driver.
+ *
+ * This table is used at initialization time to register the drivers
+ * with streams, thus getting them into the fstr_sw table.
+ *
+ * The final entry in the table is of the form:
+ *
+ *	{"", NULL, 0, 0}
+ * 
+ * The file modconf.c provides such a table and is generated by the
+ * strconf utility.  DO NOT EDIT modconf.c BY HAND.
+ * 
+ */
+typedef struct driver_config
+{
+    char		 cnf_name[FMNAMESZ+1];
+    struct streamtab	*cnf_str;
+    int			 cnf_major;
+    int			 cnf_n_minors;
+
+} driver_config_t ;
+
+extern driver_config_t		lis_driver_config[] ;
+
+
+
+/*
+ *  The streamtab data structure. This one is used to find modules and
+ * drivers entry points.
+ * Actually this struct defines a module or driver.
+ */
+
+typedef 
+struct streamtab {
+  SHARE
+        struct qinit *st_rdinit; /* read queue */
+        struct qinit *st_wrinit; /* write queue */
+        struct qinit *st_muxrinit; /* mux read queue */
+        struct qinit *st_muxwinit; /* mux write queue */
+} streamtab_t;
+
+#ifdef __KERNEL__
+
+/* Module information structure. Linux modules stuff should go here.
+ */
+typedef unsigned short modID_t;
+#define LIS_NULL_MID ((modID_t)0)
+
+typedef
+struct module_info {
+  SHARE
+        modID_t mi_idnum;               /* module id number */
+        const char *mi_idname;          /* module name */
+        long    mi_minpsz;              /* min packet size accepted */
+        long    mi_maxpsz;              /* max packet size accepted */
+        ulong   mi_hiwat;               /* hi-water mark */
+        ulong   mi_lowat;               /* lo-water mark */
+} module_info_t;
+
+/*
+ *  Per-Module statistic record
+ */
+
+typedef
+struct module_stat {
+  SHARE
+    char *ms_xptr;              /* pointer to private statistics */
+    short ms_xsize;             /* length of private statistics buffer */
+    uint ms_flags;              /* bool stats -- for future use */
+  EXPORT
+    long ms_pcnt;               /* count of calls to put proc */
+    long ms_scnt;               /* count of calls to service proc */
+    long ms_ocnt;               /* count of calls to open proc */
+    long ms_ccnt;               /* count of calls to close proc */
+    long ms_acnt;               /* count of calls to admin proc */
+} module_stat_t;
+
+typedef
+struct fmodsw {
+        char               f_name[FMNAMESZ+1];
+        struct streamtab  *f_str;
+	ushort             f_count;
+} fmodsw_t;
+
+typedef struct lis_amod {
+    modID_t a_mid;		/* module id (idx in fmodsw) */
+    char a_minor;		/* minor */
+    char a_lminor;		/* last minor */
+} lis_amod_t;
+
+/* This list (lis_apush) has a list of autopushed modules for a
+   stream. Modules will be pushed from [0] to [MAX_STRAMOD]. The value in each
+   slot is just an index into the lis_fmod_sw arry, what means the module
+   should be loaded to be autopushed. */
+typedef lis_amod_t lis_apush_t[MAX_STRAMOD]; /* list of autopushed modules per
+					      * str. */
+
+#endif /* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+/*				 Glob. Vars.                             */
+#ifdef __KERNEL__
+
+
+extern struct fmodsw     lis_fstr_sw[MAX_STRDEV]; /* streams devices */
+extern struct fmodsw     lis_fmod_sw[MAX_STRMOD]; /* streams modules */
+extern int               lis_fmodcnt;             /* # of modules */
+extern lis_apush_t      *lis_str_amod[MAX_STRDEV];/* autopushed modules */
+
+#endif /* __KERNEL__ */
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+#ifdef __KERNEL__
+/* register a new module
+ */
+#define	register_strmod		lis_register_strmod
+extern int
+lis_register_strmod(struct streamtab *strtab, char *name);
+
+/* unregister this module
+ */
+#define	unregister_strmod	lis_unregister_strmod
+extern int
+lis_unregister_strmod(struct streamtab *strtab);
+
+/* Get strtab for mod or NULL if not a valid id
+ */
+#define lis_modstr(i)	(((i)<0)?NULL:lis_fmod_sw[i].f_str)
+
+/* register a new streams device
+ */
+#define	register_strdev		lis_register_strdev
+extern int 
+lis_register_strdev(int majnum, struct streamtab *strtab, int nminor,
+		    char *name);
+
+/* unregister a streams device
+ */
+#define	unregister_strdev		lis_unregister_strdev
+extern int 
+lis_unregister_strdev(uint majnum, struct streamtab *strtab, int nminor);
+
+/* Find streamtab of a device
+ */
+extern streamtab_t *
+lis_find_strdev(int maj) ;
+
+/* get the streamtab for a streams device
+ */
+#define LIS_DEVST(majnum)	lis_fstr_sw[majnum]
+
+/* This is to check for a valid STREAMS device 
+ */
+#define LIS_DEVOK(majnum) (lis_fstr_sw[majnum].f_str!=NULL)
+
+/* This will check what kind of device is this, there're a few predefined
+ * streams drivers -- see LIS_ symbols in the kernel major number defs.
+ * (linux/major.h for Linux)
+ */
+#define LIS_ISDEV(majnum,kind)	((majnum)==(kind))
+
+/* Get the streamtab for the autopush module #n in stream w/ dev d
+ */
+extern streamtab_t *
+lis_apushm( int idx, dev_t dev);
+
+#endif /* __KERNEL__ */
+/*  -------------------------------------------------------------------  */
+#endif /*!_MOD_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/msg.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/msg.h
--- debug/drivers/streams/LiS/include/sys/LiS/msg.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/msg.h	Wed Jan  1 13:04:39 1997
@@ -0,0 +1,257 @@
+/*                               -*- Mode: C -*- 
+ * msg.h --- streams message handling
+ * Author          : Graham Wheeler
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: msg.h,v 1.3 1996/01/27 00:40:27 dave Exp $
+ * Purpose         : provide streams message handling
+ *                 : this is the main memory allocation related module.
+ * ----------------______________________________________________
+ *
+ *   Copyright (C) 1995  Graham Wheeler
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach me by email to
+ *    gram@aztec.co.za
+ */
+
+
+#ifndef _MSG_H
+#define _MSG_H 1
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#ifndef _SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifndef _SHARE_H
+#include <sys/LiS/share.h>
+#endif
+#ifndef _LIS_CONFIG_H
+#include <sys/strconfig.h>	/* config definitions */
+#endif
+
+
+
+/*
+ * The memory allocation mechanism is based on that in SVR4.2.
+ * That is, all memory is allocated dynamically, with freed
+ * message headers being held on a free list. When kernel memory
+ * is low some of these can be reclaimed by calling strgiveback.
+ *
+ * Message headers are 128 bytes in size. The extra space
+ * is used as the data buffer for smallish messages. This
+ * scheme means that in most cases, a call to allocb just
+ * requires unlinking a message header from the free list
+ * and initialising it.
+ *
+ * This scheme does add some complexity, however, with
+ * regard to dupb/dupmsg. In this case the duplicate can
+ * have pointers to a data buffer within some other message
+ * header. Thus, if a message header is freed, we have to
+ * check if its internal data buffer is still in use by
+ * someone else, in which case we defer freeing the header;
+ * on the other hand, if we are freeing the last reference
+ * to some other data buffer in a message header, we have two
+ * headers to free. All of this logic is nicely hidden in freeb()
+ * (with a little bit of it leaking into pullupmsg).
+ *
+ * NB: This does rely on the fact that if a message block
+ * has a data buffer of FASTBUF or less in size and no special
+ * free function (i.e. it wasn't an esballoc), then that data
+ * buffer lives internally within some (not necessarily the same)
+ * message header, and was *not* allocated elsewhere.
+ *
+ * To put it another way, if you don't completely understand
+ * the memory management scheme, don't fiddle with any of
+ * the following code, and don't ever directly modify data
+ * block elements like db_base, db_lim and db_size.
+ */
+
+/*  -------------------------------------------------------------------  */
+/*				   Symbols                               */
+
+/* size of header and fastbuf data 
+ */
+#define HDRSZ	(sizeof(struct mbinfo)+sizeof(struct dbinfo))
+#define FASTBUF	(128-HDRSZ)		  /* space remaining for data	*/
+
+
+/* Code for M_ERROR msg 
+ */
+#define NOERROR ((u_char)-1)	/* ?? */
+
+/*  -------------------------------------------------------------------  */
+/* Priority for block allocs (ignored)
+ */
+#define BPRI_HI		0
+#define BPRI_MED	1
+#define BPRI_LO		2
+
+/* ininite packet size
+ */
+#ifndef INFPSZ
+#define INFPSZ  (-1)
+#endif
+
+
+/*  -------------------------------------------------------------------  */
+/*				    Types                                */
+
+/* This is a message block. Messages are lists of blocks
+ * It points to a data block which enable us to share data
+ * in msgs.
+ */
+
+typedef
+struct  msgb {
+  SHARE    
+        struct  msgb    *b_next; /* next msg on queue */
+        struct  msgb    *b_prev; /* prev msg on queue */
+        struct  msgb    *b_cont; /* next blk of msg */
+        unsigned char   *b_rptr; /* 1st unread byte */
+        unsigned char   *b_wptr; /* 1st unwriten byte */
+  EXPORT
+        struct datab    *b_datap; /* pointer to data */
+        unsigned char	 b_band;  /* message priority */
+        unsigned char	 b_pad1;
+  PRIVATE
+	unsigned short	 b_flag;  /* see below */
+        long         	 b_pad2;
+} msgb_t;
+
+typedef msgb_t mblk_t;
+
+/*
+ * Msg flags 
+ */
+#define	MSGMARK		0x01	/* last byte of message is "marked" */
+#define	MSGNOLOOP	0x02	/* stream head won't loop around to write q */
+#define	MSGDELIM	0x04	/* message is delimited */
+
+
+/* This is the data block. It stores data for a message block
+ */
+typedef
+struct datab {
+  SHARE
+        struct  free_rtn* frtnp;
+  EXPORT
+        unsigned char   *db_base;
+        unsigned char   *db_lim;
+        unsigned char   db_ref;
+	unsigned char	db_type; /* QNORM or QPCTL */
+  PRIVATE
+	unsigned char	db_iswhat;
+        unsigned int    db_size;
+	caddr_t	 	db_msgaddr;
+	long		db_filler;
+} datab_t;
+
+typedef datab_t dblk_t;
+
+/*
+ * This structure is used in calls to esballoc
+ */
+
+typedef
+struct free_rtn {
+  SHARE
+        void (*free_func)(char *);      /* the free() function */
+        char *free_arg;                 /* argument */
+} frtn_t;
+
+/* Structures for the message headers
+ */
+
+struct mbinfo{
+    mblk_t	m_mblock;
+    void	(*m_func)(void);
+};
+
+struct dbinfo{
+    dblk_t	d_dblock;
+};
+
+struct mdbblock{
+    struct mbinfo	msgblk;		  /* message block header info	*/
+    struct dbinfo	datblk;		  /* data block header info	*/
+    char   		databuf[FASTBUF]; /* internal small data buffer */
+};
+
+/*  -------------------------------------------------------------------  */
+/*				 Glob. Vars.                             */
+#ifdef __KERNEL__
+
+extern struct mdbblock  *lis_mdbfreelist; /* message block free list	*/
+extern int		 lis_strcount;	  /* # bytes allocated to msgs  */
+
+#endif /* __KERNEL__ */
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+#ifdef __KERNEL__
+
+/* lis_strgiveback - return some free headers to system heap
+ */
+extern void
+lis_strgiveback(unsigned long arg);
+
+/* allocb: allocate an M_DATA message block of the specified
+ *	size. The priority is for compatibility only.
+ *
+ */
+struct msgb *
+lis_allocb(int size, unsigned int priority, char *file_name, int line_nr);
+
+/* testb: see if an allocation can actually be done.
+ *
+ */
+extern int
+lis_testb(int size, unsigned int priority);
+
+/*
+ * esballoc: allocate a message block, using a user-provided data buffer
+ *
+ */
+extern mblk_t *
+lis_esballoc(unsigned char *base, int size, int priority,
+	     frtn_t *freeinfo, char *file_name, int line_nr);
+
+/* freeb - Free data buffer and place message block on free list. Don't
+ *      follow the continuation pointer.
+ *
+ */
+extern void lis_freeb(mblk_t *bp);
+extern void lis_freedb(mblk_t *bp, int free_hdr);
+
+/* freemsg - free a whole message
+ *
+ */
+void
+lis_freemsg(mblk_t *mp);
+
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+#endif /*!_MSG_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/msgutl.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/msgutl.h
--- debug/drivers/streams/LiS/include/sys/LiS/msgutl.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/msgutl.h	Wed Jan  1 13:04:39 1997
@@ -0,0 +1,229 @@
+/*                               -*- Mode: C -*- 
+ * msgutl.c --- streams message utilities.
+ * Author          : Graham Wheeler
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: msgutl.h,v 1.6 1996/01/27 00:40:27 dave Exp $
+ * Purpose         : here you have utilites to handle str messages.
+ *                 : 
+ * ----------------______________________________________________
+ *
+ *   Copyright (C) 1995  Graham Wheeler
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach me by email to
+ *    gram@aztec.co.za
+ */
+
+
+#ifndef _MSGUTL_H
+#define _MSGUTL_H 1
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#ifndef _LIS_CONFIG_H
+#include <sys/strconfig.h>	/* config definitions */
+#endif
+#ifndef _SHARE_H
+#include <sys/LiS/share.h>	/* streams shared defs*/
+#endif
+#ifndef _MSG_H
+#include <sys/LiS/msg.h>	/* streams messages */
+#endif
+
+
+
+/*
+ * The memory allocation mechanism is based on that in SVR4.2.
+ * That is, all memory is allocated dynamically, with freed
+ * message headers being held on a free list. When kernel memory
+ * is low some of these can be reclaimed by calling strgiveback.
+ *
+ * Message headers are 128 bytes in size. The extra space
+ * is used as the data buffer for smallish messages. This
+ * scheme means that in most cases, a call to allocb just
+ * requires unlinking a message header from the free list
+ * and initialising it.
+ *
+ * This scheme does add some complexity, however, with
+ * regard to dupb/dupmsg. In this case the duplicate can
+ * have pointers to a data buffer within some other message
+ * header. Thus, if a message header is freed, we have to
+ * check if its internal data buffer is still in use by
+ * someone else, in which case we defer freeing the header;
+ * on the other hand, if we are freeing the last reference
+ * to some other data buffer in a message header, we have two
+ * headers to free. All of this logic is nicely hidden in freeb()
+ * (with a little bit of it leaking into pullupmsg).
+ *
+ * NB: This does rely on the fact that if a message block
+ * has a data buffer of FASTBUF or less in size and no special
+ * free function (i.e. it wasn't an esballoc), then that data
+ * buffer lives internally within some (not necessarily the same)
+ * message header, and was *not* allocated elsewhere.
+ *
+ * To put it another way, if you don't completely understand
+ * the memory management scheme, don't fiddle with any of
+ * the following code, and don't ever directly modify data
+ * block elements like db_base, db_lim and db_size.
+ */
+
+/*  -------------------------------------------------------------------  */
+/*				   Symbols                               */
+
+/*  -------------------------------------------------------------------  */
+/*				    Types                                */
+
+/*  -------------------------------------------------------------------  */
+/*				 Glob. Vars.                             */
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+#ifdef __KERNEL__
+
+/* return bytes in first msg blk
+ */
+#define lis_mblksize(mp)	((mp)->b_wptr - (mp)->b_rptr)
+
+/* msgsize - count sizes of blocks of message
+ *
+ */
+extern int lis_msgsize(mblk_t *mp);
+
+/* msgdsize - return number of data bytes in M_DATA blocks in message
+ *
+ */
+extern int lis_msgdsize(mblk_t *mp);
+
+/* xmsgsize - count sizes of consecutive blocks of the same
+ *	type as the first
+ *
+ */
+extern int lis_xmsgsize(mblk_t *mp);
+
+/* adjmsg - trim abs(len) bytes from a message. If len<0, trim
+ *	from tail; else trim from head. If len is greater than
+ *      the message size or the trim crosses message blocks of
+ *      differing types, adjmsg fails. Any blocks that are
+ *	completely trimmed are not removed, but have their
+ *	rptrs set to their wptrs.
+ *	Returns 1 on success; 0 otherwise.
+ *
+ */
+extern int lis_adjmsg(mblk_t *mp, int length);
+
+/* copyb - create and return a copy of a message block
+ *
+ */
+extern mblk_t * lis_copyb(mblk_t *mp);
+
+/* lis_copymsg - create and return a copy of a message
+ *
+ */
+extern mblk_t * lis_copymsg(mblk_t *mp);
+
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+
+#ifdef __KERNEL__
+
+/*
+ * lis_dupb - duplicate a message block, updating the reference count.
+ *	The data block and data buffer are reused.
+ *
+ */
+extern mblk_t * lis_dupb(mblk_t *mp);
+
+/* lis_dupmsg - duplicate a message by duplicating the constituent
+ *	data blocks.
+ *
+ */
+extern mblk_t * lis_dupmsg(mblk_t *mp);
+
+/*
+ * lis_linkb - concatenate mp1 and mp2.
+ *
+ */
+extern void lis_linkb(mblk_t *mp1, mblk_t *mp2);
+
+/* unlinkb - remove first message block from a message. Return the
+ *	next message block pointer, or NULL if no further blocks.
+ *
+ */
+extern mblk_t * lis_unlinkb(mblk_t *mp);
+
+
+/* lis_pullupmsg - attempt to merge the first len data bytes of a
+ *	message into a single block. If len is -1, all leading
+ *	blocks of the same type are merged.
+ *	The message header is reused, but a new data block and
+ *	data buffer are allocated for the first block.
+ *	Only blocks of the same type can be merged.
+ *	Returns 1 on success; 0 otherwise.
+ *
+ */
+extern int lis_pullupmsg(mblk_t *mp, int length);
+
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+#ifdef __KERNEL__
+/* lis_rmvb - remove message block bp from message mp. Returns a
+ *	pointer to the modified message, or NULL if bp was the
+ *	only block, or -1 if bp wasn't in the message
+ *
+ */
+extern mblk_t * lis_rmvb(mblk_t *mp, mblk_t *bp);
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+
+#ifdef __KERNEL__
+
+/* Check is msg is a data msg (should be given mp->b_datap->db_type)
+ */
+
+#define lis_datamsg(type)   \
+        ((type)==M_DATA         || (type)==M_PROTO      || \
+         (type)==M_PCPROTO      || (type)==M_DELAY         )
+
+/* Okay, let's do it the right way
+ */
+#define lis_isdatamsg(mp)   (lis_datamsg((mp)->b_datap->db_type))
+#define lis_isdatablk(dp)   (lis_datamsg((dp)->dbtype))
+
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+#ifdef __KERNEL__
+/* Some shorthands
+ */
+#define lis_btype(mp)	((mp)->b_datap->db_type)
+#define lis_bband(mp)	((mp)->b_band)
+#define queclass(bp)	(lis_bband(bp)) /* return band for bp */
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+#endif /*!_MSGUTL_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/poll.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/poll.h
--- debug/drivers/streams/LiS/include/sys/LiS/poll.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/poll.h	Wed Jan  1 13:04:39 1997
@@ -0,0 +1,82 @@
+/*                               -*- Mode: C -*- 
+ * poll.h --- poll() syscall
+ * Author          : Fco. J. Ballesteros
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: poll.h,v 1.3 1996/01/27 00:40:27 dave Exp $
+ * Purpose         : STREAMS poll() mechanism
+ * ----------------______________________________________________
+ *
+ *  Copyright (C) 1995  Francisco J. Ballesteros, Graham Wheeler
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to
+ *    nemo@ordago.uc3m.es, gram@aztec.co.za
+ */
+
+
+#ifndef _POLL_H
+#define _POLL_H 1
+/*  -------------------------------------------------------------------  */
+/*				   Symbols                               */
+
+/*  -------------------------------------------------------------------  */
+/*				    Types                                */
+
+/* Poll list head structure.  
+ */
+struct pollhead {
+	struct polldat	*ph_list;	/* list of pollers */
+};
+
+/* Data necessary to notify process sleeping in poll(2)
+ * when an event has occurred.
+ */
+struct polldat {
+	struct polldat	*pd_next;  /* next in poll list */
+	struct polldat	*pd_prev;  /* previous in poll list */
+	struct pollhead *pd_headp; /* backptr to pollhead */
+	short		pd_events; /* events being polled */
+	void    (*pd_fn)(long);    /* event callback fn */
+	long            pd_arg;	   /* arg to fn */
+};
+typedef struct pollhead pollhead_t;
+typedef struct polldat  polldat_t;
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+/*  -------------------------------------------------------------------  */
+/*				 Glob. Vars.                             */
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+
+#ifdef __KERNEL__
+/* poll() syscall entry point
+ */
+int lis_syspoll(char *ubuff, unsigned long n, int tmout);
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+#endif /*!_POLL_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/port-mdep.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/port-mdep.h
--- debug/drivers/streams/LiS/include/sys/LiS/port-mdep.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/port-mdep.h	Wed Jan  1 13:04:39 1997
@@ -0,0 +1,348 @@
+/*                               -*- Mode: C -*- 
+ * mdep.h --- machine (actually kernel) dependencies.
+ * Author          : David Grothe
+ * Created On      : Sat Dec 23 11:45:00 1995
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: port-mdep.h,v 1.10 1996/01/27 00:40:28 dave Exp $
+ * Purpose         : Map certain environment provided functions into abstract
+ *		   : names so that routines can be written for different
+ *		   : operating system environments.
+ * ----------------______________________________________________
+ *
+ *    Copyright (C) 1995  David Grothe
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach me by email to 
+ *    dave@gcom.com
+ *
+ * This file contains defines and externals for the portable version
+ * of STREAMS.  It matches up with port-mdep.c in the 'head' directory.
+ *
+ * There are a few typedefs (or structure definitions) left out
+ * of this file.  These are for environmental data types such as
+ * files and semaphores.  The idea is that you first include a more
+ * specfic -mdep.h file, such as user-mdep.h or qnx-mdep.h.  That
+ * file defines these necessary structures and then includes port-mdep.h.
+ *
+ * When compiling in the 'head' directory you can set compile-time
+ * switches to cause this to happen automatically via the file strport.h.
+ * These switches are:
+ *
+ *	-DUSER		Causes include of user-mdep.h and port-mdep.h
+ *	-DQNX		Causes include of qnx-mdep.h and port-mdep.h
+ *	-DLINUX		Causes include of linux-mdep.h only
+ *	-DPORTABLE	Causes just port-mdep.h to be included.  This will
+ *			lead to syntax errors due to the missing structure
+ *			declarations.
+ */
+
+#ifndef _PORT_MDEP_H
+#define _PORT_MDEP_H 1
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+/* operating system includes go here */
+
+#ifndef _SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifndef _STLIB_H
+#include <stdlib.h>	      /* for NULL, malloc, free */
+#endif
+#ifndef _STDIO_H
+#include <stdio.h>	      /* for printf */
+#endif
+#ifndef _FCNTL_H
+#include <fcntl.h>	      /* open flags, etc */
+#endif
+#ifndef _ASSERT_H
+#include <assert.h>	      /* for assert macro */
+#endif
+
+/*  -------------------------------------------------------------------  */
+
+
+/* some missing symbols
+ */
+
+#define SECS_TO(t)	(t)	/* pass secs to system tmout time units */
+
+/* some missing generic types 
+ */
+#define	dev_t	port_dev_t		/* our own definition */
+
+
+int	port_kill_proc(int pid, int sig, int priv) ;
+int	port_kill_pg (int pgrp, int sig, int priv) ;
+int	port_suser(struct file *fp) ;
+
+#define	lis_suser	port_suser		/* are we super user */
+#define	kill_proc	port_kill_proc		/* signal a process */
+#define	kill_pg		port_kill_pg		/* signal a process group */
+
+int	port_printf(char *fmt, ...) ;		/* printf routine */
+#define	printk		port_printf
+#define PRINTK		port_printf
+
+int	port_register_chrdev(unsigned major, char *name, 
+				struct file_operations *fops) ;
+int	port_unregister_chrdev(unsigned major, char *name) ;
+#define	register_chrdev		port_register_chrdev
+#define	unregister_chrdev	port_unregister_chrdev
+
+/*  -------------------------------------------------------------------  */
+/*                          Timer Structure				 */
+
+struct timer_list			/* borrowed from Linux kernel */
+{
+	struct timer_list *next;
+	struct timer_list *prev;
+	unsigned long	   tdelta;
+	unsigned long	   data;
+	void		 (*function)(unsigned long);
+};
+
+extern void port_add_timer(struct timer_list * timer);
+extern int  port_del_timer(struct timer_list * timer);
+extern void port_announce_time(long milli_sec);
+extern long port_time_till(long target_time);
+extern long port_target_time(long milli_sec);
+
+#define port_init_timer(timer)						\
+			    {						\
+				    (timer)->next = NULL;		\
+				    (timer)->prev = NULL;		\
+			    }
+
+#define	add_timer		port_add_timer
+#define	del_timer		port_del_timer
+#define	init_timer		port_init_timer
+#define	lis_time_till		port_time_till
+#define	lis_target_time		port_target_time
+
+/*  -------------------------------------------------------------------  */
+
+
+#define lis_free_page(cp) port_free_page((unsigned long)(cp))
+#define	lis_fd2str	  port_fd_to_str
+
+struct stdata		 *port_fd_to_str(int fd) ;
+
+/* should well-define this...
+ */
+#define ASSERT(e)		assert(e)
+
+/* disable/enable interrupts
+ */
+#define SPLSTR(x)	port_splstr(&(x))		/* save intr state */
+#define SPLX(x)		port_splx  (&(x))		/* restore intr state */
+#define	SPL0(x)		port_spl0  (&(x))		/* enable intrs */
+
+void	port_splstr(int *save_state) ;
+void	port_splx(int *saved_state) ;
+void	port_spl0(int *save_state) ;
+
+
+/* lock inodes...
+ */
+#define	LOCK_INO(i)	port_sem_P(&i->i_sem)
+#define	ULOCK_INO(i)	port_sem_V(&i->i_sem)
+
+/*
+ * Access inode field of file structure.
+ */
+#define STR_FILE_INODE(f)	(f)->f_inode
+
+/*
+ * Clone driver support
+ */
+#define	lis_pick_inode	 port_pick_inode
+extern struct inode 	*port_pick_inode(struct inode *old,
+					 struct inode *new,
+					 dev_t         dev);
+
+/************************************************************************
+*                          MAJOR/MINOR                                  *
+*************************************************************************
+*									*
+* These are macros that will extract the major and minor device		*
+* numbers from a port_dev_t variable.					*
+*									*
+* Note that in SVR4 these are 16-bits each.  We therefore assume that	*
+* port_dev_t is a 32-bit long.						*
+*									*
+* Also note that for the Linux kernel version of STREAMS, dev_t is	*
+* a 16 bit number and these macros are defined differently in		*
+* linux-mdep.h.								*
+*									*
+************************************************************************/
+
+#define	STR_MAJOR(port_dev_t_var)	MAJOR((port_dev_t_var))
+#define	STR_MINOR(port_dev_t_var)	MINOR((port_dev_t_var))
+
+
+#ifndef VOID
+#define VOID	void
+#endif
+
+/*
+ * for passing to mem allocators
+ */
+#define	GFP_ATOMIC		0x01
+#define	GFP_DMA			0x02
+
+#define UID(x)			port_get_uid((x))
+#define GID(x)			port_get_gid((x))
+#define EUID(x)			port_get_euid((x))
+#define EGID(x)			port_get_egid((x))
+#define PGRP(x)  		port_get_pgrp((x))
+#define PID(x)			port_get_pid((x))
+
+#define OPENFILES()		port_openfiles()
+#define SESSION(f)		port_session((f))
+#define FILE2INO(fd)		port_file_to_ino(fd)
+#define INO_STR(i)		(stdata_t *) ( (i)->i_str )
+#define DBLK_ALLOC(n,f,l)	lis_malloc(n,GFP_ATOMIC | GFP_DMA,f,l)
+#define ALLOC(n)		lis_malloc(n,GFP_ATOMIC,__FILE__,__LINE__)
+#define ALLOCF(n,f)		lis_malloc(n,GFP_ATOMIC, f __FILE__,__LINE__)
+#define MALLOC(n)		lis_malloc(n,GFP_ATOMIC,__FILE__,__LINE__)
+#define LISALLOC(n,f,l)		lis_malloc(n,GFP_ATOMIC,f,l)
+#define FREE(p)			lis_free(p,__FILE__,__LINE__)
+#define	KALLOC(n,c)		port_malloc(n,c)
+#define	KFREE(p)		port_free(p)
+#define MEMCPY(dest, src, len)	port_memcpy(dest, src, len)
+#define PANIC(msg)		port_panic(msg)
+
+int		 port_get_uid(struct file *) ;
+int		 port_get_gid(struct file *) ;
+int		 port_get_euid(struct file *) ;
+int		 port_get_egid(struct file *) ;
+int		 port_get_pgrp(struct file *) ;
+int		 port_get_pid(struct file *) ;
+
+void		*port_malloc(int size, int class) ;
+void		 port_free(void *ptr) ;
+void		 port_print_mem(void) ;
+void		 port_memcpy(void *dest, void *src, int len) ;
+void		 port_panic(char *msg) ;
+
+int		 port_openfiles(void) ;
+int		 port_session(struct file *) ;
+struct inode	*port_file_to_ino(int fd) ;
+
+int		 port_sem_P(struct semaphore *sem_addr) ;
+void		 port_sem_V(struct semaphore *sem_addr) ;
+void		 port_sem_init(struct semaphore *sem_addr, int counter) ;
+void		 port_sem_destroy(struct semaphore *sem_addr) ;
+
+#define	lis_down(sem_addr)	 port_sem_P(sem_addr)
+#define	lis_up(sem_addr)	 port_sem_V(sem_addr)
+#define	SEM_INIT(sem_addr,cntr)	 port_sem_init(sem_addr, cntr)
+#define	SEM_DESTROY(sem_addr)	 port_sem_destroy(sem_addr)
+
+/*  -------------------------------------------------------------------  */
+
+/* This should be entry points from the environment into LiS.
+ * The surrounding OS should be fixed to call them when appropriate.
+ */
+
+void		port_init(void) ;		/* intialize STREAMS */
+
+/* some kernel memory has been free'd 
+ * tell STREAMS
+ */
+extern void
+lis_memfree( void );
+
+/* Get avail kernel memory size
+ */
+#define lis_kmemavail()	((unsigned long)-1) /* lots of mem avail :) */
+
+/*  -------------------------------------------------------------------  */
+/* This will copyin usr string pointed by ustr and return the result  in
+ * *kstr. It will stop at  '\0' or max bytes copyed in.
+ * caller should call free_page(*kstr) on success.
+ * Will return 0 or errno
+ * STATUS: complete, untested
+ */
+#define	lis_copyin_str		port_copyin_str
+int	port_copyin_str(struct file *fp, const char *ustr,
+			char **kstr, int max) ;
+
+/* Just another copy in / out
+ */
+#define lis_copyin(fp,kbuf,ubuf,len)	port_memcpy_fromfs(fp,kbuf,ubuf,len)
+#define lis_copyout(fp,kbuf,ubuf,len)	port_memcpy_tofs(fp,kbuf,ubuf,len)
+
+void	port_memcpy_fromfs(struct file *fp, void *kbuf,
+					const void *ubuf, int len) ;
+void	port_memcpy_tofs(struct file *fp, const void *kbuf,
+					    void *ubuf, int len) ;
+int	port_get_fs_byte(struct file *fp, const void *uaddr) ;
+
+/* check a user memory area
+ */
+#define lis_check_umem(fp,f,p,l)	port_verify_area(fp,f,p,l)
+int	port_verify_area(struct file *fp, int rd_wr_fcn,
+			 const void *usr_addr, int lgth);
+
+#ifndef VERIFY_READ	
+#define VERIFY_READ 0		/* argument for lis_check_umem */
+#endif
+#ifndef VERIFY_WRITE	
+#define VERIFY_WRITE 1		/* argument for lis_check_umem */
+#endif
+
+
+/*  -------------------------------------------------------------------  */
+
+/*
+ * Portable construct to request that the STREAMS queues be run.
+ *
+ * port_setqsched must be coded to schedule the STREAMS queues
+ * to be run.
+ */
+#define	lis_setqsched		port_setqsched
+#define	lis_runqueues		port_setqsched
+
+extern void    port_setqsched(void) ;
+
+
+
+/*  -------------------------------------------------------------------  */
+
+/*
+ * Portable routine to wake up processes that are waiting on the
+ * stream head pending select() action.  The wakeup routine has
+ * at its disposal the sd_select structure inside the stdata structure
+ * which it can use to hold information that will allow it to wake
+ * up waiting processes.
+ */
+#define	lis_select_wakeup	port_select_wakeup
+
+extern void port_select_wakeup(struct stdata *hd) ;
+
+
+/*  -------------------------------------------------------------------  */
+#endif /*!__LIS_M_DEP_H*/
+
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/qnx-mdep.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/qnx-mdep.h
--- debug/drivers/streams/LiS/include/sys/LiS/qnx-mdep.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/qnx-mdep.h	Wed Jan  1 13:04:39 1997
@@ -0,0 +1,362 @@
+#ifndef _QNX_MDEP_H_
+#define _QNX_MDEP_H_
+/************************************************************************
+*                      QNX Machine Dependencies                         *
+*************************************************************************
+*									*
+* This file contains the missing structure definitions required		*
+* to run STREAMS as a QNX driver.					*
+*									*
+* The file then includes port-mdep.h for the portable version of the	*
+* code.									*
+*									*
+* Author:	Mikel Matthews <mikel@gcom.com>				*
+*									*
+************************************************************************/
+
+#include <sys/types.h>
+#include <errno.h>
+
+#if 0
+#include <string.h>	      /* for memcpy */
+#endif
+#include <signal.h>	      /* for signal numbers */
+
+#if 1
+#include <semaphore.h>	      /* QNX */
+#endif
+
+#include <sys/io_msg.h>
+#include <sys/sys_msg.h>
+#include <sys/dev_msg.h>
+
+typedef unsigned long	ulong;
+typedef unsigned int	uint;
+typedef unsigned short	ushort;
+
+typedef unsigned long	port_dev_t ;		/* device major/minor */
+typedef dev_t	        major_t ;		/* device major/minor */
+
+#ifndef bcopy
+extern int     bcopy(const char *s, char *d, int n);
+#endif
+#ifndef memset
+extern void *memset( void *__s, int __c, size_t __n );
+#endif
+#ifndef memcpy
+extern void *memcpy( void *__s1, const void *__s2, size_t __n );
+#endif
+
+#undef uid 
+#undef gid
+typedef int     o_uid_t;
+typedef int     o_gid_t;
+typedef unsigned   char uchar;
+
+typedef struct cred {
+	uid_t	cr_uid;			/* effective user id */
+	uid_t	cr_ruid;			/* effective user id */
+	gid_t	cr_gid;			/* effective group id */
+	gid_t	cr_rgid;			/* effective group id */
+} cred_t;
+
+#if 0
+
+struct ocb
+{
+        mode_t           mode;
+        int              count;
+	int		 strfd;
+        int              nonblock ;
+        pid_t            pid ;
+        pid_t            proxy ;
+        int              nbytes ;
+        short            ppid,
+                         pid_group,
+                         rgid,
+                         ruid,
+                         egid,
+                         euid;
+	union qnx_msg   *msg ;
+        int              bytes_alloc ;
+	int		 rec_buf_cnt;
+	int		 do_test;
+	long		 offset;
+	user_DIR	*dir_ptr;
+	char		*buf;
+};
+
+struct _io_getmsg {
+    msg_t       type;
+    short int   fd,
+                request,
+                nbytes;
+    long        zero;
+    char        data[1];
+    } ;
+
+struct _io_getmsg_reply {
+    msg_t           status;
+    short unsigned  ret_val;
+    long            zero[2];
+    char            data[1];
+    } ;
+
+struct _io_putmsg {
+    msg_t       type;
+    short int   fd,
+                request,
+                nbytes;
+    long        zero;
+    char        data[1];
+    } ;
+
+struct _io_putmsg_reply {
+    msg_t           status;
+    short unsigned  ret_val;
+    long            zero[2];
+    } ;
+
+struct _io_pollmsg {
+    msg_t       type;
+    short int   fd,
+                request,
+                nbytes;
+    long        zero;
+    char        data[1];
+    } ;
+
+struct _io_pollmsg_reply {
+    msg_t           status;
+    short unsigned  ret_val;
+    long            zero[2];
+    char            data[1];
+    } ;
+
+typedef struct strbuf_proxy {
+    int bfrlen;
+    int maxlen;
+    int len;
+    int prior;
+    int flags;
+    char data[1];
+} strbuf_proxy_t;
+
+typedef
+struct strioctl_proxy {
+    int     pic_cmd;                 /* command */
+    int     pic_timout;              /* timeout value */
+    int     pic_len;                 /* length of data */
+    char    pic_dp[1];                 /* pointer to data */
+} strioctl_proxy_t;
+
+
+typedef
+struct poll_proxy {
+    ulong     pnfds;                 /* command */
+    int       ptimeout;              /* timeout value */
+    int       plen;                 /* length of data */
+    char      pdata[1];                 /* pointer to data */
+} poll_proxy_t;
+
+typedef
+struct _io_rsys_init {
+    msg_t       type;
+} rsys_init_t;
+
+typedef
+struct _io_rsys_init_reply {
+    msg_t       status;
+    pid_t       pid;
+} rsys_init_reply_t;
+
+
+/* union for receiving messages */
+union qnx_msg
+{
+        msg_t                           type ;
+        msg_t                           status ;
+        struct _sysmsg_hdr              sysmsg ;
+        struct _sysmsg_hdr_reply        version_reply ;
+        struct _io_open                 open ;
+        struct _io_open_reply           open_reply ;
+        struct _io_dup                  dup ;
+        struct _io_dup_reply            dup_reply ;
+        struct _io_flags                flags ;
+        struct _io_flags_reply          flags_reply ;
+        struct _io_close                close ;
+        struct _io_close_reply          close_reply ;
+        struct _io_read                 read ;
+        struct _io_read_reply           read_reply ;
+        struct _io_write                write ;
+        struct _io_write_reply          write_reply ;
+        struct _io_qioctl               qioctl ;
+        struct _io_qioctl_reply         qioctl_reply ;
+	struct _io_getmsg 		getmsg ;
+	struct _io_getmsg_reply 	getmsg_reply ;
+	struct _io_putmsg 		putmsg ;
+	struct _io_putmsg_reply 	putmsg_reply ;
+	struct _io_pollmsg 		pollmsg ;
+	struct _io_pollmsg_reply 	pollmsg_reply ;
+	struct _io_rsys_init		rsys_init;
+	struct _io_rsys_init_reply	rsys_init_reply;
+	struct _io_lseek		seek;
+	struct _io_lseek_reply		seek_reply;
+	struct _io_readdir		readdir;
+	struct _io_readdir_reply	readdir_reply;
+	struct _io_rewinddir		rewinddir;
+	struct _io_rewinddir_reply	rewinddir_reply;
+} ;
+
+#define _IO_GETMSG    0xff20
+#define _IO_PUTMSG    0xff21
+#define _IO_PEEKMSG   0xff22
+#define _IO_POLLMSG   0xff23
+#define _IO_RSYS_INIT 0xff24
+
+#define GCOM_NAME "GCOM_FSYS"
+#define MSG_CTL  1
+#define MSG_DATA 2
+
+#endif
+
+/*
+ * name changes for these structures.
+ */
+#define	file		u_file
+#define	file_t		u_file_t
+#define	file_operations	u_file_operations
+
+#define MAJOR	major
+#define MINOR	minor
+#define makedevice(maj,min) makedev(1,(maj), (min))
+
+#if 0
+struct new_proc
+{
+	struct new_proc *next;
+	struct new_proc *prev;
+	pid_t		 pid;
+	pid_t		 clpid;
+	char		*stack;
+	int		 ref;
+} ;
+
+typedef struct new_proc  new_proc_t;
+typedef struct new_proc * new_proc_p;
+#endif
+
+#if 0
+#define	semaphore	u_semaphore
+#define	semaphore_t	u_semaphore_t
+
+typedef struct u_semaphore
+{
+    int			sem_count ;		/* semaphore counter */
+    long		sem_xxx[8] ;		/* just a placeholder */
+
+} u_semaphore_t ;
+
+#else
+
+#define	semaphore	u_semaphore
+#define	semaphore_t	sem_t			/* QNX semaphore */
+
+typedef struct u_semaphore
+{
+    sem_t	sem ;				/* QNX semaphore */
+
+} u_semaphore_t ;
+
+#endif
+
+#define EBADMSG		1200
+#define ENODATA		1201
+#define ENOPKG		1202
+#define ENOSR		1203
+#define ETIME		1204
+#define EPROTO		1205
+
+/*
+ * TBD: Turn a virtual memory address into a physical memory address
+ */
+#define	kvtophys(addr)		(addr)		/* user level fakery */
+
+/*
+ * bzero and bcopy
+ */
+#define	bzero(addr,nbytes)	memset(addr, 0, nbytes)
+#define	bcopy(src,dst,n)	memcpy(dst,src,n)
+
+
+/*
+ * This define is used to determine the max amount of data that the copyout
+ * routines will send back to the client
+ */
+
+#define MAXRECBUFSIZE	17*1024
+
+#ifndef PORTABLE
+#define	PORTABLE	1
+#endif
+/*
+ * Defines for i_mode, compliments of include/linux/stat.h
+ */
+#undef S_IFMT
+#undef S_IFSOCK
+#undef S_IFLNK
+#undef S_IFREG
+#undef S_IFBLK
+#undef S_IFDIR
+#undef S_IFCHR
+#undef S_IFIFO
+#undef S_ISUID
+#undef S_ISGID
+#undef S_ISVTX
+
+#undef S_ISLNK
+#undef S_ISREG
+#undef S_ISDIR
+#undef S_ISCHR
+#undef S_ISBLK
+#undef S_ISFIFO
+#undef S_ISSOCK
+
+#undef S_IRWXU
+#undef S_IRUSR
+#undef S_IWUSR
+#undef S_IXUSR
+
+#undef S_IRWXG
+#undef S_IRGRP
+#undef S_IWGRP
+#undef S_IXGRP
+
+#undef S_IRWXO
+#undef S_IROTH
+#undef S_IWOTH
+#undef S_IXOTH
+
+#undef S_IRWXUGO
+#undef S_IALLUGO
+#undef S_IRUGO
+#undef S_IWUGO
+#undef S_IXUGO
+
+/*
+ * A dummy to support the select structure in stdata_t.
+ */
+typedef struct lis_select_struct
+{
+    int		dummy ;
+
+} lis_select_t ;
+
+
+/*
+ * Now include the portable stuff
+ */
+#include <sys/LiS/user-cmn.h>
+#include <sys/LiS/port-mdep.h>
+
+#endif
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/queue.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/queue.h
--- debug/drivers/streams/LiS/include/sys/LiS/queue.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/queue.h	Wed Jan  1 13:04:39 1997
@@ -0,0 +1,467 @@
+/*                               -*- Mode: C -*- 
+ * queue.h --- streams queue handling
+ * Author          : Graham Wheeler
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: queue.h,v 1.9 1996/01/27 00:40:28 dave Exp $
+ * Purpose         : here you have utilites to handle str queues.
+ * ----------------______________________________________________
+ *
+ *   Copyright (C) 1995  Graham Wheeler, Francisco J. Ballesteros
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    gram@aztec.co.za, nemo@ordago.uc3m.es
+ */
+
+
+#ifndef _QUEUE_H
+#define _QUEUE_H 1
+
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#ifndef _LIS_CONFIG_H
+#include <sys/strconfig.h>	/* config definitions */
+#endif
+#ifndef _MSG_H
+#include <sys/LiS/msg.h>	/* streams messages*/
+#endif
+#ifndef _STRPORT_H
+#include <sys/strport.h>	/* machine-dependent porting constructs */
+#endif
+
+/*  -------------------------------------------------------------------  */
+/*				   Symbols                               */
+
+/* Max # of bands -- hard limit since we use char to store band ids
+ */
+#define LIS_MAX_BAND	255
+
+/* STREAMS queue flags (q_flag) mask values
+ */
+#define QENAB           0x000001 /* queue enabled */
+#define QWANTR          0x000002 /* usr wants to read */
+#define QWANTW          0x000004 /* usr wants to write */
+#define QFULL           0x000008 /* queue is full */
+#define QREADR          0x000010 /* it's the reader */
+#define QUSE            0x000020 /* not a free queue */
+#define QNOENB          0x000040 /* don't enable with putq() */
+#define QBACK           0x000080 /* a back-enabled queue */
+#define QRETRY		0x000100 /* retry timer's set */
+#define QSCAN		0x000200 /* queue in the scan list */
+#define	QCLOSING	0x000400 /* strm hd wants to close this queue */
+/*  -------------------------------------------------------------------  */
+/* STREAMS queue's qband flags
+ */
+#define QB_FULL         0x000001 /* band is full */
+#define QB_WANTW        0x000002 
+#define QB_BACK         0x000004 
+
+/* flushq() flags
+ */
+#define FLUSHDATA 0		/* do not flush cntl msgs */
+#define FLUSHALL  1		/* flush every msg */
+
+
+/* what to qtrqget/set
+ */
+#define QHIWAT		0
+#define QLOWAT		1
+#define QMAXPSZ		2
+#define QMINPSZ		3
+#define QCOUNT		4
+#define QFIRST		5
+#define QLAST		6
+#define QFLAG		7
+
+/*  -------------------------------------------------------------------  */
+/*				    Types                                */
+
+typedef int qfields_t;
+
+/*
+ *  The STREAMS queue structure. Each module has a queue upstream and
+ * another one downstream.
+ */
+
+typedef
+struct queue {
+  SHARE
+        long            q_minpsz;       /* min packet size accepted [I]*/
+        long            q_maxpsz;       /* max packet size accepted [I]*/
+        ulong           q_hiwat;        /* queue high water mark [I]*/
+        ulong           q_lowat;        /* queue low water mark [I]*/
+        void            *q_ptr;         /* module private data for free */
+  EXPORT
+        struct  qinit   *q_qinfo;       /* procs and limits for queue [I]*/
+        struct  msgb    *q_first;       /* first data block [Z]*/
+        struct  msgb    *q_last;        /* last data block [Z]*/
+        struct  queue   *q_next;        /* next Q of stream [Z]*/
+        struct  queue   *q_link;        /* to next Q for the scan list [Z]*/
+        ulong           q_count;        /* number of bytes on Q [Z]*/
+        ulong           q_flag;         /* queue state [Z]*/
+  PRIVATE
+        struct qband    *q_bandp;       /* separate flow information */
+        struct  queue   *q_scnxt;       /* next q in the scan list */
+} queue_t;
+
+
+/*
+ *  The qinit structure. It's used to hold the queue routines and info.
+ *
+ *  The SVR4 DKI contains contradictory information about the types
+ *  of the put and srv procedures.  In the D2DK section, it says that
+ *  that they are void type.  In the D4DK section on qinit, it says
+ *  that they are int type.  I have made these 'void'.  This may cause
+ *  some compatibility problems.  If this proves to be the case, change
+ *  them back to 'int'.  -- DMG
+ */
+
+typedef
+struct  qinit {
+  SHARE
+        void    (*qi_putp)(queue_t*, mblk_t*);  /* put procedure */
+        void    (*qi_srvp)(queue_t*);           /* service procedure */
+        int     (*qi_qopen)(queue_t *, dev_t *, int, int, cred_t *);   /* open procedure */
+        int     (*qi_qclose)(queue_t *, int,cred_t *);   /* close procedure */
+        int     (*qi_qadmin)(void);         /* debugging */
+        struct module_info *qi_minfo;   /* module information structure */
+        struct module_stat *qi_mstat;   /* module statistics structure */
+} qinit_t;
+
+
+/*
+ * This structure hold a queue's priority band information.
+ */
+
+typedef
+struct qband {
+  SHARE
+        struct qband    *qb_next;       /* next band's info */
+        ulong           qb_count;       /* number of bytes in band */
+        struct msgb     *qb_first;      /* beginning of band's data */
+        struct msgb     *qb_last;       /* end of band's data */
+        ulong           qb_hiwat;       /* high water mark for band */
+        ulong           qb_lowat;       /* low water mark for band */
+        ulong           qb_flag;        /* see above */
+} qband_t;
+
+/*  -------------------------------------------------------------------  */
+/*				 Glob. Vars.                             */
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+/* Queues are allocated always in queue pairs, the pointer to the queue pair
+ * may be a pointer to any of the two queues (usually the pointer to
+ * RD(q). Flags are initialized by allocq in such a way RD(q) and WR(q) will
+ * always work regardless the given queue.
+ * The pointer given by allocq is actually a pointer to RD(q).
+ */
+
+#ifdef __KERNEL__
+/* Allocate a new queue pair
+ * return NULL on failure 
+ *
+ */
+extern queue_t * lis_allocq( const char *name );
+
+/* Deallocate a new queue pair
+ * return NULL on failure
+ *
+ */
+extern void lis_freeq( queue_t *q );
+
+#endif /* __KERNEL__ */
+
+/* backq - Return the queue which feeds this one.
+ * get ptr to the queue behind q. That queue with q_next == q.
+ * returns NULL if no such queue
+ *
+ */
+#ifdef __KERNEL__
+extern queue_t * lis_backq(queue_t *q);
+#endif				/* __KERNEL__ */
+
+/* lis_getq - get message from head of queue
+ *
+ */
+#ifdef __KERNEL__
+extern mblk_t * lis_getq(queue_t *q);
+#endif				/* __KERNEL__ */
+
+/* putq- put a message into a queue
+ *
+ */
+#ifdef __KERNEL__
+extern int lis_putq(queue_t *q, mblk_t *mp);
+#endif				/* __KERNEL__ */
+
+/* putbq - return a message to a queue
+ *
+ */
+#ifdef __KERNEL__
+extern int lis_putbq(queue_t *q, mblk_t *mp);
+#endif				/* __KERNEL__ */
+
+/*insq - insert nmp before emp. If emp is NULL, insert at end
+ *	of queue. If the insertion is out-of-order, the insert fails.
+ *	Returns 1 on success; 0 otherwise.
+ *
+ */
+#ifdef __KERNEL__
+extern int lis_insq(queue_t *q, mblk_t *emp, mblk_t *mp);
+#endif				/* __KERNEL__ */
+
+/* rmvq - remove a message from a queue. If the message
+ *		does not exist, panic.
+ *
+ */
+#ifdef __KERNEL__
+extern void lis_rmvq(queue_t *q, mblk_t *mp);
+#endif				/* __KERNEL__ */
+
+/* lis_qenable - schedule a queue for service
+ *
+ */
+#ifdef __KERNEL__
+extern void lis_qenable(queue_t *q);
+#endif				/* __KERNEL__ */
+
+/* backenable - enable back queue if QWANTW is set, i.e.
+ *	if a back queue is full.
+ *
+ */
+#ifdef __KERNEL__
+extern void lis_backenable(queue_t *q);
+#endif				/* __KERNEL__ */
+
+/* lis_setq - Set queue variables
+ *
+ */
+#ifdef __KERNEL__
+extern void lis_setq(queue_t * q, struct qinit *rinit, struct qinit *winit);
+#endif				/* __KERNEL__ */
+
+/* lis_flushband - flush messages in a specified priority band.
+ *	flag can be FLUSHDATA (flush only M_DATA, M_DELAY,
+ *	M_PROTO, M_PCPROTO) or FLUSHALL.
+ *
+ */
+#ifdef __KERNEL__
+extern void lis_flushband(queue_t *q, unsigned char band, int flag);
+#endif				/* __KERNEL__ */
+
+/* lis_flushq - free messages from a queue, enabling upstream/downstream
+ *	service routines if applicable. The flag is the same as for
+ *	lis_flushband.
+ *
+ */
+#ifdef __KERNEL__
+extern void lis_flushq(queue_t *q, int flag);
+#endif				/* __KERNEL__ */
+
+/* putctl - allocate a message block, set the type,
+ *	and put it on a queue. Returns 1 on success;
+ *	0 if the allocation failed or type is one of
+ *	M_DATA, M_PROTO or M_PCPROTO
+ *
+ */
+#ifdef __KERNEL__
+extern int lis_putctl(queue_t *q, int type);
+#endif				/* __KERNEL__ */
+
+/* lis_putctl1 - as for lis_putctl, but with a one byte parameter
+ *
+ */
+#ifdef __KERNEL__
+extern int lis_putctl1(queue_t *q, int type, int param);
+#endif				/* __KERNEL__ */
+
+
+/* lis_qsize - returns the number of messages on a queue
+ *
+ */
+#ifdef __KERNEL__
+extern int lis_qsize(queue_t *q);
+
+#define	qsize		lis_qsize
+#endif				/* __KERNEL__ */
+
+
+/* lis_strqget - get information about a (band of a) queue.
+ *	Valid values for what are QHIWAT, QLOWAT, QMAXPSZ,
+ *	QMINPSZ, QCOUNT, QFIRST, QLAST, QFLAG.
+ *	Returns 0 on success.
+ *
+ */
+#ifdef __KERNEL__
+extern int 
+lis_strqget(queue_t *q, qfields_t what, unsigned char band, long *val);
+#endif				/* __KERNEL__ */
+
+/* lis_strqset - change information about a (band of a) queue.
+ *	Valid values for what are QHIWAT, QLOWAT, QMAXPSZ,
+ *	QMINPSZ.
+ *	Returns 0 on success.
+ *
+ */
+#ifdef __KERNEL__
+extern int
+lis_strqset(queue_t *q, qfields_t what, unsigned char band, long val);
+#endif				/* __KERNEL__ */
+
+#ifdef __KERNEL__
+#ifdef SAFE
+extern void safe_noenable(queue_t *q, char *f, int l);
+extern void safe_enableok(queue_t *q, char *f, int l);
+extern int safe_canenable(queue_t *q, char *f, int l);
+#define lis_noenable(q)	 safe_noenable(q, __FILE__, __LINE__)
+#define lis_enableok(q)	 safe_enableok(q, __FILE__, __LINE__)
+#define lis_canenable(q) safe_canenable(q, __FILE__, __LINE__)
+
+extern queue_t *safe_OTHERQ(queue_t *q, char *f, int l);
+extern queue_t *safe_RD(queue_t *q, char *f, int l);
+extern queue_t *safe_WR(queue_t *q, char *f, int l);
+extern int safe_SAMESTR(queue_t *q, char *f, int l);
+#define LIS_OTHERQ(q)	safe_OTHERQ(q, __FILE__, __LINE__)
+#define LIS_RD(q)	safe_RD(q, __FILE__, __LINE__)
+#define LIS_WR(q)	safe_WR(q, __FILE__, __LINE__)
+#define LIS_SAMESTR(q)	safe_SAMESTR(q, __FILE__, __LINE__)
+
+extern void safe_putnext(queue_t *q, mblk_t *mp, char *f, int l);
+extern void safe_qreply(queue_t *q, mblk_t *mp, char *f, int l);
+#define lis_putnext(q,mp) 	safe_putnext(q, mp, __FILE__, __LINE__)
+#define lis_qreply(q,mp) 	safe_qreply(q, mp, __FILE__, __LINE__)
+#else  /* SAFE */
+
+#define lis_noenable(q)	(q)->q_flag |= QNOENB
+#define lis_enableok(q)	(q)->q_flag &= ~QNOENB
+#define lis_canenable(q) !((q)->q_flag & QNOENB)
+
+#define	LIS_OTHERQ(q)   (((q)->q_flag&QREADR) ? (q)+1: (q)-1)
+#define	LIS_RD(q)	(((q)->q_flag&QREADR) ? (q): (q)-1)
+#define	LIS_WR(q)	(((q)->q_flag&QREADR) ? (q)+1: (q))
+#define LIS_SAMESTR(q)	((q)->q_next!=NULL && \
+			(((q)->q_flag&QREADR) == ((q)->q_next->q_flag&QREADR)))
+
+#define lis_putnext(q, mp)  (*((q)->q_next->q_qinfo->qi_putp))((q)->q_next, mp)
+#define lis_qreply(q, mp)   putnext(OTHERQ(q), mp)
+
+#endif /* !SAFE */
+#endif				/* __KERNEL__ */
+
+/* Count messages on a queue 
+ */
+#ifdef __KERNEL__
+extern int lis_qsize(queue_t *);			
+#endif				/* __KERNEL__ */
+
+/* Insert message(3) after message(2) or at start 
+ */
+#ifdef __KERNEL__
+extern void lis_appq(queue_t *, mblk_t *, mblk_t *);
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+#ifdef __KERNEL__
+
+/* The functions below are to achieve mutual exclusion on the queue
+ * They use the q_wait  wait queue to sleep and the q_lock char to
+ * flag the lock.
+ * you should use only lis_{lock,unlock}_queue().
+ * the others are for internal use.
+ */
+#if 0				/* DMG save these until MP version */
+extern  void
+lis_sleep_on_queue(queue_t * q);
+
+#define lis_wait_on_queue(q)						\
+				{					\
+				    if (q->q_lock)			\
+					lis_sleep_on_queue(q);		\
+				}
+
+#define lis_lock_queue(q)						\
+				{					\
+				    lis_wait_on_queue(q);		\
+				    q->q_lock=1;			\
+				}
+
+#define lis_unlock_queue(q)						\
+				{					\
+				    q->q_lock=0;			\
+				    wake_up(&q->q_wait);		\
+				}
+#endif
+
+/*  -------------------------------------------------------------------  */
+/* lis_bcanput - search the stream starting from q until a service
+ *	routine is found, if any, and test the found queue for
+ *	flow control at a specified band. Schedule backenabling
+ *	if flow controlled.
+ *	For band==0 this is equivalent to canput. Returns 0 if
+ *	flow controlled; 1 otherwise.
+ *
+ * test for flow cntl in band
+ * returns STR_OK if msg can be put(), STR_ERR (0) if not.
+ *
+ */
+extern int lis_bcanput(queue_t *q, unsigned char band);
+
+/*  -------------------------------------------------------------------  */
+/* lis_bcanputnext - search the stream starting from the queue after q
+ *	until a service routine is found.
+ *
+ *	This is equivalent to lis_bcanput(q->q_next, band).  It is
+ *	a routine in AT&T's MP DKI.
+ *
+ * returns STR_OK if msg can be put(), STR_ERR (0) if not.
+ *
+ */
+extern int lis_bcanputnext(queue_t *q, unsigned char band);
+
+/*  -------------------------------------------------------------------  */
+/* lis_bcanputnext_anyband - search the stream starting from the queue after q
+ *	until a service routine is found.  Return true if there is some
+ *	non-zero qband in that queue that can be written into.
+ *
+ * returns STR_OK if msg can be put(), STR_ERR (0) if not.
+ *
+ */
+extern int lis_bcanputnext_anyband(queue_t *q);
+
+/*  -------------------------------------------------------------------  */
+/* lis_qcountstrm - return the accumulated q_count fields of all the
+ *                  queues hooked together in this stream.
+ *		    This routine also sets the QCLOSING flag for each
+ *		    queue that it encounters.  It is used only by the
+ *		    close logic to drain queues.
+ */
+extern int lis_qcountstrm(queue_t *q) ;
+
+
+#endif /* __KERNEL__ */
+/*  -------------------------------------------------------------------  */
+#endif /*!_QUEUE_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/sco-mdep.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/sco-mdep.h
--- debug/drivers/streams/LiS/include/sys/LiS/sco-mdep.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/sco-mdep.h	Fri Dec 27 12:31:37 1996
@@ -0,0 +1,125 @@
+/************************************************************************
+*                   SCO User Level Machine Dependencies                 *
+*************************************************************************
+*									*
+* This file contains the missing structure definitions required		*
+* to run STREAMS at user level in a a testing environment on SCO UNIX.	*
+*									*
+* The file then includes port-mdep.h for the portable version of the	*
+* code.									*
+*									*
+* Author:	David Grothe						*
+*									*
+************************************************************************/
+
+
+#ifndef	_SCO_MDEP_H
+#define	_SCO_MDEP_H			1
+
+#include <sys/types.h>
+#include <sys/errno.h>	      /* for errno */
+#include <memory.h>	      /* for memcpy */
+#include <sys/signal.h>	      /* for signal numbers */
+
+/*
+ * name changes for these structures.
+ */
+#define	semaphore	u_semaphore
+#define	semaphore_t	u_semaphore_t
+
+/************************************************************************
+*                            major/minor                                *
+*************************************************************************
+*									*
+* Macros to extract the major and minor device numbers from a dev_t	*
+* variable.								*
+*									*
+************************************************************************/
+
+#if 0
+
+#define	major(dev_t_var)	STR_MAJOR(dev_t_var)
+#define	minor(dev_t_var)	STR_MINOR(dev_t_var)
+
+#define makedevice(majornum,minornum) \
+		((((dev_t) (majornum)) << 16) | ((minornum) & 0xFFFF))
+#else
+
+#define	_INKERNEL		1
+
+#include <sys/sysmacros.h>		/* SCO include file */
+
+#define	MAJOR		_major
+#define	MINOR		_minor
+#define	makedevice	_makedev
+#undef	major
+#undef	minor
+#define	major		_major
+#define	minor		_minor
+
+#endif
+
+typedef unsigned long	port_dev_t ;		/* device major/minor */
+
+#undef uid 
+#undef gid
+typedef int     o_uid_t;
+typedef int     o_gid_t;
+typedef unsigned   char uchar;
+typedef struct cred {
+	uid_t	cr_uid;			/* effective user id */
+	uid_t	cr_ruid;			/* effective user id */
+	gid_t	cr_gid;			/* effective group id */
+	gid_t	cr_rgid;			/* effective group id */
+} cred_t;
+
+typedef struct u_semaphore
+{
+    int			sem_count ;		/* semaphore counter */
+    long		sem_xxx[8] ;		/* just a placeholder */
+
+} u_semaphore_t ;
+
+
+#define	kvtophys(addr)		(addr)		/* user level fakery */
+
+/*
+ * bzero and bcopy
+ */
+#define	bzero(addr,nbytes)	memset(addr, 0, nbytes)
+#define	bcopy(src,dst,n)	memcpy(dst,src,n)
+
+
+
+#ifndef PORTABLE
+#define	PORTABLE	1
+#endif
+
+/*
+ * Signal that STREAMS uses but SCO does not support.
+ */
+#define	SIGURG		31
+
+
+/*
+ * A dummy to support the select structure in stdata_t.
+ */
+typedef struct lis_select_struct
+{
+    int		dummy ;
+
+} lis_select_t ;
+
+
+/*
+ * Now include the portable stuff
+ */
+#ifndef _USER_CMN_H
+#include <sys/LiS/user-cmn.h>
+#endif
+#ifndef _PORT_MDEP_H
+#include <sys/LiS/port-mdep.h>
+#endif
+
+
+#endif
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/share.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/share.h
--- debug/drivers/streams/LiS/include/sys/LiS/share.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/share.h	Mon Dec 16 16:36:40 1996
@@ -0,0 +1,93 @@
+/*                               -*- Mode: C -*- 
+ * share.h --- streams entry points from the file ops
+ * Author          : Francisco J. Ballesteros
+ * Created On      : Tue May 31 21:40:37 1994
+ * Last Modified By: Francisco J. Ballesteros
+ * Last Modified On: Fri Sep 29 17:33:41 1995
+ * Update Count    : 6
+ * RCS Id          : $Id: share.h,v 1.6 1996/01/27 00:40:29 dave Exp $
+ * Usage           : see below :)
+ * Required        : see below :)
+ * Status          : ($State: Exp $) Unknown, Use with caution!
+ * Prefix(es)      : lis
+ * Requeriments    : 
+ * Purpose         : provide glue for lis vs os
+ *                 : 
+ * ----------------______________________________________________
+ *
+ *   Copyright (C) 1995  Francisco J. Ballesteros
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach me by email to
+ *    nemo@ordago.uc3m.es
+ */
+
+#ifndef _SHARE_H
+#define _SHARE_H 1
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+/* We put here every linux kernel specific include to 
+ * help developing internal code
+ */
+
+
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+/*  -------------------------------------------------------------------  */
+/* This defines values returned by some utility functions
+ */
+enum { STR_ERR = 0, STR_OK = 1 };
+
+#ifndef min
+#define min(a,b)	(((a)<(b))?(a):(b))
+#define max(a,b)	(((a)>(b))?(a):(b))
+#endif
+/*  -------------------------------------------------------------------  */
+
+/* Bit flags
+ */
+#define F_ISSET(f,v)	((f) & (v))
+#define F_SET(f,v)	((f) |= (v))
+#define F_CLR(f,v)	((f) &= ~(v))
+
+#ifndef NULL
+#define NULL ((void*)0)
+#endif
+
+#ifndef VOID
+#define VOID void
+#endif
+
+#ifdef __KERNEL__
+/* extract values from a char pointer and advance the pointer */
+int lis_getint(unsigned char **p) ;				/* msg.c */
+
+void lis_putbyte(unsigned char **p, unsigned char byte) ;	/* msg.c */
+
+void	lis_bzero(void *ptr, int cnt) ;				/* head.c */
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+#endif /*!_SHARE_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/stats.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/stats.h
--- debug/drivers/streams/LiS/include/sys/LiS/stats.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/stats.h	Wed Jan  1 13:04:39 1997
@@ -0,0 +1,146 @@
+/*                               -*- Mode: C -*- 
+ * stats.h --- streams statistics
+ * Author          : Francisco J. Ballesteros, Graham Wheeler
+ * Created On      : Tue May 31 21:40:37 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: stats.h,v 1.3 1996/01/27 00:40:29 dave Exp $
+ * Purpose         : provide statistics for LiS
+ * ----------------______________________________________________
+ *
+ *   Copyright (C) 1995  Francisco J. Ballesteros, Graham Wheeler
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    nemo@ordago.uc3m.es, gram@aztec.co.za
+ */
+
+
+#ifndef _STATS_H
+#define _STATS_H 1
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+
+/*  -------------------------------------------------------------------  */
+/*				   Symbols                               */
+
+/* accounted items for stats and their names
+ */
+#define HEADERS		0
+#define FREEHDRS	1
+#define DATABS		2
+#define	MEMALLOCS	3			/* # times allocator called */
+#define	MEMFREES	4			/* # times free called */
+#define	MEMALLOCD	5			/* amount of memory */
+#define	DBLKMEM		6			/* amt of mem allocated dblks */
+#define	MSGSQD		7			/* # messages queued */
+#define	MSGQDSTRHD	8			/* # msgs qd at strm hd */
+#define	QUEUES		9			/* # queues allocated */
+#define	CANPUTS		10			/* # canput calls */
+#define	QSCHEDS		11			/* # queues scheduled to run */
+#define	BUFCALLS	12			/* # bufcalls */
+#define	MEMLIM		13			/* lis_max_mem */
+#define	MSGMEMLIM	14			/* lis_max_msg_mem */
+#define	STRMAXSTAT	15			/* largest slot */
+#define HEADERSSTR      "In-Use Message Blocks"
+#define FREEHDRSSTR     "Free Message Blocks"
+#define DATABSSTR       "Data Blocks"
+#define	MEMALLOCSSTR	"Memory Allocator Calls"
+#define	MEMFREESSSTR	"Memory Free Calls"
+#define	MEMALLOCDSTR	"Bytes Allocated"
+#define	DBLKMEMSTR	"Bytes Allocated to D-Blks"
+#define	MSGSQDSTR	"Messages Queued"
+#define	MSGQDSTRHDSTR	"Messages Queued at Strm Hd"
+#define	QUEUESSTR	"Queues Allocated"
+#define	CANPUTSSTR	"Canput Calls"
+#define	QSCHEDSSTR	"Scheduled Queues"
+#define	BUFCALLSSTR	"Bufcalls"
+#define	MEMLIMSTR	"Memory Limit"
+#define	MSGMEMLIMSTR	"D-Blk Memory Limit"
+
+/* per item statistics & their names
+ */
+#define CURRENT		0
+#define TOTAL		1
+#define MAXIMUM		2
+#define FAILURES	3
+#define CURRENTSTR	"Current"
+#define TOTALSTR	"Total"
+#define MAXIMUMSTR	"Maximum" 
+#define FAILURESSTR	"Failures"
+
+
+/*  -------------------------------------------------------------------  */
+/*				    Types                                */
+
+
+/*  -------------------------------------------------------------------  */
+/*				 Glob. Vars.                             */
+
+extern unsigned long lis_strstats[STRMAXSTAT][4]; /* the stats */
+
+/* If in user mode, include a stats dump routine 
+ */
+#ifdef MEMPRINT
+
+typedef struct
+{
+    int         stats_inx ;             /* index into lis_strstats */
+    char        *name ;                 /* ASCII name */
+} itemname_t ;
+
+
+extern itemname_t  lis_itemnames[];
+extern char       *lis_countnames[];
+#endif
+
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+#ifdef __KERNEL__
+/* increment count for one item
+ */
+extern void LisUpCounter(int item, int n);
+
+#define	LisUpCount(item)	LisUpCounter(item,1)
+
+/* increment fail count for item
+ */
+#define LisUpFailCount(item)	lis_strstats[item][FAILURES]++
+
+/* decrement count for item
+ */
+#define LisDownCount(item)	lis_strstats[item][CURRENT]--
+#define LisDownCounter(item,n)	lis_strstats[item][CURRENT] -= (n)
+
+#endif /* __KERNEL__ */
+
+/* If in user mode, include a stats dump routine 
+ */
+#ifdef MEMPRINT
+extern void
+LisShowStrStats(unsigned long (*strstats)[STRMAXSTAT][4]);
+#endif
+
+/*  -------------------------------------------------------------------  */
+#endif /*!_STATS_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/streamsdrv.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/streamsdrv.h
--- debug/drivers/streams/LiS/include/sys/LiS/streamsdrv.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/streamsdrv.h	Mon Dec 16 16:36:40 1996
@@ -0,0 +1,161 @@
+/*                               -*- Mode: C -*- 
+ * init.c --- 
+ * Author          : David Howells
+ * Created On      : 
+ * Last Modified By: 
+ * Last Modified On: 
+ * Update Count    : 0
+ * RCS Id          : : init.c$
+ * Usage           : see below :)
+ * Required        : see below :)
+ * Status          : 
+ * Prefix(es)      : 
+ * Requeriments    : 
+ * Purpose         : 
+ *                 : 
+ * ----------------______________________________________________
+ *   Copyright (C) 1995  Denis Froschauer
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Library General Public
+ *    License as published by the Free Software Foundation; either
+ *    version 2 of the License, or (at your option) any later version.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Library General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Library General Public
+ *    License along with this library; if not, write to the Free
+ *    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach me by email to
+ *    100741.1151@compuserve.com
+ */
+
+#ifndef _LIS_STREAMSDRV_H_
+#define _LIS_STREAMSDRV_H_
+
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+
+#include <sys/strport.h>
+#include <sys/LiS/mod.h>
+#include <sys/LiS/queue.h>
+
+/*
+ * STREAMS system:
+ *
+ *       *****PROGRAMS*****
+ *          |           |
+ *          |           | (struct file_operations) CHRDEV I/F
+ *          |           |
+ *        +-|-----------|-+
+ *        : |           | :
+ *        : |  STREAMS  | :         MODULE LAYER I/F
+ *        : |   HEAD    | :
+ *        +-|-----------|-+
+ *          |           |
+ *   +------|-----------|------+
+ *   :      |           |      :
+ *   : +----*---+  +----*----+ :
+ *   : : module :  : module  : :    REGISTERED STREAMS MODULES
+ *   : +------*-+  +-*-------+ :
+ *   :        |      |         :
+ *   :       +*------*+        :
+ *   :       : module :        :
+ *   :       +---*----+        :
+ *   :           |             :
+ *   +-----------|-------------+
+ *               |
+ *               | (struct lis_physical_driver) STREAMS PHYSICAL LAYER I/F
+ *               |
+ *        +------*--------+
+ *        : Physical      :
+ *        : Layer         :    REGISTERED STREAMS PHYSICAL DRIVER
+ *        : Driver        :
+ *        +------*--------+
+ *               |
+ *            HARDWARE
+ */
+
+/*****************************************************************************/
+
+#ifdef __KERNEL__
+
+/* physical layer driver linkage - to replace fmodsw */
+typedef
+struct LiS_driver {
+    int		ld_magic;
+
+    /* registration data */
+    ushort	ld_major;	/* major device number for CHRDEV registry */
+    const char	*ld_name;	/* module ID and /proc-fs filename */
+
+    /* /proc data */
+    const char	*ld_desc;	/* longer description for /proc -
+				   newline separated strings */
+
+    /* module access */
+    module_info_t *ld_minfo;	/* module info */
+    streamtab_t *ld_access;	/* I/O entry points */
+
+    /* kernel/streams filled-in data */
+    ushort	ld_usage;	/* usage count */
+    lis_apush_t	ld_automods;	/* autopushed modules */
+} LiS_driver_t;
+
+/* provisional magic number */
+#define LIS_DRIVER_MAGIC 0x53545264 /* 'STRd' */
+
+/* physical driver registry */
+int lis_register_driver(LiS_driver_t *);
+int lis_unregister_driver(LiS_driver_t *);
+
+/* access a driver linkage block */
+LiS_driver_t *lis_get_driver(int majnum);
+LiS_driver_t *lis_find_driver(const char *name);
+
+#endif				/* __KERNEL__ */
+
+/*****************************************************************************/
+
+#ifdef __KERNEL__
+
+/* module linkage */
+typedef
+struct LiS_module {
+    int		lm_magic;
+
+    /* registration data */
+    const char	*lm_name;	/* module ID and /proc-fs filename */
+
+    /* /proc data */
+    const char	*lm_desc;	/* longer description for /proc -
+				   newline separated strings */
+
+    /* module access */
+    module_info_t *lm_minfo;	/* module info */
+    streamtab_t *lm_access;	/* I/O entry points */
+
+    /* kernel/streams filled-in data */
+    ushort	lm_usage;	/* usage count */
+    modID_t	lm_idnum;	/* ID number */
+} LiS_module_t;
+
+/* provisional magic number */
+#define LIS_MODULE_MAGIC 0x5354526D /* 'STRm' */
+
+/* streams module registry */
+int lis_register_module(LiS_module_t *);
+int lis_unregister_module(LiS_module_t *);
+
+/* access a module linkage block */
+LiS_module_t *lis_findmod(const char *name);
+LiS_module_t *lis_apushm(int ix, dev_t dev);
+
+#endif				/* __KERNEL__ */
+
+#endif _LIS_STREAMSDRV_H_
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/strlog.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/strlog.h
--- debug/drivers/streams/LiS/include/sys/LiS/strlog.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/strlog.h	Mon Dec 16 16:36:40 1996
@@ -0,0 +1,59 @@
+/*                               -*- Mode: C -*- 
+ * strlog.h --- streams strlog cntl handling
+ * Author          : Graham Wheeler
+ * Created On      : Tue May 31 22:25:19 1994
+ * Last Modified By: 
+ * Last Modified On: 
+ * Update Count    : 0
+ * RCS Id          : $Id: strlog.h,v 1.2 1996/01/27 00:40:30 dave Exp $
+ * Usage           : see below :)
+ * Required        : see below :)
+ * Status          : ($State: Exp $) Unknown, Use with caution!
+ * Prefix(es)      : lis
+ * Requeriments    : 
+ * Purpose         : here you have utilites to handle str strlogs.
+ *                 : 
+ * ----------------______________________________________________
+ */
+
+#ifndef _STRLOG_H
+#define _STRLOG_H 1
+
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+
+/*  -------------------------------------------------------------------  */
+/*				   Symbols                               */
+
+/*  -------------------------------------------------------------------  */
+/*				    Types                                */
+
+/*  -------------------------------------------------------------------  */
+/*				 Glob. Vars.                             */
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+/*  -------------------------------------------------------------------  */
+/* strlog - send a message to STREAMS log driver
+ *
+ * STATUS: incomplete, untested
+ */
+#ifdef __KERNEL__
+extern int
+lis_strlog(short mid, short sid, char level, unsigned short flags,
+	   char *fmt, ... );
+#endif				/* __KERNEL__ */
+
+
+
+/*  -------------------------------------------------------------------  */
+#endif /*!_STRLOG_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/strmdbg.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/strmdbg.h
--- debug/drivers/streams/LiS/include/sys/LiS/strmdbg.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/strmdbg.h	Mon Dec 16 16:36:40 1996
@@ -0,0 +1,159 @@
+/************************************************************************
+*                      STREAMS Debugging Aids                           *
+*************************************************************************
+*									*
+* These are routines that print things and bits of a debug mask.	*
+*									*
+* The debug mask can be turned on by the user via an ioctl.  Bits	*
+* of this mask control the printing of various messages.		*
+*									*
+* Some of the streams primitives have been aliased such that they	*
+* pass in the caller's file name and line number to the routine that	*
+* really does the work.  This allows us to keep pretty good track of	*
+* memory usage.  Stray memory is always a nasty problem in debugging	*
+* streams drivers.							*
+*									*
+* Author:	David Grothe <dave@gcom.com>				*
+*									*
+************************************************************************/
+
+#ifndef	_STRMDBG_H
+#define	_STRMDBG_H		1
+
+
+#ifndef _HEAD_H
+#include <sys/LiS/head.h>
+#endif
+
+
+/*
+ * These bits can be set to cause the streams module to print
+ * interesting stuff while it is executing.
+ */
+extern unsigned long	lis_debug_mask ;
+
+
+#define LIS_DEBUG_OPEN_BIT		0x00000001L
+#define LIS_DEBUG_CLOSE_BIT		0x00000002L
+#define LIS_DEBUG_READ_BIT		0x00000004L
+#define LIS_DEBUG_WRITE_BIT		0x00000008L
+
+#define LIS_DEBUG_IOCTL_BIT		0x00000010L
+#define LIS_DEBUG_PUTNEXT_BIT		0x00000020L
+#define LIS_DEBUG_STRRPUT_BIT		0x00000040L
+#define LIS_DEBUG_SIG_BIT		0x00000080L
+
+#define LIS_DEBUG_PUTMSG_BIT		0x00000100L
+#define LIS_DEBUG_GETMSG_BIT		0x00000200L
+#define LIS_DEBUG_POLL_BIT		0x00000400L
+#define LIS_DEBUG_LINK_BIT		0x00000800L
+
+#define LIS_DEBUG_SAFE_BIT		0x00010000L
+#define LIS_DEBUG_TRCE_MSG_BIT		0x00020000L
+#define LIS_DEBUG_CLEAN_MSG_BIT		0x00040000L
+
+#define LIS_DEBUG_MP_ALLOC		0x00100000L	/* allocb debug */ 
+#define LIS_DEBUG_MP_FREEMSG		0x00200000L	/* freemsg debug */ 
+#define	LIS_DEBUG_MALLOC_BIT		0x00400000L	/* lis_malloc/free */
+#define LIS_DEBUG_MONITOR_MEM_BIT	0x00800000L	/* monitor memory */
+
+#define LIS_DEBUG_DMP_QUEUE_BIT		0x01000000L
+#define LIS_DEBUG_DMP_MBLK_BIT		0x02000000L
+#define LIS_DEBUG_DMP_DBLK_BIT		0x04000000L
+#define LIS_DEBUG_DMP_STRHD_BIT		0x08000000L
+
+#define LIS_DEBUG_ADDRS_BIT		0x80000000L	/* print addrs */
+
+
+#define LIS_DEBUG_OPEN		(lis_debug_mask & LIS_DEBUG_OPEN_BIT)
+#define LIS_DEBUG_CLOSE		(lis_debug_mask & LIS_DEBUG_CLOSE_BIT)
+#define LIS_DEBUG_READ		(lis_debug_mask & LIS_DEBUG_READ_BIT)
+#define LIS_DEBUG_WRITE		(lis_debug_mask & LIS_DEBUG_WRITE_BIT)
+
+#define LIS_DEBUG_IOCTL		(lis_debug_mask & LIS_DEBUG_IOCTL_BIT)
+#define LIS_DEBUG_PUTNEXT	(lis_debug_mask & LIS_DEBUG_PUTNEXT_BIT)
+#define LIS_DEBUG_STRRPUT	(lis_debug_mask & LIS_DEBUG_STRRPUT_BIT)
+#define LIS_DEBUG_SIG		(lis_debug_mask & LIS_DEBUG_SIG_BIT)
+
+#define LIS_DEBUG_PUTMSG	(lis_debug_mask & LIS_DEBUG_PUTMSG_BIT)
+#define LIS_DEBUG_GETMSG	(lis_debug_mask & LIS_DEBUG_GETMSG_BIT)
+#define LIS_DEBUG_POLL		(lis_debug_mask & LIS_DEBUG_POLL_BIT)
+#define LIS_DEBUG_LINK		(lis_debug_mask & LIS_DEBUG_LINK_BIT)
+
+#define LIS_DEBUG_SAFE		(lis_debug_mask & LIS_DEBUG_SAFE_BIT)
+#define LIS_DEBUG_TRCE_MSG	(lis_debug_mask & LIS_DEBUG_TRCE_MSG_BIT)
+#define LIS_DEBUG_CLEAN_MSG	(lis_debug_mask & LIS_DEBUG_CLEAN_MSG_BIT)
+
+#define LIS_DEBUG_ALLOC 	(lis_debug_mask & LIS_DEBUG_MP_ALLOC)
+#define LIS_DEBUG_FREEMSG 	(lis_debug_mask & LIS_DEBUG_MP_FREEMSG)
+#define LIS_DEBUG_MALLOC	(lis_debug_mask & LIS_DEBUG_MALLOC_BIT)
+#define LIS_DEBUG_MONITOR_MEM	(lis_debug_mask & LIS_DEBUG_MONITOR_MEM_BIT)
+
+#define LIS_DEBUG_DMP_QUEUE	(lis_debug_mask & LIS_DEBUG_DMP_QUEUE_BIT)
+#define LIS_DEBUG_DMP_MBLK	(lis_debug_mask & LIS_DEBUG_DMP_MBLK_BIT)
+#define LIS_DEBUG_DMP_DBLK	(lis_debug_mask & LIS_DEBUG_DMP_DBLK_BIT)
+#define LIS_DEBUG_DMP_STRHD	(lis_debug_mask & LIS_DEBUG_DMP_STRHD_BIT)
+
+#define LIS_DEBUG_ADDRS		(lis_debug_mask & LIS_DEBUG_ADDRS_BIT)
+
+
+
+/*
+ * Some routines to assist in debug printing
+ */
+#ifdef __KERNEL__
+void		 lis_print_block(void *ptr) ;
+void		 lis_print_mem(void) ;
+void		 lis_print_queue(queue_t * q) ;
+void		 lis_print_stream(stdata_t *head) ;
+const char	*lis_strm_name(stdata_t *head) ;
+const char	*lis_queue_name(queue_t *q) ;
+const char	*lis_maj_min_name(stdata_t *head) ;
+const char	*lis_msg_type_name(mblk_t *mp) ;
+void		 lis_print_data(mblk_t *mp, int opt, int cont) ;
+void		 lis_print_msg(mblk_t *mp, const char *prefix, int opt) ;
+char		*lis_poll_events(short events) ;
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+/*                             print_msg options			 */
+
+#define	PRINT_DATA_SHORT	0		/* short form		 */
+#define	PRINT_DATA_ENTIRE	1		/* print entire dblk	 */
+#define	PRINT_DATA_RDWR		2		/* print just rptr->wptr */
+
+/*  -------------------------------------------------------------------  */
+/*                             Memory Allocation			 */
+/*
+ * Note that the lis memory allocator is located in strmdbg.c so that
+ * it can maintain the secret memory links for all streams-allocated
+ * memory.
+ */
+#ifdef __KERNEL__
+void	*lis_malloc(int nbytes, int class, char *file_name, int line_nr) ;
+void	 lis_free(void *ptr, char *file_name, int line_nr) ;
+void	 lis_mark_mem(void *ptr, const char *file_name, int line_nr) ;
+int      lis_check_guard(void *ptr, char *msg) ;
+int      lis_check_mem(void) ;
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+/*				Memory Codes				 */
+
+#define	MEM_QUEUE	-1		/* it's a queue */
+#define	MEM_MSG		-2		/* it's a message (mblk) */
+#define	MEM_STRMHD	-3		/* it's a stream head (stdata) */
+#define	MEM_TIMER	-4		/* it's a timer structure */
+
+
+/*
+ * Guard word value
+ */
+#define	MEM_GUARD	0x1234abcd	/* unique pattern at end of mem area */
+
+
+/*  -------------------------------------------------------------------  */
+/*				Streams Statistics			 */
+
+
+#endif
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/sys54-mdep.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/sys54-mdep.h
--- debug/drivers/streams/LiS/include/sys/LiS/sys54-mdep.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/sys54-mdep.h	Mon Dec 16 16:36:40 1996
@@ -0,0 +1,117 @@
+/************************************************************************
+*                   SVR 4 User Level Machine Dependencies               *
+*************************************************************************
+*									*
+* This file contains the missing structure definitions required		*
+* to run STREAMS at user level in a a testing environment on SVR4 UNIX.	*
+*									*
+* The file then includes port-mdep.h for the portable version of the	*
+* code.									*
+*									*
+* Author:	David Grothe						*
+*									*
+************************************************************************/
+
+#ifndef	_SYS54_MDEP_H
+#define	_SYS54_MDEP_H			1
+
+
+
+#include <sys/types.h>
+#include <sys/errno.h>	      /* for errno */
+#include <memory.h>	      /* for memcpy */
+#include <sys/signal.h>	      /* for signal numbers */
+
+/*
+ * name changes for these structures.
+ */
+#define	semaphore	u_semaphore
+#define	semaphore_t	u_semaphore_t
+
+/************************************************************************
+*                            major/minor                                *
+*************************************************************************
+*									*
+* Macros to extract the major and minor device numbers from a dev_t	*
+* variable.								*
+*									*
+************************************************************************/
+
+#ifndef _INKERNEL		
+#define	_INKERNEL		1
+#endif
+
+#undef _KERNEL			/* undefine for this include file */
+#include <sys/mkdev.h>		/* SVR4 include file */
+#define	_KERNEL			1
+
+#define	MAJOR		major
+#define	MINOR		minor
+#define	makedevice	makedev
+
+#if defined(__USLC__)
+
+    /* compiling with USL C compiler, i.e., compiling on SVR4 */
+
+#else
+
+    /* not compiling ON SVR4, but compiling FOR SVR4 */
+    typedef unsigned long	major_t ;
+    typedef unsigned long	minor_t ;
+
+#endif
+
+typedef unsigned long	port_dev_t ;		/* device major/minor */
+
+#undef uid 
+#undef gid
+/* typedef int     o_uid_t; */
+/* typedef int     o_gid_t; */
+typedef unsigned   char uchar;
+typedef struct cred {
+	uid_t	cr_uid;			/* effective user id */
+	gid_t	cr_gid;			/* effective group id */
+} cred_t;
+
+typedef struct u_semaphore
+{
+    int			sem_count ;		/* semaphore counter */
+    long		sem_xxx[8] ;		/* just a placeholder */
+
+} u_semaphore_t ;
+
+
+
+#define	kvtophys(addr)		(addr)		/* user level fakery */
+
+/*
+ * bzero and bcopy
+ */
+#define	bzero(addr,nbytes)	memset(addr, 0, nbytes)
+#define	bcopy(src,dst,n)	memcpy(dst,src,n)
+
+
+#ifndef PORTABLE
+#define	PORTABLE	1
+#endif
+
+/*
+ * Signal that STREAMS uses but SVR4 does not support.
+ */
+/* #define	SIGURG		31 */
+
+
+
+
+/*
+ * Now include the portable stuff
+ */
+#ifndef _USER_CMN_H
+#include <sys/LiS/user-cmn.h>
+#endif
+#ifndef _PORT_MDEP_H
+#include <sys/LiS/port-mdep.h>
+#endif
+
+
+#endif
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/user-cmn.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/user-cmn.h
--- debug/drivers/streams/LiS/include/sys/LiS/user-cmn.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/user-cmn.h	Wed Jan  1 13:04:39 1997
@@ -0,0 +1,153 @@
+/************************************************************************
+*                      User-level Common Structures                     *
+*************************************************************************
+*									*
+* The defines and data structures in this file are common to all uses	*
+* of the user-level file system.  Thus, user-mdep.h, qnx-mdep.h,	*
+* sco-mdep.h and sys54-mdep.h all include this file.			*
+*									*
+************************************************************************/
+
+#ifndef _USER_CMN_H
+#define	_USER_CMN_H		1
+
+
+#define	inode		u_inode
+#define	inode_t		u_inode_t
+#define	file		u_file
+#define	file_t		u_file_t
+#define	file_operations	u_file_operations
+
+#define REFERENCE_INODE	1	/* inode that will not be removed */
+
+typedef struct u_inode
+{
+    struct u_inode	*i_link ;		/* in case of linked list */
+    long		 i_mode ;		/* file mode */
+    port_dev_t		 i_dev ;		/* major/minor */
+    struct stdata	*i_str ;		/* ptr to stream struct */
+    struct semaphore	 i_sem ;		/* inode semaphore */
+    int			 i_use ;		/* use count */
+    int			 i_inum ;		/* inode number (phoney) */
+    long		 i_ctime ;		/* status change time */
+    long		 i_mtime ;		/* modified time */
+    long		 i_atime ;		/* accessed time */
+    long		 i_ftime ;		/* creation time */
+    int			 i_flags ;		/* flags field */
+} u_inode_t ;
+
+#define i_rdev		i_dev			/* head.c uses i_rdev */
+
+typedef struct u_file
+{
+    struct u_file	*f_link ;		/* in case of linked list */
+    char		*f_name ;		/* file name */
+    int			 f_flags ;		/* file open flags */
+    int			 f_count ;		/* reference count */
+    int			 f_fdnr ;		/* file number */
+    struct inode	*f_inode ;		/* inode of file */
+    struct file_operations * f_op;		/* handler routines */
+    void		*f_usr_ptr ;		/* user's pointer */
+    struct semaphore	 f_sem ;		/* to lock file struct */
+    void		*f_ptr ;		/* ptr for user's use */
+
+} u_file_t ;
+
+#define LOCK_FILE(f)	port_sem_P(&f->f_sem)
+#define ULOCK_FILE(f)	port_sem_V(&f->f_sem)
+
+
+struct u_file_operations			/* from linux/fs.h */
+{
+	int (*lseek) (void);
+	int (*read) (struct inode *, struct file *, char *, int);
+	int (*write) (struct inode *, struct file *, char *, int);
+	int (*readdir) (void);
+	int (*select) (void);
+	int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);
+
+	int (*mmap) (void);
+
+	int (*open) (struct inode *, struct file *);
+	void (*release) (struct inode *, struct file *);
+
+	int (*fsync) (void);
+	int (*fasync) (void);
+	int (*check_media_change) (void);
+	int (*revalidate) (void);
+	int (*putpmsg)(struct inode *, struct file *, void *, void *, int, int);
+	int (*getpmsg)(struct inode *, struct file *, void *, void *, int *, int *, int);
+	int (*pollfd)(struct inode *, struct file *, void *);
+};
+
+/*
+ * Defines for i_mode, compliments of include/linux/stat.h
+ */
+#ifndef S_IFMT
+
+#define S_IFMT  00170000
+#define S_IFSOCK 0140000
+#define S_IFLNK	 0120000
+#define S_IFREG  0100000
+#define S_IFBLK  0060000
+#define S_IFDIR  0040000
+#define S_IFCHR  0020000
+#define S_IFIFO  0010000
+#define S_ISUID  0004000
+#define S_ISGID  0002000
+#define S_ISVTX  0001000
+
+#endif
+
+#ifndef S_ISLNK
+
+#define S_ISLNK(m)	(((m) & S_IFMT) == S_IFLNK)
+#define S_ISREG(m)	(((m) & S_IFMT) == S_IFREG)
+#define S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)
+#define S_ISCHR(m)	(((m) & S_IFMT) == S_IFCHR)
+#define S_ISBLK(m)	(((m) & S_IFMT) == S_IFBLK)
+#define S_ISFIFO(m)	(((m) & S_IFMT) == S_IFIFO)
+#define S_ISSOCK(m)	(((m) & S_IFMT) == S_IFSOCK)
+
+#endif
+
+#ifndef S_IRWXU
+
+#define S_IRWXU 00700
+#define S_IRUSR 00400
+#define S_IWUSR 00200
+#define S_IXUSR 00100
+
+#endif
+
+#ifndef S_IRWXG
+
+#define S_IRWXG 00070
+#define S_IRGRP 00040
+#define S_IWGRP 00020
+#define S_IXGRP 00010
+
+#endif
+
+#ifndef S_IRWXO
+
+#define S_IRWXO 00007
+#define S_IROTH 00004
+#define S_IWOTH 00002
+#define S_IXOTH 00001
+
+#endif
+
+#ifndef S_IRWXUGO
+
+#define S_IRWXUGO	(S_IRWXU|S_IRWXG|S_IRWXO)
+#define S_IALLUGO	(S_ISUID|S_ISGID|S_ISVTX|S_IRWXUGO)
+#define S_IRUGO		(S_IRUSR|S_IRGRP|S_IROTH)
+#define S_IWUGO		(S_IWUSR|S_IWGRP|S_IWOTH)
+#define S_IXUGO		(S_IXUSR|S_IXGRP|S_IXOTH)
+
+#endif
+
+
+
+#endif
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/user-mdep.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/user-mdep.h
--- debug/drivers/streams/LiS/include/sys/LiS/user-mdep.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/user-mdep.h	Sat Dec 28 12:06:17 1996
@@ -0,0 +1,105 @@
+/************************************************************************
+*                   User Level Machine Dependencies                     *
+*************************************************************************
+*									*
+* This file contains the missing structure definitions required		*
+* to run STREAMS at user level in a a testing environment.		*
+*									*
+* The file then includes port-mdep.h for the portable version of the	*
+* code.									*
+*									*
+* Author:	David Grothe						*
+*									*
+************************************************************************/
+
+#ifndef _USER_MDEP_H
+#define _USER_MDEP_H
+
+
+#include <sys/errno.h>	      /* for errno */
+#ifndef _MEMORY_H
+#include <memory.h>	      /* for memcpy */
+#endif
+#ifndef _SIGNAL_H
+#include <sys/signal.h>	      /* for signal numbers */
+#endif
+
+
+/*
+ * Major/minor representation is unique for each version
+ */
+#define	major(dev_t_var)	STR_MAJOR(dev_t_var)
+#define	minor(dev_t_var)	STR_MINOR(dev_t_var)
+#define	MAJOR(dev)		( ((dev) >> 16) )
+#define	MINOR(dev)		( ((dev) & 0xFFFF) )
+
+#define makedevice(majornum,minornum) \
+		((((dev_t) (majornum)) << 16) | ((minornum) & 0xFFFF))
+
+typedef unsigned long	port_dev_t ;		/* device major/minor */
+
+/*
+ * User ids and group ids are unique for each version
+ */
+#undef uid 
+#undef gid
+typedef int     o_uid_t;
+typedef int     o_gid_t;
+typedef unsigned   char uchar;
+typedef struct cred {
+	uid_t	cr_uid;			/* effective user id */
+	gid_t	cr_gid;			/* effective group id */
+	uid_t	cr_ruid;		/* real user id */
+	gid_t	cr_rgid;		/* real group id */
+} cred_t;
+
+/*
+ * Semaphores are unique for each version
+ */
+
+#define	semaphore	u_semaphore
+#define	semaphore_t	u_semaphore_t
+
+typedef struct u_semaphore
+{
+    int			sem_count ;		/* semaphore counter */
+    long		sem_xxx[8] ;		/* just a placeholder */
+
+} u_semaphore_t ;
+
+
+#define	kvtophys(addr)		(addr)		/* user level fakery */
+
+/*
+ * bzero and bcopy
+ */
+#define	bzero(addr,nbytes)	memset(addr, 0, nbytes)
+#define	bcopy(src,dst,n)	memcpy(dst,src,n)
+
+/*
+ * A dummy to support the select structure in stdata_t.
+ */
+typedef struct lis_select_struct
+{
+    int		dummy ;
+
+} lis_select_t ;
+
+
+
+#ifndef PORTABLE
+#define	PORTABLE	1
+#endif
+
+/*
+ * Now include the portable stuff
+ */
+#ifndef _USER_CMN_H
+#include <sys/LiS/user-cmn.h>	/* common elements for all user-file systs */
+#endif
+#ifndef _PORT_MDEP_H
+#include <sys/LiS/port-mdep.h>
+#endif
+
+
+#endif
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/LiS/wait.h /usr/src/linux/drivers/streams/LiS/include/sys/LiS/wait.h
--- debug/drivers/streams/LiS/include/sys/LiS/wait.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/LiS/wait.h	Wed Jan  1 13:04:39 1997
@@ -0,0 +1,135 @@
+/*                               -*- Mode: C -*- 
+ * wait.h --- waiting for events...
+ * Author          : Francisco J. Ballesteros
+ * Created On      : Tue May 31 21:40:37 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: wait.h,v 1.5 1996/01/27 00:40:32 dave Exp $
+ * Purpose         : provide user waitentials
+ * ----------------______________________________________________
+ *
+ *   Copyright (C) 1995  Francisco J. Ballesteros
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach me by email to
+ *    nemo@ordago.uc3m.es
+ */
+
+
+#ifndef _WAIT_H
+#define _WAIT_H 1
+
+#ifdef __KERNEL__
+/*  -------------------------------------------------------------------  */
+/*                               Dependencies                            */
+
+#ifndef _HEAD_H
+#include <sys/LiS/head.h>	/* stream head */
+#endif
+
+
+/*  -------------------------------------------------------------------  */
+/*                         Shared global variables                       */
+
+#define ONESEC (1000000/HZ)	/* ? */
+
+/*  -------------------------------------------------------------------  */
+/*			Exported functions & macros                      */
+
+
+/* The functions below are to achieve mutual exclusion on the stream
+ * head. They use the sd_wopen wait queue to sleep and the sd_lock char to
+ * flag the lock.
+ * The lock/unlock are the complete ones.
+ * if you just want to wait you may use wait_on/wake_up.
+ *
+ * You can lock(L)/wait(W)/sleep(S) on the following events:
+ * L/S wopen:  the 1st opener completes its job
+ * W/S wwrite: there's room in the write queue to issue a downstream msg.
+ * W/S wread: msg arrives at the stream head.
+ * L/S wioc:  process completes it's ioctl()
+ *   S wiocing: answer to ioc arrived
+ * STATUS: complete(?), untested
+ */
+extern int lis_sleep_on_wopen(struct stdata * sd) ;
+extern int lis_sleep_on_wioc(struct stdata * sd) ;
+extern int lis_sleep_on_wwrite(struct stdata * sd);
+extern int lis_sleep_on_wread(struct stdata * sd);
+extern int lis_sleep_on_wiocing(struct stdata * sd);
+
+/*  -------------------------------------------------------------------  */
+
+#define lis_wait_on_wwrite(sd)	lis_sleep_on_wwrite(sd)
+
+#define lis_wait_on_wread(sd)	lis_sleep_on_wread(sd)
+
+#define lis_lock_wopen(sd)	lis_sleep_on_wopen(sd)
+
+#define lis_lock_wioc(sd)	lis_sleep_on_wioc(sd)
+
+/*  -------------------------------------------------------------------  */
+
+#define lis_wake_up_wwrite(sd)						\
+				{					\
+				    lis_up(&sd->sd_wwrite);		\
+				}
+
+#define lis_wake_up_wread(sd)						\
+				{					\
+				    lis_up(&sd->sd_wread);		\
+				}
+
+#define lis_wake_up_wiocing(sd)						\
+				{					\
+				    lis_up(&sd->sd_wiocing);		\
+				}
+
+/*  -------------------------------------------------------------------  */
+#define lis_unlock_wopen(sd)						\
+				{					\
+				    F_CLR(sd->sd_flag,STWOPEN);		\
+				    lis_up(&sd->sd_wopen);		\
+				}
+
+
+/*  -------------------------------------------------------------------  */
+#define lis_unlock_wioc(sd)						\
+				{					\
+				    F_CLR(sd->sd_flag,IOCWAIT);		\
+				    lis_up(&sd->sd_wioc);		\
+				}
+
+
+/*  -------------------------------------------------------------------  */
+
+/* Sched & cancel timeouts
+ */
+typedef	void	tmout_fcn_t(ulong) ;
+
+extern void
+lis_tmout(struct timer_list *tl, tmout_fcn_t *fn, long arg, long ticks) ;
+
+extern void
+lis_untmout( struct timer_list *tl) ;
+
+#endif /* __KERNEL__ */
+
+#endif /*!_WAIT_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/cdi.h /usr/src/linux/drivers/streams/LiS/include/sys/cdi.h
--- debug/drivers/streams/LiS/include/sys/cdi.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/cdi.h	Mon Dec 16 16:36:40 1996
@@ -0,0 +1,470 @@
+#ifndef _SYS_CDI_H
+#define _SYS_CDI_H
+
+/*
+ * cdi.h header for Communications Device Interface
+ *
+ * Copyright (c) 1989 NCR Comten
+ */
+
+/*
+ * Primitives for Local Management Services
+ */
+#define CD_INFO_REQ     	0x00    /* Information request */
+#define CD_INFO_ACK     	0x01    /* Information acknowledgement */
+#define CD_ATTACH_REQ   	0x02    /* Attach a PPA */
+#define CD_DETACH_REQ   	0x03    /* Detach a PPA */
+#define CD_ENABLE_REQ   	0x04    /* Prepare a device */
+#define CD_DISABLE_REQ  	0x05    /* Disable a device */
+#define CD_OK_ACK       	0x06    /* Success acknowledgement */
+#define CD_ERROR_ACK    	0x07    /* Error acknowledgement */
+#define CD_ENABLE_CON   	0x08    /* Enable confirmation */
+#define CD_DISABLE_CON  	0x09    /* Disable confirmation */
+#define CD_ERROR_IND    	0x0a    /* Error indication */
+
+/*
+ * Primitives used for Data Transfer
+ */
+#define CD_ALLOW_INPUT_REQ      0x0b    /* Allow input */
+#define CD_READ_REQ     	0x0c    /* Wait-for-input request */
+#define CD_UNITDATA_REQ 	0x0d    /* Data send request */
+#define CD_WRITE_READ_REQ       0x0e    /* Write/read request */
+#define CD_UNITDATA_ACK 	0x0f    /* Data send acknowledgement */
+#define CD_UNITDATA_IND 	0x10    /* Data receive indication */
+#define CD_HALT_INPUT_REQ       0x11    /* Halt input */
+#define CD_ABORT_OUTPUT_REQ     0x12    /* Abort output */
+#define CD_MUX_NAME_REQ		0x13	/* get mux name (Gcom) */
+#define	CD_BAD_FRAME_IND	0x14	/* frame w/error (Gcom extension) */
+#define	CD_MODEM_SIG_REQ	0x15	/* Assert modem signals (Gcom) */
+#define	CD_MODEM_SIG_IND	0x16	/* Report modem signal state (Gcom) */
+
+
+/*
+ * CDI device states
+ */
+#define CD_UNATTACHED   	0x00    /* No PPA attached */
+#define CD_UNUSABLE     	0x01    /* PPA cannot be used */
+#define CD_DISABLED     	0x02    /* PPA attached */
+#define CD_ENABLE_PENDING       0x03    /* Waiting ack of enable req */
+#define CD_ENABLED      	0x04    /* Awaiting use */
+#define CD_READ_ACTIVE  	0x05    /* Input section enabled; */
+					/* disabled after data arrives */
+#define CD_INPUT_ALLOWED        0x06    /* Input section permanently enabled */
+#define CD_DISABLE_PENDING      0x07    /* Waiting ack of disable req */
+#define CD_OUTPUT_ACTIVE        0x08    /* Output section active only */
+
+/*
+ * CD_ERROR_ACK and CD_ERROR_IND error return values
+ */
+#define CD_BADADDRESS   0x01    /* Address was invalid */
+#define CD_BADADDRTYPE  0x02    /* Invalid address type */
+#define CD_BADDIAL      0x03    /* Dial information was invalid */
+#define CD_BADDIALTYPE  0x04    /* Invalid dial information type */
+#define CD_BADDISPOSAL  0x05    /* Invalid disposal parameter */
+#define CD_BADFRAME     0x06    /* Defective SDU received */
+#define CD_BADPPA       0x07    /* Invalid PPA identifier */
+#define CD_BADPRIM      0x08    /* Unrecognized primitive */
+#define CD_DISC 	0x09    /* Disconnected */
+#define CD_EVENT        0x0a    /* Protocol-specific event occurred */
+#define CD_FATALERR     0x0b    /* Device has become unusable */
+#define CD_INITFAILED   0x0c    /* Line initialization failed */
+#define CD_NOTSUPP      0x0d    /* Primitive not supported by this device */
+#define CD_OUTSTATE     0x0e    /* Primitive was issued from an invalid state */
+#define CD_PROTOSHORT   0x0f    /* M_PROTO block too short */
+#define CD_READTIMEOUT  0x10    /* Read request timed out before data arrived */
+#define CD_SYSERR       0x11    /* UNIX system error */
+#define CD_WRITEFAIL    0x12    /* Unitdata request failed */
+
+/*
+ * Error explanations
+ */
+#define CD_CRCERR       	0x01    /* CRC or FCS error */
+#define CD_DLE_EOT      	0x02    /* DLE EOT detected */
+#define CD_FORMAT       	0x03    /* Format error detected */
+#define CD_HDLC_ABORT   	0x04    /* Aborted frame detected */
+#define CD_OVERRUN      	0x05    /* Input overrun */
+#define CD_TOOSHORT     	0x06    /* Frame too short */
+#define CD_INCOMPLETE   	0x07    /* Partial frame received */
+#define CD_BUSY 		0x08    /* Telephone was busy */
+#define CD_NOANSWER     	0x09    /* Connection went unanswered */
+#define CD_CALLREJECT   	0x0a    /* Connection rejected */
+#define CD_HDLC_IDLE    	0x0b    /* HDLC line went idle */
+#define CD_HDLC_NOTIDLE 	0x0c    /* HDLC line no longer idle */
+#define CD_QUIESCENT    	0x0d    /* Line being reassigned */
+#define CD_RESUMED      	0x0e    /* Line has been reassigned */
+#define CD_DSRTIMEOUT   	0x0f    /* Did not see DSR in time */
+#define CD_LAN_COLLISIONS       0x10    /* LAN excessive collisions */
+#define CD_LAN_REFUSED  	0x11    /* LAN message refused */
+#define CD_LAN_NOSTATION        0x12    /* LAN no such station */
+#define CD_LOSTCTS      	0x13    /* Lost Clear to Send signal */
+#define CD_DEVERR       	0x100   /* Start of device-specific codes */
+
+/*
+ * CDI device classes
+ */
+#define CD_HDLC 	0x00    /* Bit-synchronous */
+#define CD_BISYNC       0x01    /* Character-synchronous */
+#define CD_LAN          0x02    /* ISO 8802-3,4,5 local-area network MAC layer 
+*/
+
+/*
+ * CDI duplex types
+ */
+#define CD_FULLDUPLEX   0x00    /* Full duplex; allow input supported */
+#define CD_HALFDUPLEX   0x01    /* Half duplex; read and write/read supported 
+*/
+
+/*
+ * CDI output styles
+ */
+#define CD_UNACKEDOUTPUT 0x00    /* No unitdata acknowledgements */
+#define CD_ACKEDOUTPUT   0x01    /* Unitdata acknowledgements */
+#define CD_PACEDOUTPUT   0x02    /* Unitdata acks as output timing hints */
+
+/*
+ * CDI optional features
+ */
+#define CD_CANREAD      0x01    /* Read request supported on full duplex */
+#define CD_CANDIAL      0x02    /* Dial information supported */
+#define CD_AUTOALLOW    0x04    /* CD_INPUT_ALLOWED as soon as enabled */
+#define CD_KEEPALIVE	0x08	/* Gcom: Don't send off at CD_DISABLE_REQ */
+
+/*
+ * CDI provider style.
+ * The CDI provider style which determines whether a provider
+ * requires a CD_ATTACH_REQ to inform the provider which PPA
+ * user messages should be sent/received on.
+ */
+#define CD_STYLE1       0x00    /* PPA is implicitly bound by open(2) */
+#define CD_STYLE2       0x01    /* PPA must be explicitly bound via 
+CD_ATTACH_REQ */
+#define	CD_STYLE_1	CD_STYLE1	/* Gcom -- to match document */
+#define	CD_STYLE_2	CD_STYLE2	/* Gcom -- to match document */
+
+/*
+ * Symbolic value for "no dialing information"
+ */
+#define CD_NODIAL       0x00
+
+/*
+ * Actions to take with undelivered data in a CD_DISABLE_REQ or
+CD_HALT_INPUT_REQ
+ */
+#define CD_FLUSH        0x00    /* Discard undelivered data */
+#define CD_WAIT 	0x01    /* Attempt to deliver unsent data */
+#define CD_DELIVER      0x02
+
+/*
+ * Address types
+ */
+#define CD_SPECIFIC     0x00    /* Specific address follows */
+#define CD_BROADCAST    0x01    /* Broadcast; no address follows */
+#define CD_IMPLICIT     0x02    /* No address or embedded address */
+
+/*
+ * Error types for CD_BAD_FRAME_IND
+ */
+
+#define	CD_FRMTOOLONG	0xFFFF		/* frame overflowed rcv bfr */
+#define	CD_FRMNONOCTET	0xFFFE		/* frame not octet-aligned */
+#define	CD_EMPTY_BFR	0xFFFD		/* empty rcv buffer (not used) */
+#define	CD_BAD_CRC	0xFFFC		/* CRC error */
+#define	CD_FRM_ABORTED	0xFFFB		/* frame aborted */
+#define	CD_RCV_OVERRUN	0xFFFA		/* receive overrun */
+
+
+/*
+ * Modem signal bits for modem signal related requests and indications
+ */
+#define CD_DTR		0x01
+#define CD_RTS		0x02
+#define CD_DSR		0x04
+#define CD_DCD		0x08
+#define CD_CTS		0x10
+#define CD_RI		0x20
+
+
+/*
+ * CDI interface primitive definitions.
+ *
+ * Each primitive is sent as a Stream message.  It is possible that
+ * the messages may be viewed as a sequence of bytes that have the
+ * following form without any padding. The structure definition
+ * of the following messages may have to change depending on the
+ * underlying hardware architecture and crossing of a hardware
+ * boundary with a different hardware architecture.
+ *
+ * Each message has the name defined followed by the
+ * Stream message type (M_PROTO, M_PCPROTO, M_DATA)
+ */
+
+typedef unsigned long  cd_ulong;
+typedef unsigned short cd_ushort;
+
+/*
+ *      LOCAL MANAGEMENT PRIMITIVES
+ */
+
+/*
+ * CD_INFO_REQ, M_PROTO or M_PCPROTO type
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+} cd_info_req_t;
+
+/*
+ * CD_INFO_ACK, M_PROTO or M_PCPROTO type
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+        cd_ulong   cd_state;
+        cd_ulong   cd_max_sdu;
+        cd_ulong   cd_min_sdu;
+        cd_ulong   cd_class;
+        cd_ulong   cd_duplex;
+        cd_ulong   cd_output_style;
+        cd_ulong   cd_features;
+        cd_ulong   cd_addr_length;
+        cd_ulong   cd_ppa_style;
+} cd_info_ack_t;
+
+/*
+ * CD_ATTACH_REQ, M_PROTO or M_PCPROTO type
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+        cd_ulong   cd_ppa;
+} cd_attach_req_t;
+
+/*
+ * CD_DETACH_REQ, M_PROTO or M_PCPROTO type
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+} cd_detach_req_t;
+
+/*
+ * CD_ENABLE_REQ, M_PROTO or M_PCPROTO type
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+        cd_ulong   cd_dial_type;
+        cd_ulong   cd_dial_length;
+        cd_ulong   cd_dial_offset;
+} cd_enable_req_t;
+
+/*
+ * CD_DISABLE_REQ, M_PROTO or M_PCPROTO type
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+        cd_ulong   cd_disposal;
+} cd_disable_req_t;
+
+/*
+ * CD_OK_ACK, M_PROTO or M_PCPROTO type
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+        cd_ulong   cd_state;
+        cd_ulong   cd_correct_primitive;
+} cd_ok_ack_t;
+
+/*
+ * CD_ERROR_ACK, M_PROTO or M_PCPROTO type
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+        cd_ulong   cd_state;
+        cd_ulong   cd_error_primitive;
+        cd_ulong   cd_errno;
+        cd_ulong   cd_explanation;
+} cd_error_ack_t;
+
+/*
+ * CD_ENABLE_CON, M_PROTO or M_PCPROTO type
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+        cd_ulong   cd_state;
+} cd_enable_con_t;
+
+/*
+ * CD_DISABLE_CON, M_PROTO or M_PCPROTO type
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+        cd_ulong   cd_state;
+} cd_disable_con_t;
+
+/*
+ * CD_ERROR_IND, M_PROTO or M_PCPROTO type
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+        cd_ulong   cd_state;
+        cd_ulong   cd_errno;
+        cd_ulong   cd_explanation;
+} cd_error_ind_t;
+
+/*
+ *      DATA TRANSFER PRIMITIVES
+ */
+
+/*
+ * CD_ALLOW_INPUT_REQ, M_PROTO or M_PCPROTO type
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+} cd_allow_input_req_t;
+
+/*
+ * CD_READ_REQ, M_PROTO or M_PCPROTO type
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+        cd_ulong   cd_msec;
+} cd_read_req_t;
+
+/*
+ * CD_UNITDATA_REQ, optional M_PROTO type, with M_DATA block(s)
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+        cd_ushort  cd_addr_type;
+        cd_ushort  cd_priority;
+        cd_ulong   cd_dest_addr_length;
+        cd_ulong   cd_dest_addr_offset;
+} cd_unitdata_req_t;
+
+/*
+ * CD_WRITE_READ_REQ, M_PROTO type
+ */
+typedef struct {
+        cd_ulong           cd_primitive;
+        cd_unitdata_req_t       cd_unitdata_req;
+        cd_read_req_t           cd_read_req;
+} cd_write_read_req_t;
+
+/*
+ * CD_UNITDATA_ACK, M_PROTO type
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+        cd_ulong   cd_state;
+} cd_unitdata_ack_t;
+
+/*
+ * CD_UNITDATA_IND, optional M_PROTO type, with M_DATA block(s)
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+        cd_ulong   cd_state;
+        cd_ulong   cd_src_addr_length;
+        cd_ulong   cd_src_addr_offset;
+        cd_ushort  cd_addr_type;
+        cd_ushort  cd_priority;
+        cd_ulong   cd_dest_addr_length;
+        cd_ulong   cd_dest_addr_offset;
+} cd_unitdata_ind_t;
+
+/*
+ * CD_BAD_FRAME_IND, M_PROTO type, with M_DATA block(s)
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+        cd_ulong   cd_state;
+	cd_ulong   cd_error ;		/* what is wrong with the frame */
+
+} cd_bad_frame_ind_t;
+
+/*
+ * CD_MODEM_SIG_REQ, M_PROTO type
+ *
+ * Assert the modem signals with '1' bits in the cd_sigs mask and
+ * drop those signals with '0' bits.  Sensed modem signals such
+ * as DCD or CTS are ignored.
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+        cd_ulong   cd_sigs;
+
+} cd_modem_sig_req_t;
+
+/*
+ * CD_MODEM_SIG_IND, M_PROTO type
+ *
+ * The cd_sigs field reports the current state of the modem signals.
+ * This message is sent when modem signals change at the hardware
+ * interface.  Only changes in signals selected by the cd_modem_sig_enb_req_t
+ * cd_sigs mask will be evaluated for purposes of change detection.
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+        cd_ulong   cd_sigs;
+
+} cd_modem_sig_ind_t;
+
+
+/*
+ * CD_HALT_INPUT_REQ, M_PROTO or M_PCPROTO type
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+        cd_ulong   cd_disposal;
+} cd_halt_input_req_t;
+
+/*
+ * CD_ABORT_OUTPUT_REQ, M_PROTO or M_PCPROTO type
+ */
+typedef struct {
+        cd_ulong   cd_primitive;
+} cd_abort_output_req_t;
+
+union CD_primitives {
+        cd_ulong           cd_primitive;
+        cd_info_req_t           info_req;
+        cd_info_ack_t           info_ack;
+        cd_attach_req_t attach_req;
+        cd_detach_req_t detach_req;
+        cd_enable_req_t enable_req;
+        cd_disable_req_t        disable_req;
+        cd_ok_ack_t             ok_ack;
+        cd_error_ack_t          error_ack;
+        cd_enable_con_t enable_con;
+        cd_disable_con_t        disable_con;
+        cd_error_ind_t          error_ind;
+        cd_allow_input_req_t    allow_input_req;
+        cd_read_req_t           read_req;
+        cd_unitdata_req_t       unitdata_req;
+        cd_write_read_req_t     write_read_req;
+        cd_unitdata_ack_t       unitdata_ack;
+        cd_unitdata_ind_t       unitdata_ind;
+	cd_halt_input_req_t     halt_input_req;
+};
+
+#define CD_INFO_REQ_SIZE                sizeof(cd_info_req_t)
+#define CD_INFO_ACK_SIZE                sizeof(cd_info_ack_t)
+#define CD_ATTACH_REQ_SIZE              sizeof(cd_attach_req_t)
+#define CD_DETACH_REQ_SIZE              sizeof(cd_detach_req_t)
+#define CD_ENABLE_REQ_SIZE              sizeof(cd_enable_req_t)
+#define CD_DISABLE_REQ_SIZE             sizeof(cd_disable_req_t)
+#define CD_OK_ACK_SIZE          sizeof(cd_ok_ack_t)
+#define CD_ERROR_ACK_SIZE               sizeof(cd_error_ack_t)
+#define CD_ALLOW_INPUT_REQ_SIZE sizeof(cd_allow_input_req_t)
+#define CD_READ_REQ_SIZE                sizeof(cd_read_req_t)
+#define CD_UNITDATA_REQ_SIZE            sizeof(cd_unitdata_req_t)
+#define CD_WRITE_READ_REQ_SIZE  sizeof(cd_write_read_req_t)
+#define CD_UNITDATA_ACK_SIZE            sizeof(cd_unitdata_ack_t)
+#define CD_UNITDATA_IND_SIZE            sizeof(cd_unitdata_ind_t)
+#define CD_HALT_INPUT_REQ_SIZE          sizeof(cd_halt_input_req_t)
+#define CD_ABORT_OUTPUT_REQ_SIZE        sizeof(cd_abort_output_req_t)
+#define CD_ERROR_IND_SIZE               sizeof(cd_error_ind_t)
+#define CD_ENABLE_CON_SIZE              sizeof(cd_enable_con_t)
+#define CD_DISABLE_CON_SIZE             sizeof(cd_disable_con_t)
+#define CD_BAD_FRAME_IND_SIZE		sizeof(cd_bad_frame_ind_t)
+#define CD_MODEM_SIG_REQ_SIZE		sizeof(cd_modem_sig_req_t)
+#define CD_MODEM_SIG_IND_SIZE		sizeof(cd_modem_sig_ind_t)
+
+#endif /* _SYS_CDI_H */
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/cmn_err.h /usr/src/linux/drivers/streams/LiS/include/sys/cmn_err.h
--- debug/drivers/streams/LiS/include/sys/cmn_err.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/cmn_err.h	Wed Jan  1 13:04:40 1997
@@ -0,0 +1,32 @@
+/*                               -*- Mode: C -*- 
+ * cmd_err.h --- 
+ * Author          : Francisco J. Ballesteros, David Grothe
+ * Created On      : Tue May 31 21:40:37 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: cmn_err.h,v 1.2 1996/01/27 00:39:48 dave Exp $
+ */
+
+#ifndef _CMD_ERR_H
+#define _CMD_ERR_H 1
+
+#define	CE_CONT		0		/* continue printing */
+#define	CE_NOTE		1		/* NOTICE */
+#define	CE_WARN		2		/* WARNING */
+#define	CE_PANIC	3		/* PANIC */
+
+#ifdef __KERNEL__
+
+void	cmn_err(int err_lvl, char *fmt, ...) ;
+
+typedef      void  (*lis_print_trace_t)   (char *bfrp) ;
+extern       lis_print_trace_t      lis_print_trace;
+
+#endif				/* __KERNEL__ */
+
+#endif /*!_CMD_ERR_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/cred.h /usr/src/linux/drivers/streams/LiS/include/sys/cred.h
--- debug/drivers/streams/LiS/include/sys/cred.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/cred.h	Wed Jan  1 13:04:40 1997
@@ -0,0 +1,25 @@
+/*                               -*- Mode: C -*- 
+ * cred.h --- credentials
+ * Author          : Francisco J. Ballesteros
+ * Created On      : Tue May 31 21:40:37 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: cred.h,v 1.2 1996/01/27 00:39:49 dave Exp $
+ * Purpose         : provide user credentials
+ */
+
+#ifndef _CRED_H
+#define _CRED_H 1
+
+/* This file has to be updated with the Linux counterpart of SVR4 <sys/cred.h>
+ * header file. 
+ *
+ * This is in the xxx-mdep.h family of files -- DMG
+ */
+
+#endif /*!_CRED_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/ddi.h /usr/src/linux/drivers/streams/LiS/include/sys/ddi.h
--- debug/drivers/streams/LiS/include/sys/ddi.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/ddi.h	Mon Dec 16 16:36:40 1996
@@ -0,0 +1,35 @@
+/*                               -*- Mode: C -*- 
+ * ddi.h --- 
+ * Author          : Francisco J. Ballesteros
+ * Created On      : Tue May 31 21:40:37 1994
+ * Last Modified By: 
+ * Last Modified On: 
+ * Update Count    : 0
+ * RCS Id          : $Id: ddi.h,v 1.1 1995/12/19 15:52:08 dave Exp $
+ * Usage           : see below :)
+ * Required        : see below :)
+ * Status          : ($State: Exp $) Unknown, Use with caution!
+ * Prefix(es)      : 
+ * Requeriments    : 
+ * Purpose         : 
+ *                 : 
+ * ----------------______________________________________________
+ */
+
+#ifndef _DDI_H
+#define _DDI_H 1
+
+/* This file has to be updated with the Linux counterpart of SVR4 <sys/ddi.h>
+ * header file. 
+ */
+
+#define	getmajor		MAJOR
+#define	getminor		MINOR
+
+#endif /*!_DDI_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/debug.h /usr/src/linux/drivers/streams/LiS/include/sys/debug.h
--- debug/drivers/streams/LiS/include/sys/debug.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/debug.h	Mon Dec 16 16:36:40 1996
@@ -0,0 +1,33 @@
+/*                               -*- Mode: C -*- 
+ * debug.h --- debugging stuff
+ * Author          : Francisco J. Ballesteros
+ * Created On      : Tue May 31 21:40:37 1994
+ * Last Modified By: 
+ * Last Modified On: 
+ * Update Count    : 0
+ * RCS Id          : $Id: debug.h,v 1.1 1995/12/19 15:52:08 dave Exp $
+ * Usage           : see below :)
+ * Required        : see below :)
+ * Status          : ($State: Exp $) Unknown, Use with caution!
+ * Prefix(es)      : 
+ * Requeriments    : 
+ * Purpose         : 
+ *                 : 
+ * ----------------______________________________________________
+ */
+
+#ifndef _DEBUG_H
+#define _DEBUG_H 1
+
+/* This file has to be updated with the Linux counterpart of SVR4 <sys/debug.h>
+ * header file. 
+ */
+
+
+#endif /*!_DEBUG_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/dki.h /usr/src/linux/drivers/streams/LiS/include/sys/dki.h
--- debug/drivers/streams/LiS/include/sys/dki.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/dki.h	Mon Dec 16 16:36:40 1996
@@ -0,0 +1,61 @@
+/************************************************************************
+*                     SVR4 Driver-Kernel Interface			*
+*************************************************************************
+*									*
+* These are the external definitions for SVR4 compatible DKI functions.	*
+*									*
+* Author:	David Grothe <dave@gcom.com>				*
+*									*
+************************************************************************/
+
+#ifndef	DKI_H
+#define	DKI_H		1
+
+
+#ifndef _SYS_TYPES_H
+#include <sys/types.h>
+#endif
+
+
+#ifndef NULL
+#define	NULL		( (void *) 0 )
+#endif
+
+/************************************************************************
+*                           Timeouts                                    *
+*************************************************************************
+*									*
+* The function timeout is alled with a pointer to a function to		*
+* invoke at a later time, an argument to be passed to the function,	*
+* and the number of ticks to wait.  'timeout' returns an integer	*
+* that serves as a "handle" for the timer.  The untimeout function	*
+* takes a timer handle as an argument and stops the timer.		*
+*									*
+* These two functions are defined in the dki.c file.  Their		*
+* implementation depends upon lis_tmout() and lis_untimout() which	*
+* are defined in either linux-mdep.c, which uses Linux timers to	*
+* implement the functions, or in the port-mdep.c file, which implements	*
+* a portable timer algorithm based on the Linux timer mechanism.	*
+*									*
+************************************************************************/
+
+#ifdef __KERNEL__
+
+typedef int	timo_fcn_t(caddr_t arg) ;
+
+#define	timeout(fcn,arg,ticks)	lis_timeout_fcn(fcn,arg,ticks,__FILE__, __LINE__)
+
+extern int	lis_timeout_fcn(timo_fcn_t *timo_fcn, caddr_t arg, long ticks,
+			    char *file_name, int line_nr) ;
+extern int	untimeout(int id) ;
+
+#endif				/* __KERNEL__ */
+
+#ifndef HZ
+#define	HZ	100			/* ticks per second */
+#endif
+
+
+
+
+#endif				/* from top of file */
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/dlpi.h /usr/src/linux/drivers/streams/LiS/include/sys/dlpi.h
--- debug/drivers/streams/LiS/include/sys/dlpi.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/dlpi.h	Mon Dec 16 16:36:40 1996
@@ -0,0 +1,1158 @@
+/* 
+ * dlpi.h 	   : Data Link Provider Interface
+ * Author          : David Grothe
+ * Created On      : Tue May 31 21:40:37 1994
+ * Last Modified By: $Author: dave $
+ * Last Modified On: $Date: 1996/02/11 20:53:12 $
+ * Update Count    : $Revision: 1.2 $
+ * RCS Id          : $Id: dlpi.h,v 1.2 1996/02/11 20:53:12 dave Exp $
+ * Status          : ($State: Exp $) 
+ * Purpose         : STREAMS interface to link level and MAC layer drivers
+ */
+
+#ifndef _DLPI_H
+#define _DLPI_H		1		/* define several markers */
+#define	 DLPI_H		1
+#define	 LIS_DLPI_H	1		/* unique to this version of dlpi.h */
+
+/************************************************************************
+*                           Reference                                   *
+*************************************************************************
+*									*
+* This file follows the DLPI specification published by UNIX		*
+* International, version 2.0.0 dated August 20, 1991.			*
+*									*
+************************************************************************/
+
+
+/************************************************************************
+*                           DLPI Types                                  *
+*************************************************************************
+*									*
+* Unlike other dlpi.h files, this one defines its own types so that	*
+* it can be used without depending upon system specific types.h files.	*
+*									*
+************************************************************************/
+typedef unsigned long		dl_ulong ;
+typedef unsigned short		dl_ushort ;
+
+/************************************************************************
+*                          Message Structures                           *
+*************************************************************************
+*									*
+* These structures are located in an M_PROTO or an M_PCPROTO message	*
+* starting at b_rptr.  Some message types also have an attached		*
+* M_DATA chained through the b_cont field.				*
+*									*
+* Each primitive is sent as a stream message.  It is possible that	*
+* the messages may be viewed as a sequence of bytes that have the	*
+* following form without any padding.  The structure definition		*
+* of the following messages may have to change depending on the		*
+* underlying hardware architecture and crossing of a hardware		*
+* boundary with a different hardware architecture.			*
+*									*
+* Fields in the primitives having a name of the form "dl_reserved"	*
+* cannot be used and have the value of binary zero, no bits turned on.	*
+*									*
+************************************************************************/
+
+/*
+ * Local Management Primitives
+ */
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+
+} dl_info_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_max_sdu ;
+    dl_ulong		dl_min_sdu ;
+    dl_ulong		dl_addr_length ;
+    dl_ulong		dl_mac_type ;
+    dl_ulong		dl_reserved ;
+    dl_ulong		dl_current_state ;
+    long		dl_sap_length ;			/* yes, signed long */
+    dl_ulong		dl_service_mode ;
+    dl_ulong		dl_qos_length ;
+    dl_ulong		dl_qos_offset ;
+    dl_ulong		dl_qos_range_length ;
+    dl_ulong		dl_qos_range_offset ;
+    long		dl_provider_style ;		/* yes, signed long */
+    dl_ulong		dl_addr_offset ;
+    dl_ulong		dl_version ;
+    dl_ulong		dl_brdcst_addr_length ;
+    dl_ulong		dl_brdcst_addr_offset ;
+    dl_ulong		dl_growth ;
+
+} dl_info_ack_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_ppa ;
+
+} dl_attach_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+
+} dl_detach_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_sap ;
+    dl_ulong		dl_max_conind ;
+    dl_ushort		dl_service_mode ;
+    dl_ushort		dl_conn_mgmt ;
+    dl_ulong		dl_xidtest_flg ;
+
+} dl_bind_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_sap ;
+    dl_ulong		dl_addr_length ;
+    dl_ulong		dl_addr_offset ;
+    dl_ulong		dl_max_conind ;
+    dl_ulong		dl_xidtest_flg ;
+
+} dl_bind_ack_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+
+} dl_unbind_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_subs_sap_offset ;
+    dl_ulong		dl_subs_sap_length ;
+    dl_ulong		dl_subs_bind_class ;
+
+} dl_subs_bind_req_t ;
+#define	dl_subs_sap_len	dl_subs_sap_length	/* SCO compatibility */
+
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_subs_sap_offset ;
+    dl_ulong		dl_subs_sap_length ;
+
+} dl_subs_bind_ack_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_subs_sap_offset ;
+    dl_ulong		dl_subs_sap_length ;
+
+} dl_subs_unbind_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_addr_length ;
+    dl_ulong		dl_addr_offset ;
+
+} dl_enabmulti_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_addr_length ;
+    dl_ulong		dl_addr_offset ;
+
+} dl_disabmulti_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_level ;
+
+} dl_promiscon_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_level ;
+
+} dl_promiscoff_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_correct_primitive ;
+
+} dl_ok_ack_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_error_primitive ;
+    dl_ulong		dl_errno ;
+    dl_ulong		dl_unix_errno ;
+
+} dl_error_ack_t ;
+
+
+/*
+ * Connection-mode Service Primitives
+ */
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_dest_addr_length ;
+    dl_ulong		dl_dest_addr_offset ;
+    dl_ulong		dl_qos_length ;
+    dl_ulong		dl_qos_offset ;
+    dl_ulong		dl_growth ;
+
+} dl_connect_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_correlation ;
+    dl_ulong		dl_called_addr_length ;
+    dl_ulong		dl_called_addr_offset ;
+    dl_ulong		dl_calling_addr_length ;
+    dl_ulong		dl_calling_addr_offset ;
+    dl_ulong		dl_qos_length ;
+    dl_ulong		dl_qos_offset ;
+    dl_ulong		dl_growth ;
+
+} dl_connect_ind_t ;
+
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_correlation ;
+    dl_ulong		dl_resp_token ;
+    dl_ulong		dl_qos_length ;
+    dl_ulong		dl_qos_offset ;
+    dl_ulong		dl_growth ;
+
+} dl_connect_res_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_resp_addr_length ;
+    dl_ulong		dl_resp_addr_offset ;
+    dl_ulong		dl_qos_length ;
+    dl_ulong		dl_qos_offset ;
+    dl_ulong		dl_growth ;
+
+} dl_connect_con_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+
+} dl_token_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_token ;
+
+} dl_token_ack_t ;
+
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_reason ;
+    dl_ulong		dl_correlation ;
+
+} dl_disconnect_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_originator ;
+    dl_ulong		dl_reason ;
+    dl_ulong		dl_correlation ;
+
+} dl_disconnect_ind_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+
+} dl_reset_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_originator ;
+    dl_ulong		dl_reason ;
+
+} dl_reset_ind_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+
+} dl_reset_res_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+
+} dl_reset_con_t ;
+
+
+
+/*
+ * Connectionless-mode Service Primitives
+ */
+
+typedef struct
+{
+    dl_ulong		dl_min ;
+    dl_ulong		dl_max ;
+
+} dl_priority_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_dest_addr_length ;
+    dl_ulong		dl_dest_addr_offset ;
+    dl_priority_t	dl_priority ;
+
+} dl_unitdata_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_dest_addr_length ;
+    dl_ulong		dl_dest_addr_offset ;
+    dl_ulong		dl_src_addr_length ;
+    dl_ulong		dl_src_addr_offset ;
+    dl_ulong		dl_group_address ;
+
+} dl_unitdata_ind_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_dest_addr_length ;
+    dl_ulong		dl_dest_addr_offset ;
+    dl_ulong		dl_unix_errno ;
+    dl_ulong		dl_errno ;
+
+} dl_uderror_ind_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_qos_length ;
+    dl_ulong		dl_qos_offset ;
+
+} dl_uqos_req_t ;
+
+
+
+/*
+ * XID and TEST Operations Primitives
+ */
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_flag ;
+    dl_ulong		dl_dest_addr_length ;
+    dl_ulong		dl_dest_addr_offset ;
+
+} dl_test_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_flag ;
+    dl_ulong		dl_dest_addr_length ;
+    dl_ulong		dl_dest_addr_offset ;
+    dl_ulong		dl_src_addr_length ;
+    dl_ulong		dl_src_addr_offset ;
+
+} dl_test_ind_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_flag ;
+    dl_ulong		dl_dest_addr_length ;
+    dl_ulong		dl_dest_addr_offset ;
+
+} dl_test_res_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_flag ;
+    dl_ulong		dl_dest_addr_length ;
+    dl_ulong		dl_dest_addr_offset ;
+    dl_ulong		dl_src_addr_length ;
+    dl_ulong		dl_src_addr_offset ;
+
+} dl_test_con_t ;
+
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_flag ;
+    dl_ulong		dl_dest_addr_length ;
+    dl_ulong		dl_dest_addr_offset ;
+
+} dl_xid_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_flag ;
+    dl_ulong		dl_dest_addr_length ;
+    dl_ulong		dl_dest_addr_offset ;
+    dl_ulong		dl_src_addr_length ;
+    dl_ulong		dl_src_addr_offset ;
+
+} dl_xid_ind_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_flag ;
+    dl_ulong		dl_dest_addr_length ;
+    dl_ulong		dl_dest_addr_offset ;
+
+} dl_xid_res_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_flag ;
+    dl_ulong		dl_dest_addr_length ;
+    dl_ulong		dl_dest_addr_offset ;
+    dl_ulong		dl_src_addr_length ;
+    dl_ulong		dl_src_addr_offset ;
+
+} dl_xid_con_t ;
+
+/*
+ * Acknowledged Connectionless-mode Service Primitives
+ */
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_correlation ;
+    dl_ulong		dl_dest_addr_length ;
+    dl_ulong		dl_dest_addr_offset ;
+    dl_ulong		dl_src_addr_length ;
+    dl_ulong		dl_src_addr_offset ;
+    dl_ulong		dl_priority ;
+    dl_ulong		dl_service_class ;
+
+} dl_data_ack_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_dest_addr_length ;
+    dl_ulong		dl_dest_addr_offset ;
+    dl_ulong		dl_src_addr_length ;
+    dl_ulong		dl_src_addr_offset ;
+    dl_ulong		dl_priority ;
+    dl_ulong		dl_service_class ;
+
+} dl_data_ack_ind_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_correlation ;
+    dl_ulong		dl_status ;
+
+} dl_data_ack_status_ind_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_correlation ;
+    dl_ulong		dl_dest_addr_length ;
+    dl_ulong		dl_dest_addr_offset ;
+    dl_ulong		dl_src_addr_length ;
+    dl_ulong		dl_src_addr_offset ;
+    dl_ulong		dl_priority ;
+    dl_ulong		dl_service_class ;
+
+} dl_reply_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_dest_addr_length ;
+    dl_ulong		dl_dest_addr_offset ;
+    dl_ulong		dl_src_addr_length ;
+    dl_ulong		dl_src_addr_offset ;
+    dl_ulong		dl_priority ;
+    dl_ulong		dl_service_class ;
+
+} dl_reply_ind_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_correlation ;
+    dl_ulong		dl_status ;
+
+} dl_reply_status_ind_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_correlation ;
+    dl_ulong		dl_src_addr_length ;
+    dl_ulong		dl_src_addr_offset ;
+
+} dl_reply_update_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_correlation ;
+    dl_ulong		dl_status ;
+
+} dl_reply_update_status_ind_t ;
+
+
+/*
+ * QOS parameter structures
+ */
+
+typedef struct
+{
+    dl_ulong		dl_target_value ;
+    dl_ulong		dl_accept_value ;
+
+} dl_through_t ;
+
+typedef struct
+{
+    dl_ulong		dl_target_value ;
+    dl_ulong		dl_accept_value ;
+
+} dl_transdelay_t ;
+
+typedef struct
+{
+    dl_ulong		dl_min ;
+    dl_ulong		dl_max ;
+
+} dl_protect_t ;
+
+typedef struct
+{
+    dl_ulong		dl_disc_prob ;
+    dl_ulong		dl_reset_prob ;
+
+} dl_resilience_t ;
+
+
+/*
+ * QOS Data Structures
+ */
+
+typedef struct
+{
+    dl_ulong		dl_qos_type ;
+    dl_through_t	dl_rcv_throughput ;
+    dl_transdelay_t	dl_rcv_trans_delay ;
+    dl_through_t	dl_xmt_throughput ;
+    dl_transdelay_t	dl_xmt_trans_delay ;
+    dl_priority_t	dl_priority ;
+    dl_protect_t	dl_protection ;
+    dl_ulong		dl_residual_error ;
+    dl_resilience_t	dl_resilience ;
+
+} dl_qos_co_range1_t ;
+
+typedef struct
+{
+    dl_ulong		dl_qos_type ;
+    dl_through_t	dl_rcv_throughput ;
+    dl_transdelay_t	dl_rcv_trans_delay ;
+    dl_through_t	dl_xmt_throughput ;
+    dl_transdelay_t	dl_xmt_trans_delay ;
+    dl_priority_t	dl_priority ;
+    dl_protect_t	dl_protection ;
+    dl_ulong		dl_residual_error ;
+    dl_resilience_t	dl_resilience ;
+
+} dl_qos_co_sel1_t ;
+
+typedef struct
+{
+    dl_ulong		dl_qos_type ;
+    dl_transdelay_t	dl_trans_delay ;
+    dl_priority_t	dl_priority ;
+    dl_protect_t	dl_protection ;
+    dl_ulong		dl_residual_error ;
+
+} dl_qos_cl_range1_t ;
+
+typedef struct
+{
+    dl_ulong		dl_qos_type ;
+    dl_transdelay_t	dl_trans_delay ;
+    dl_priority_t	dl_priority ;
+    dl_protect_t	dl_protection ;
+    dl_ulong		dl_residual_error ;
+
+} dl_qos_cl_sel1_t ;
+
+
+
+/*
+ * Physical Layer Management Primitives
+ */
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_addr_type ;
+
+} dl_phys_addr_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_addr_length ;
+    dl_ulong		dl_addr_offset ;
+
+} dl_phys_addr_ack_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_addr_length ;
+    dl_ulong		dl_addr_offset ;
+
+} dl_set_phys_addr_req_t ;
+
+
+/*
+ * Statistics Extensions
+ */
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+
+} dl_get_statistics_req_t ;
+
+typedef struct
+{
+    dl_ulong		dl_primitive ;
+    dl_ulong		dl_stat_length ;
+    dl_ulong		dl_stat_offset ;
+
+} dl_get_statistics_ack_t ;
+
+/*
+ * Union of all primitives
+ */
+union DL_primitives
+{
+    dl_ulong			dl_primitive ;
+    dl_detach_req_t		detach_req;
+    dl_bind_req_t		bind_req;
+    dl_bind_ack_t		bind_ack;
+    dl_unbind_req_t		unbind_req;
+    dl_subs_bind_req_t		subs_bind_req;
+    dl_subs_bind_ack_t		subs_bind_ack;
+    dl_subs_unbind_req_t	subs_unbind_req;
+    dl_enabmulti_req_t		enabmulti_req;
+    dl_disabmulti_req_t		disabmulti_req;
+    dl_promiscon_req_t		promiscon_req;
+    dl_promiscoff_req_t		promiscoff_req;
+    dl_ok_ack_t			ok_ack;
+    dl_error_ack_t		error_ack;
+    dl_connect_req_t		connect_req;
+    dl_connect_ind_t		connect_ind;
+    dl_connect_res_t		connect_res;
+    dl_connect_con_t		connect_con;
+    dl_token_req_t		token_req;
+    dl_token_ack_t		token_ack;
+    dl_disconnect_req_t		disconnect_req;
+    dl_disconnect_ind_t		disconnect_ind;
+    dl_reset_req_t		reset_req;
+    dl_reset_ind_t		reset_ind;
+    dl_reset_res_t		reset_res;
+    dl_reset_con_t		reset_con;
+    dl_priority_t		priority;
+    dl_unitdata_req_t		unitdata_req;
+    dl_unitdata_ind_t		unitdata_ind;
+    dl_uderror_ind_t		uderror_ind;
+    dl_uqos_req_t		uqos_req;
+    dl_test_req_t		test_req;
+    dl_test_ind_t		test_ind;
+    dl_test_res_t		test_res;
+    dl_test_con_t		test_con;
+    dl_xid_req_t		xid_req;
+    dl_xid_ind_t		xid_ind;
+    dl_xid_res_t		xid_res;
+    dl_xid_con_t		xid_con;
+    dl_data_ack_req_t		data_ack_req;
+    dl_data_ack_ind_t		data_ack_ind;
+    dl_data_ack_status_ind_t	data_ack_status_ind;
+    dl_reply_req_t		reply_req;
+    dl_reply_ind_t		reply_ind;
+    dl_reply_status_ind_t	reply_status_ind;
+    dl_reply_update_req_t	reply_update_req;
+    dl_reply_update_status_ind_t reply_update_status_ind;
+    dl_phys_addr_req_t		phys_addr_req;
+    dl_phys_addr_ack_t		phys_addr_ack;
+    dl_set_phys_addr_req_t	set_phys_addr_req;
+    dl_get_statistics_req_t	get_statistics_req;
+    dl_get_statistics_ack_t	get_statistics_ack;
+} ;
+
+
+
+/*
+ * Sizes of the primitives
+ */
+
+#define	DL_INFO_REQ_SIZE		sizeof(dl_info_req_t)
+#define	DL_INFO_ACK_SIZE		sizeof(dl_info_ack_t)
+#define DL_DETACH_REQ_SIZE		sizeof(dl_detach_req_t)
+#define DL_BIND_REQ_SIZE		sizeof(dl_bind_req_t)
+#define DL_BIND_ACK_SIZE		sizeof(dl_bind_ack_t)
+#define DL_UNBIND_REQ_SIZE		sizeof(dl_unbind_req_t)
+#define DL_SUBS_BIND_REQ_SIZE		sizeof(dl_subs_bind_req_t)
+#define DL_SUBS_BIND_ACK_SIZE		sizeof(dl_subs_bind_ack_t)
+#define DL_SUBS_UNBIND_REQ_SIZE		sizeof(dl_subs_unbind_req_t)
+#define DL_ENABMULTI_REQ_SIZE		sizeof(dl_enabmulti_req_t)
+#define DL_DISABMULTI_REQ_SIZE		sizeof(dl_disabmulti_req_t)
+#define DL_PROMISCON_REQ_SIZE		sizeof(dl_promiscon_req_t)
+#define DL_PROMISCOFF_REQ_SIZE		sizeof(dl_promiscoff_req_t)
+#define DL_OK_ACK_SIZE			sizeof(dl_ok_ack_t)
+#define DL_ERROR_ACK_SIZE		sizeof(dl_error_ack_t)
+#define DL_CONNECT_REQ_SIZE		sizeof(dl_connect_req_t)
+#define DL_CONNECT_IND_SIZE		sizeof(dl_connect_ind_t)
+#define DL_CONNECT_RES_SIZE		sizeof(dl_connect_res_t)
+#define DL_CONNECT_CON_SIZE		sizeof(dl_connect_con_t)
+#define DL_TOKEN_REQ_SIZE		sizeof(dl_token_req_t)
+#define DL_TOKEN_ACK_SIZE		sizeof(dl_token_ack_t)
+#define DL_DISCONNECT_REQ_SIZE		sizeof(dl_disconnect_req_t)
+#define DL_DISCONNECT_IND_SIZE		sizeof(dl_disconnect_ind_t)
+#define DL_RESET_REQ_SIZE		sizeof(dl_reset_req_t)
+#define DL_RESET_IND_SIZE		sizeof(dl_reset_ind_t)
+#define DL_RESET_RES_SIZE		sizeof(dl_reset_res_t)
+#define DL_RESET_CON_SIZE		sizeof(dl_reset_con_t)
+#define DL_PRIORITY_SIZE		sizeof(dl_priority_t)
+#define DL_UNITDATA_REQ_SIZE		sizeof(dl_unitdata_req_t)
+#define DL_UNITDATA_IND_SIZE		sizeof(dl_unitdata_ind_t)
+#define DL_UDERROR_IND_SIZE		sizeof(dl_uderror_ind_t)
+#define DL_UQOS_REQ_SIZE		sizeof(dl_uqos_req_t)
+#define DL_TEST_REQ_SIZE		sizeof(dl_test_req_t)
+#define DL_TEST_IND_SIZE		sizeof(dl_test_ind_t)
+#define DL_TEST_RES_SIZE		sizeof(dl_test_res_t)
+#define DL_TEST_CON_SIZE		sizeof(dl_test_con_t)
+#define DL_XID_REQ_SIZE			sizeof(dl_xid_req_t)
+#define DL_XID_IND_SIZE			sizeof(dl_xid_ind_t)
+#define DL_XID_RES_SIZE			sizeof(dl_xid_res_t)
+#define DL_XID_CON_SIZE			sizeof(dl_xid_con_t)
+#define DL_DATA_ACK_REQ_SIZE		sizeof(dl_data_ack_req_t)
+#define DL_DATA_ACK_IND_SIZE		sizeof(dl_data_ack_ind_t)
+#define DL_DATA_ACK_STATUS_IND_SIZE	sizeof(dl_data_ack_status_ind_t)
+#define DL_REPLY_REQ_SIZE		sizeof(dl_reply_req_t)
+#define DL_REPLY_IND_SIZE		sizeof(dl_reply_ind_t)
+#define DL_REPLY_STATUS_IND_SIZE	sizeof(dl_reply_status_ind_t)
+#define DL_REPLY_UPDATE_REQ_SIZE	sizeof(dl_reply_update_req_t)
+#define DL_REPLY_UPDATE_STATUS_IND_SIZE	sizeof(dl_reply_update_status_ind_t)
+#define DL_PHYS_ADDR_REQ_SIZE		sizeof(dl_phys_addr_req_t)
+#define DL_PHYS_ADDR_ACK_SIZE		sizeof(dl_phys_addr_ack_t)
+#define DL_SET_PHYS_ADDR_REQ_SIZE	sizeof(dl_set_phys_addr_req_t)
+#define DL_GET_STATISTICS_REQ_SIZE	sizeof(dl_get_statistics_req_t)
+#define DL_GET_STATISTICS_ACK_SIZE	sizeof(dl_get_statistics_ack_t)
+
+
+
+/************************************************************************
+*                          Field Values                                 *
+*************************************************************************
+*									*
+* The following #defines specifiy the values used in the fields of	*
+* the structures declared above.					*
+*									*
+* These values are taken from the listing of dlpi.h given in the	*
+* DLPI version 2 specification.  The listing in that specification	*
+* contains no copyright, so the following has been entered pretty	*
+* much literally from the listing.					*
+*									*
+************************************************************************/
+
+/*
+ * DLPI revision definition history
+ */
+#define	DL_CURRENT_VERSION	0x02		/* current version of DLPI */
+#define	DL_VERSION_2		0x02		/* DLPI March 12, 1991 */
+
+
+/************************************************************************
+*                          Primitive Types                              *
+************************************************************************/
+
+/*
+ * Primitives for Local Managemet Services
+ */
+#define	DL_INFO_REQ		0x00
+#define	DL_INFO_ACK		0x03
+#define	DL_ATTACH_REQ		0x0b
+#define DL_DETACH_REQ		0x0c
+#define DL_BIND_REQ		0x01
+#define DL_BIND_ACK		0x04
+#define DL_UNBIND_REQ		0x02
+#define DL_SUBS_BIND_REQ	0x1b
+#define DL_SUBS_BIND_ACK	0x1c
+#define DL_SUBS_UNBIND_REQ	0x15
+#define DL_ENABMULTI_REQ	0x1d
+#define DL_DISABMULTI_REQ	0x1e
+#define DL_PROMISCON_REQ	0x1f
+#define DL_PROMISCOFF_REQ	0x20
+#define DL_OK_ACK		0x06
+#define DL_ERROR_ACK		0x05
+/*
+ * Primitives used for Connection-Oriented Service
+ */
+#define DL_CONNECT_REQ		0x0d
+#define DL_CONNECT_IND		0x0e
+#define DL_CONNECT_RES		0x0f
+#define DL_CONNECT_CON		0x10
+#define DL_TOKEN_REQ		0x11
+#define DL_TOKEN_ACK		0x12
+#define DL_DISCONNECT_REQ	0x13
+#define DL_DISCONNECT_IND	0x14
+#define DL_RESET_REQ		0x17
+#define DL_RESET_IND		0x18
+#define DL_RESET_RES		0x19
+#define DL_RESET_CON		0x1a
+/*
+ * Primitives used for Connectionless Service
+ */
+#define DL_UNITDATA_REQ		0x07
+#define DL_UNITDATA_IND		0x08
+#define DL_UDERROR_IND		0x09
+#define DL_UQOS_REQ		0x0a
+/*
+ * Primitives for TEST and XID
+ */
+#define DL_TEST_REQ		0x2d
+#define DL_TEST_IND		0x2e
+#define DL_TEST_RES		0x2f
+#define DL_TEST_CON		0x30
+#define DL_XID_REQ		0x29
+#define DL_XID_IND		0x2a
+#define DL_XID_RES		0x2b
+#define DL_XID_CON		0x2c
+/*
+ * Primitives used for Acknowledged Connectionless Service
+ */
+#define DL_DATA_ACK_REQ		0x21
+#define DL_DATA_ACK_IND		0x22
+#define DL_DATA_ACK_STATUS_IND	0x23
+#define DL_REPLY_REQ		0x24
+#define DL_REPLY_IND		0x25
+#define DL_REPLY_STATUS_IND	0x26
+#define DL_REPLY_UPDATE_REQ	0x27
+#define DL_REPLY_UPDATE_STATUS_IND 0x28
+/*
+ * Primitives to get and set the physical address
+ */
+#define DL_PHYS_ADDR_REQ	0x31
+#define DL_PHYS_ADDR_ACK	0x32
+#define DL_SET_PHYS_ADDR_REQ	0x33
+/*
+ * Primitives to get statistics
+ */
+#define DL_GET_STATISTICS_REQ	0x34
+#define DL_GET_STATISTICS_ACK	0x35
+
+
+/************************************************************************
+*                       DLPI Interface States                           *
+*************************************************************************
+*									*
+* Refer to DLPI spec for the meaning of these states.			*
+*									*
+************************************************************************/
+
+#define DL_UNATTACHED		0x04
+#define DL_ATTACH_PENDING	0x05
+#define DL_DETACH_PENDING	0x06
+#define DL_UNBOUND		0x00
+#define DL_BIND_PENDING		0x01
+#define DL_UNBIND_PENDING	0x02
+#define DL_IDLE			0x03
+#define DL_UQOS_PENDING		0x07
+#define DL_OUTCON_PENDING	0x08
+#define DL_INCON_PENDING	0x09
+#define DL_CONN_RES_PENDING	0x0a
+#define DL_DATAXFER		0x0b
+#define DL_USER_RESET_PENDING	0x0c
+#define DL_PROV_RESET_PENDING	0x0d
+#define DL_RESET_RES_PENDING	0x0e
+#define DL_DISCON8_PENDING	0x0f
+#define DL_DISCON9_PENDING	0x10
+#define DL_DISCON11_PENDING	0x11
+#define DL_DISCON12_PENDING	0x12
+#define DL_DISCON13_PENDING	0x13
+#define DL_SUBS_BIND_PND	0x14
+#define DL_SUBS_UNBIND_PND	0x15
+
+/************************************************************************
+*                        DL_ERROR_ACK Error Values                      *
+*************************************************************************
+*									*
+* These are the values of the dl_errno field.				*
+*									*
+************************************************************************/
+
+#define DL_ACCESS	0x02	/* Improper permissions */
+#define DL_BADADDR	0x01	/* DLSAP addr in improper format or invalid */
+#define DL_BADCORR	0x05	/* Seq nr not from outstanding DL_CONN_IND */
+#define DL_BADDATA	0x06	/* User data exceeded provider limit */
+#define DL_BADPPA	0x08	/* PPA was invalid */
+#define DL_BADPRIM	0x09	/* Primitive received is not know by DLS prov */
+#define DL_BADQOSPARAM	0x0a	/* QOS params contained invalid values */
+#define DL_BADQOSTYPE	0x0b	/* QOS structure type unknown or unsupported */
+#define DL_BADSAP	0x00	/* Bad LSAP selector, LLI compatibility */
+#define DL_BADTOKEN	0x0c	/* Token not associated with active stream */
+#define DL_BOUND	0x0d	/* Attempted second bind with dl_max_conind or
+				 * dl_conn_mgmt > 0 on same DLSAP or PPA
+				 */
+#define DL_INITFAILED	0x0e	/* Physical link initialization failed */
+#define DL_NOADDR	0x0f	/* Provider couldn't allocate alternate addr */
+#define DL_NOTINIT	0x10	/* Physical link not initialized */
+#define DL_OUTSTATE	0x03	/* Primitive issued in improper state */
+#define DL_SYSERR	0x04	/* UNIX system error occurred */
+#define DL_UNSUPPORTED	0x07	/* Requested service not supplied by provider */
+#define DL_UNDELIVERABLE 0x11	/* Previous data unit could not be delivered */
+#define DL_NOTSUPPORTED	0x12	/* Primitive is known but not supported */
+#define DL_TOOMANY	0x13	/* Limit exceeded */
+#define DL_NOTENAB	0x14	/* Promiscuous mode not enabled */
+#define DL_BUSY		0x15	/* Other streams for a particular PPA in
+				 * the post-attached state.
+				 */
+#define DL_NOAUTO	0x16	/* Automatic handling of XID and TEST response
+				 * not supported.
+				 */
+#define DL_NOXIDAUTO	0x17	/* Automatic handling of XID not supported */
+#define DL_NOTESTAUTO	0x18	/* Automatic handling of TEST not supported */
+#define DL_XIDAUTO	0x19	/* Automatic handling of XID response */
+#define DL_TESTAUTO	0x1a	/* Automatic handling of TEST response */
+#define DL_PENDING	0x1b	/* pending outstanding connect indications */
+
+/*
+ * NOTE: The range of error codes from 0x80 - 0xff is reserved for
+ *       implementation specific error codes.  This reserved range
+ *       of error codes will be defined by the DLS Provider.
+ */
+
+
+/************************************************************************
+*                         Types of Services                             *
+************************************************************************/
+
+/*
+ * Media types supported
+ */
+#define DL_CSMACD	0x00	/* IEEE 802.3 CSMA/CD network */
+#if 0
+#define DL_TPB		0x01	/* IEEE 802.4 Token Passing Bus */
+#endif
+#define DL_TPR		0x02	/* IEEE 802.5 Token Passing Ring */
+#define DL_METRO	0x03	/* IEEE 802.6 Metro Net */
+#define DL_ETHER	0x04	/* Ethernet Bus */
+#define DL_HDLC		0x05	/* ISO HDLC protocol support, bit synchronous */
+#define DL_CHAR		0x06	/* Character Synchronous (Bisync) */
+#define DL_CTCA		0x07	/* IBM Channel-to-Channel Adapter */
+#define DL_FDDI		0x08	/* Fiber Distributed Data Interface */
+#define DL_OTHER	0x09	/* Any other medium not lested above */
+				/* DMG: Note missing ATM and Frame Relay */
+
+/*
+ * DLPI provider services supported
+ *
+ * These are bit-wise ORed for dl_service_mode in DL_INFO_ACK
+ */
+#define	DL_CODLS	0x01	/* connection oriented service supported */
+#define	DL_CLDLS	0x02	/* connectionless service supported */
+#define	DL_ACLDLS	0x04	/* acknowledged connectionless service */
+
+
+/*
+ * DLPI provider style
+ *
+ * The DLPI provider style which determines whether a provider
+ * requires a DL_ATTACH_REQ to inform the provider which PPA
+ * user messages should be set/receive on.
+ */
+#define	DL_STYLE1	0x0500	/* PPA is implicitly bound by open */
+#define	DL_STYLE2	0x0501	/* PPA must be attached by DL_ATTACH_REQ */
+
+
+
+/************************************************************************
+*                     Disconnect and Reset Reasons                      *
+************************************************************************/
+
+/*
+ * DLPI Originator for Disconnect and Resets
+ */
+#define	DL_PROVIDER	0x0700
+#define	DL_USER		0x0701
+
+/*
+ * DLPI Disconnect Reasons
+ */
+#define DL_CONREJ_DEST_UNKNOWN			0x0800
+#define DL_CONREJ_DEST_UNREACH_PERMANENT	0x0801
+#define DL_CONREJ_DEST_UNREACH_TRANSIENT	0x0802
+#define DL_CONREJ_QOS_UNAVAIL_PERMANENT		0x0803
+#define DL_CONREJ_QOS_UNAVAIL_TRANSIENT		0x0804
+#define DL_CONREJ_PERMANENT_COND		0x0805
+#define DL_CONREJ_TRANSIENT_COND		0x0806
+#define DL_DISC_ABNORMAL_CONDITION		0x0807
+#define DL_DISC_NORMAL_CONDITION		0x0808
+#define DL_DISC_PERMANENT_CONDITION		0x0809
+#define DL_DISC_TRANSIENT_CONDITION		0x080a
+#define DL_DISC_UNSPECIFIED			0x080b
+
+/*
+ * DLPI Reset Reasons
+ */
+#define DL_RESET_FLOW_CONTROL			0x0900
+#define DL_RESET_LINK_ERROR			0x0901
+#define DL_RESET_RESYNCH			0x0902
+
+
+/************************************************************************
+*                 Acknowledged Connectionless Service                   *
+************************************************************************/
+
+/*
+ * DLPI status values for acknowledged connectionless data transfer
+ */
+#define DL_CMD_MASK	0x0f
+#define DL_CMD_OK	0x00	/* Command accepted */
+#define DL_CMD_RS	0x01	/* Unimplemented or inactivated service */
+#define DL_CMD_UE	0x05	/* Data Link User interface error */
+#define DL_CMD_PE	0x06	/* protocol error */
+#define DL_CMD_IP	0x07	/* Permanent implementation dependent error */
+#define DL_CMD_UN	0x09	/* Resources temporarily unavailable */
+#define DL_CMD_IT	0x0f	/* Temporary implementation dependent error */
+
+#define DL_RSP_MASK	0xf0
+#define DL_RSP_OK	0x00	/* Response DLSDU present */
+#define DL_RSP_RS	0x10	/* Unimplemented or inactivated service */
+#define DL_RSP_NE	0x30	/* Response DLSDU never submitted */
+#define DL_RSP_NR	0x40	/* Response DLSDU not requested */
+#define DL_RSP_UE	0x50	/* Data Link User interface error */
+#define DL_RSP_IP	0x70	/* Permanent implementation dependent error */
+#define DL_RSP_UN	0x90	/* Resources temporarily unavailable */
+#define DL_RSP_IT	0xf0	/* Temporary implementation dependent error */
+
+/*
+ * Service class values for acknowledged connectionless data transfer
+ */
+#define DL_RQST_RSP	0x01	/* Use acknowldege capability in MAC sublayer */
+#define DL_RQST_NORSP	0x01	/* No acknowldegement services requested */
+
+
+
+/************************************************************************
+*                       Quality of Service                              *
+************************************************************************/
+
+/*
+ * QOS Protection specification
+ */
+#define	DL_NONE			0x0b01	/* no protection supplied */
+#define	DL_MONITOR		0x0b02	/* protection against passive
+					 * monitoring
+					 */
+#define	DL_MAXIMUM		0x0b03	/* protection against modification,
+					 * replay, addition or deletion.
+					 */
+
+/*
+ * QOS parameter values
+ */
+#define DL_UNKNOWN		-1
+#define DL_QOS_DONT_CARE	-2
+
+/*
+ * QOS type definitions
+ */
+#define DL_QOS_CO_RANGE1	0x0101	/* connection oriented service */
+#define DL_QOS_CO_SEL1		0x0102	/* connection oriented service */
+#define DL_QOS_CL_RANGE1	0x0103	/* connectionless service */
+#define DL_QOS_CL_SEL1		0x0104	/* connectionless service */
+
+
+/************************************************************************
+*                          Miscellaneous                                *
+************************************************************************/
+
+/*
+ * DLPI address type definition
+ */
+#define	DL_FACT_PHYS_ADDR	0x01	/* factory physical address */
+#define	DL_CURR_PHYS_ADDR	0x02	/* current physical address */
+
+/*
+ * DLPI flag definitions
+ */
+#define	DL_POLL_FINAL		0x01	/* poll/final bit for TEST/XID */
+
+/*
+ * XID and TEST responses supported by the provider
+ */
+#define DL_AUTO_XID		0x01	/* provider will respond to XID */
+#define DL_AUTO_TEST		0x01	/* provider will respond to TEST */
+
+/*
+ * Subsequent bind types
+ */
+#define	DL_PEER_BIND		0x01	/* subsequent bind on a peer addr */
+#define	DL_HIERARCHICAL_BIND	0x01	/* subs-bind on a hierarchical addr */
+
+/*
+ * DLPI promiscuous mode definitions
+ */
+#define	DL_PROMISC_PHYS		0x01	/* promiscuous mode at physical level */
+#define	DL_PROMISC_SAP		0x01	/* promiscuous mode at SAP level */
+#define	DL_PROMISC_MULTI	0x01	/* promiscuous mode for multicast */
+
+
+
+
+
+#endif /*!_DLPI_H*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/kmem.h /usr/src/linux/drivers/streams/LiS/include/sys/kmem.h
--- debug/drivers/streams/LiS/include/sys/kmem.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/kmem.h	Mon Dec 16 16:36:40 1996
@@ -0,0 +1,22 @@
+/*
+ * This file provides some prototypes and defines for SVR4 compatibility
+ */
+
+#ifdef __KERNEL__
+
+#ifndef _STRPORT_H
+#include <sys/strport.h>
+#endif
+
+#ifdef QNX
+void * port_sbrk(int siz);
+void   port_tok_free(char *ptr, int siz);
+
+#define	kmem_alloc(siz,wait_code)	port_sbrk((siz))
+#define	kmem_free(ptr,siz)		port_tok_free((ptr), (siz))
+#else
+#define	kmem_alloc(siz,wait_code)	ALLOC(siz)
+#define	kmem_free(ptr,siz)		FREE(ptr)
+#endif
+
+#endif				/* __KERNEL__ */
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/major.h /usr/src/linux/drivers/streams/LiS/include/sys/major.h
--- debug/drivers/streams/LiS/include/sys/major.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/major.h	Mon Dec 16 16:36:40 1996
@@ -0,0 +1 @@
+must add str devs
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/mkdev.h /usr/src/linux/drivers/streams/LiS/include/sys/mkdev.h
--- debug/drivers/streams/LiS/include/sys/mkdev.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/mkdev.h	Mon Dec 16 16:36:40 1996
@@ -0,0 +1,4 @@
+/* 
+ * A file needed by SVR4
+ * A dummy for linux
+ */
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/npi.h /usr/src/linux/drivers/streams/LiS/include/sys/npi.h
--- debug/drivers/streams/LiS/include/sys/npi.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/npi.h	Wed Jan  1 13:04:40 1997
@@ -0,0 +1,876 @@
+
+
+
+/*
+ * npi.h header for the Network Provider Interface (OSI conforming)
+ */
+
+#ifndef SYS_NPI_H
+#define SYS_NPI_H				/* mark file as included */
+
+
+/*
+ * Primitives that are initiated by the network user.
+ */
+
+#define N_CONN_REQ	0	/* NC request */
+#define N_CONN_RES	1	/* Accept previous connection indication */
+#define N_DISCON_REQ	2	/* NC disconnection request */
+#define N_DATA_REQ	3	/* Conneciton-Mode data transfer request */
+#define N_EXDATA_REQ	4	/* Expeted data request */
+#define N_INFO_REQ	5	/* Information Request */
+#define N_BIND_REQ	6	/* Bind a NS user to network address */
+#define N_UNBIND_REQ	7	/* Unbind NS user from network address */
+#define N_UNITDATA_REQ	8	/* Connection-less data send request */
+#define N_OPTMGMT_REQ	9	/* Options Management requiest */
+
+/*
+ * Primitives that are initiated by the network provider.
+ */
+#define N_CONN_IND	11	/* Incoming connection indication */
+#define N_CONN_CON	12	/* Connection established */
+#define N_DISCON_IND	13	/* NC disconnected */
+#define N_DATA_IND	14	/* Incoming connection-mode data indication */
+#define N_EXDATA_IND	15	/* Incoming expedited data indication */
+#define N_INFO_ACK	16	/* Inomation Acknowledgement */
+#define N_BIND_ACK	17	/* NS User bound to network address */
+#define N_ERROR_ACK	18	/* Error Acknowledgement */
+#define N_OK_ACK	19	/* Success Acknowledgement */
+#define N_UNITDATA_IND	20	/* Connection-less data receive indication */
+#define N_UDERROR_IND	21	/* UNITDATA Error Indication*/
+
+/*
+ * Additional NPI Primitives
+ */
+
+#define N_DATACK_REQ	23	/* Data acknowledgment request */
+#define N_DATACK_IND	24	/* Data acknowledgement indication */
+#define N_RESET_REQ	25	/* NC reset request */
+#define N_RESET_IND	26	/* Inccoming NC reset request indication */
+#define N_RESET_RES	27	/* Reset processing accepted */
+#define N_RESET_CON	28	/* Reset processing complete */
+
+/*
+ *  The following are the events that drive the state machine
+ */
+
+/*
+ * Initialization events
+ */
+
+#define NE_BIND_REQ 	0	/* bind request */
+#define NE_UNBIND_REQ	1	/* unbind reques*/
+#define NE_OPTMGMT_REQ	2	/* manage options request */
+#define NE_BIND_ACK	3	/* bind acknowledgement */
+#define NE_ERROR_ACK	5	/* error acknowledgement */
+#define NE_OK_ACK1	6	/* ok ack, outcnt ==0 */
+#define NE_OK_ACK2	7	/* ok ack, outcnt == 1, q == rq */
+#define NE_OK_ACK3	8	/* ok ack, outcnt == 1, q! == rq */
+#define NE_OK_ACK4	9	/* ok ack, outcnt >1 */
+
+/*Connection-Mode events */
+#define NE_CONN_REQ	10	/* connect request */
+#define NE_CONN_RES	11	/* connect response */
+#define NE_DISCON_REQ	12	/* disconnect request */
+#define NE_DATA_REQ	13	/* data request */
+#define NE_EXDATA_REQ	14	/* expedited data request */
+#define NE_CONN_IND	16	/* connect indication */
+#define NE_CONN_CON	17	/* connect confirm */
+#define NE_DATA_IND	18	/* data indication */
+#define NE_EXDATA_IND	19	/* expedited data indication */
+#define NE_DISCON_IND1	21	/* disconnect indication, outcnt == 0 */
+#define NE_DISCON_IND2	22	/* disconnect indication, outcnt == 1 */
+#define NE_DISCON_IND3	23	/* disconnect indication, outcnt  > 1 */
+#define NE_PASS_CON	24	/* pass connection */
+#define NE_RESET_REQ	28	/* reset request */
+#define NE_RESET_RES	29	/* reset response */
+#define NE_DATACK_REQ	30	/* data acknowledgement request */
+#define NE_DATACK_IND	31	/* data acknowledgement indication */
+#define NE_RESET_IND	32	/* reset indication */
+#define NE_RESET_CON	33	/* reset confirm */
+
+/*
+ * Connection-less events 
+ */
+#define NE_UNITDATA_REQ	25	/* unitdata request */
+#define NE_UNITDATA_IND	26	/* unitdata indication */
+#define NE_UDERROR_IND	27	/* unitdata error indication */
+ 
+#define NE_NOEVENTS	36	/* no events */
+
+/*
+ *   NPI interface states
+ */
+#define NS_UNBND	0	/* NS user not bound to network address */
+#define NS_WACK_BREQ	1	/* Awaiting acknowledgement of N_BIND_REQ */
+#define NS_WACK_UREQ	2	/* Pending acknowledgement of N_UNBIND_REQ */
+#define NS_IDLE		3	/* Idle, no conneciton */
+#define NS_WACK_OPTREQ	4	/* Pending acknowledgement of N_OPTMGMT_REQ */
+#define NS_WACK_RRES	5	/* Pending acknowledgement of N_RESET_RES */
+#define NS_WCON_CREQ	6	/* Pending confirmation of N_CONN_REQ */
+#define NS_WRES_CIND	7	/* Pending response of N_CONN_IND */
+#define NS_WACK_CRES	8	/* Pending acknowledgement of N_CONN_RES */
+#define NS_DATA_XFER	9	/* Connection-mode data transfer */
+#define NS_WCON_RREQ	10	/* Pending confirmation of N_RESET_REQ */
+#define NS_WRES_RIND	11	/* Pending response of N_RESET_IND */
+#define NS_WACK_DREQ6	12	/* Waiting ack of N_DISCON_REQ */
+#define NS_WACK_DREQ7	13	/* Waiting ack of N_DISCON_REQ */
+#define NS_WACK_DREQ9	14	/* Waiting ack of N_DISCON_REQ */
+#define NS_WACK_DREQ10	15	/* Waiting ack of N_DISCON_REQ */
+#define NS_WACK_DREQ11	16	/* Waiting ack of N_DISCON_REQ */
+
+#define NS_NOSTATES	18	/* No states */
+
+
+/*
+ *  N_ERROR_ACK error return code values
+ */
+#define NBADADDR	1  /* Incorrect address format/illegal address info */
+#define NBADOPT		2  /* Options in incorrect format or contain illegal information*/
+#define NACCESS		3  /* User did not have proper permissions*/
+#define NNOADDR		5  /* NS Provider could not allocate address*/
+#define NOUTSTATE	6  /* Primitive was issues in wrong sequence*/
+#define NBADSEQ		7  /* Sequence number in primitive was incorrect/illegal*/
+#define NSYSERR		8  /* UNIX system error*/
+#define NBADDATA	10 /* User data spec. outside range supported by NS provider*/
+#define NBADFLAG	16 /* Flags specified in primitive were		      */
+			   /* illegal/incorrect */
+#define NNOTSUPPORT	18 /* Primitive type not supported by the NS provider */
+#define NBOUND		19 /* Illegal second attempt to bind listener or      */
+			   /* default listener */
+#define NBADQOSPARAM 	20 /* QOS values specified are outside the range      */
+			   /* supported by the NS provider */
+#define NBADQOSTYPE	21 /* QOS structure type specified is not supported   */
+			   /* by the NS provider */
+#define NBADTOKEN	22 /* Token used is not associated with an open stream*/
+
+/*
+ *  N_UDERROR_IND reason codes
+ */
+#define N_UD_UNDEFINED		10	/*no reason specified*/
+#define N_UD_TD_EXCEEDED	11	/*Transit delay exceeded*/
+#define N_UD_CONGESTION		12	/*NS Provider congestion*/
+#define N_UD_QOS_UNAVAIL	13	/*Requested QOS/service characteristic unavailable*/
+#define N_UD_LIFE_EXCEEDED	14	/*NSDU Lifetime exceeded*/
+#define N_UD_ROUTE_UNAVAIL	15	/*Suitable route unavailable*/
+
+
+/*
+ *   NPI Originator for Resets and Disconnects
+ */
+#define N_PROVIDER	0x0100	/* provider originated reset/disconnect */
+#define N_USER		0x0101	/* user originated reset/disconnect */
+#define N_UNDEFINED	0x0102	/* reset/disconnect originator undefined */
+
+
+/*
+ *  NPI Disconnect & Reset reasons when the originator is the N_UNDEFINED
+ */
+
+#define N_REASON_UNDEFINED	0x0200
+
+/*
+ *  NPI Disconnect reasons when the originator is the N_PROVIDER
+ */
+
+#define N_DISC_P		0x0300	/* Disconnection-permanent condition  */
+#define N_DISC_T		0x0301	/* Disconnection-transient condition  */
+#define N_REJ_NSAP_UNKNOWN	0x0302	/* Connection rejection-NSAP address  */
+					/* unknown (permanent condition)      */
+#define N_REJ_NSAP_UNREACH_P	0x0303	/* Connection rejection rejection-NSAP*/
+					/* unreachable (permanent condition)  */
+#define N_REJ_NSAP_UNREACH_T	0x0304	/* Conneciton rejection-NSAP	      */
+					/* unreachable (transient condition)  */
+
+/*
+ *  NPI  Disconnect reasons when the originator is the N_USER 
+ */
+#define N_DISC_NORMAL		0x0400	/* Disconnection-normal condition    */
+#define N_DISC_ABNORMAL		0x0401	/* Disconnection-abnormal condition  */
+#define N_REJ_P			0x0402	/* Connection rejection-permanent    */
+					/* condition */
+#define N_REJ_T			0x0403	/* Connection rejection-temporary    */
+					/* condition */
+#define N_REJ_INCOMPAT_INFO	0x0406	/* Connection rejection incompatible */
+					/* information in NS-user-data       */
+
+
+/*
+ *  NPI Disconnect reasons when the originator is the N_USER or N_PROVIDER
+ */
+#define N_REJ_QOS_UNAVAIL_P	0x0305	/* Connection rejection-QOS          */
+					/* unavailable (permanent condition) */
+#define N_REJ_QOS_UNAVAIL_T	0x0306	/* Connection rejection_QOS	     */
+					/* unavailable (transient condition) */
+#define N_REJ_UNSPECIFIED	0x0307	/* Connection rejection-reason       */
+					/* unspecified			     */
+
+/*
+ *  NPI Reset reasons when originator is N_PROVIDER
+ */
+
+#define N_CONGESTION		0x0500	/* Reset due to congestion */
+#define N_RESET_UNSPECIFIED	0x0501	/* Reset-reason "unspecified" */
+
+/*
+ *  NPI Reset reasons when originator is N_USER
+ */
+#define N_USER_RESYNC		0x0600	/* Reset due to user resynchronizaiton*/
+
+/*
+ *  CONN_flags definition; (used in N_conn_req, N_conn_ind, N_conn_res,
+ *  and N_conn_con *primitives)
+ *
+ * Flags to indicate support of network provider options;
+ * (used with the OPTIONS_)flags field of N_info_ack primitive)
+ */
+
+#define REC_CONF_OPT	0x00000001L	/*Receipt Confirmation Selection and Support*/
+#define EX_DATA_OPT	0x00000002L	/*Expedited Data Selection and Support*/
+
+/* This flag is used with the OPTIONS _flags field of N_info_ack as well as */
+/* the OPTMGMT_flags of the N_optmgmnt_req primitive */
+
+#define DEFAULT_RC_SEL	0x00000003L	/*Indicates if default receipt confirmation is selected*/
+
+
+/*
+ * BIND_flags; (used with N_bind_req primitive)
+ */
+
+#define DEFAULT_LISTENER	0x00000001L	/*this stream is the default listener*/
+#define TOKEN_REQUEST		0x00000002L	/*"token" should be assigned to the stream*/
+
+
+/*
+ * QOS Parameter Definitions
+ */
+
+
+/*
+ *  Throughput
+ * 
+ *  This parameter is specified for both directions.
+ */
+
+typedef struct
+{
+	long	thru_tar_value;	/*target throughput values*/
+	long	thru_min_value;	/*minimum acceptable throughput value*/
+}  thru_values_t;
+
+/*
+*  Transit Delay
+*/
+
+typedef struct
+{
+	long	td_targ_value;		/*target transmit delay*/
+	long	thru_min_value;		/*maximum acceptable transit delay*/
+}  td_values_t; 
+
+
+/*
+ *  Protection Values
+ */
+
+typedef struct
+{
+	long	protect_targ_value;	/*target proteciton value*/
+	long	protect_min_value;	/*minimum or available protection*/
+}  protection_values_t;
+
+
+/*
+ *  Priority values
+ */
+
+typedef struct
+{
+	long	priority_targ_value;	/*target priority*/
+	long	priority_min_value;	/*minimum acceptable priority*/
+}  priority_values_t;
+
+
+/*
+ *  Types of proteciton specifications
+ */
+#define	N_NO_PROT		0x0000000L	/*no protection*/
+#define	N_PASSIVE_PROT		0x00000001L	/*protection against passive monitoring*/
+#define	N_ACTIVE_PROT		0x00000002L	/*protection against active monitoring*/
+#define	N_ACTIVE_PASSIVE_PROT	0x00000003L	/*protection against active and passive monitoring*/
+
+/*
+ *  Cost Selection
+ */
+
+#define N_LEAST_EXPENSIVE	0x0000000L	/*choose least expensive means*/
+
+
+
+/*
+*   QOS STRUCTURE TYPES AND DEFINED VALUES
+*/
+
+#define N_QOS_CO_RANGE1		0x0101
+#define N_QOS_CO_SEL1		0x0102
+#define N_QOS_CL_RANGE1		0x0103
+#define N_QOS_CL_SEL1		0x0104
+#define N_QOS_CO_OPT_RANGE1	0x0105
+#define N_QOS_CO_OPT_SEL1	0x0105
+
+
+/*
+ * When NS user/provider cannot determine the value of a QOS field,
+ * it should return a value of QOS_UNKNOWN.
+ */
+
+#define QOS_UNKNOWN			-1
+
+typedef unsigned long np_ulong;
+
+/*
+ *  QOS range for CONS.  (Used with N_CONN_REQ and N_CONN_IND.)
+ */
+typedef struct
+{
+    np_ulong		n_qos_type;		/*always N_QOS_CO_RANGE*/
+    thru_values_t	src_throughput_range;	/*source throughput range*/
+    thru_values_t	dest_throughput_range;	/*destination throughput range*/
+    td_values_t		transit_delay_range;	/*transit delay range*/
+    protection_values_t	protection_range;	/*protection range*/
+    priority_values_t	priority_range;		/*priority range*/
+}  N_qos_co_range_t;
+
+
+/*
+ *  QOS selected for CONS.   (Used with N_CONN_RES and N_CONN_CON.)
+ */
+
+typedef struct
+{
+    np_ulong	n_qos_type;		/*always N_QOS_CO_SEL*/
+    long	src_throughput_sel;	/*source throughput selected*/
+    long	dest_throughput_sel;	/*destination ghroughput selected*/
+    long	transit_delay_sel;	/*transit delay selected*/
+    long	protection_sel;		/*NC protection selected*/
+    long	priority_sel;		/*NC priority selected*/
+}  N_qos_co_sel_t;
+
+
+
+/*
+ *   QOS range for CLNS options management.  (Used with N_INFO_ACK.)
+ */
+typedef struct
+{
+    np_ulong		n_qos_type;		/*always N_QOS_CL_RANGE*/
+    td_values_t		transit_delay_max;	/*maximum transit delay*/
+    np_ulong		residual_error_rate;	/*residual error rate*/
+    protection_values_t	protection_range;	/*protection range*/
+    priority_values_t	priority_range;		/*priority range*/
+    long		max_accept_cost;	/*maximum acceptable cost*/
+}   N_qos_cl_range_t;
+
+
+/*
+ *  QOS selection for CLNS options management.
+ * (Used with N_OPTMGMT_REQ and N_INFO_ACK.)
+ */
+typedef struct
+{
+    np_ulong		n_qos_type;		/*always N_QOS_CL sel*/
+    long		transit_delay_max;	/*maximum transit delay*/
+    np_ulong		residual_error_rate;	/*residual error rate*/
+    long		protection_sel;		/*protection range*/
+    long		priority_sel;		/*priority range*/
+    long		max_accept_cost;	/*maximum acceptable cost*/
+}  N_qos_cl_sel_t;
+
+
+/*
+ *   QOS range for CONS options management.  (used with N_OPTMGMT_REQ.)
+ */
+typedef struct 
+{
+    np_ulong		n_qos_type;		/*always N_QOS_CO_OPT RANGE*/
+    thru_values_t	src_throughput;		/*source throughput values*/
+    thru_values_t	dest_throughput;	/*dest throughput values*/
+    td_values_t		transit_delay;		/*transit delay values*/
+    long		nc_estab_delay;		/*NC establishment delay*/
+    np_ulong		nc_estab_fall_prob;	/*NC estab failure probability*/
+    np_ulong		residual_error_rate;	/*residual error rate*/
+    np_ulong		xfer_fail_prob;		/*transfer failure probability*/
+    np_ulong		nc_resilience;		/*NC resilience*/
+    long		nc_rel_delay;		/*NC release delay*/
+    np_ulong		nc_rel_fail_prob;	/*NC release failure probability*/
+    protection_values_t	protection_range;	/*protection selected*/
+    priority_values_t	priority_range;		/*priority selected*/
+    long		max_accept_cost;	/*maximum acceptable cost*/
+}  N_qos_co_opt_range_t;
+
+
+/*
+ *   QOS values selected for CONS options management.
+ *   (Used with N_OPTMGMT_REQ and N_INFO_ACK.)
+ */
+typedef struct
+{
+    np_ulong		n_qos_type;		/*always N_QOS CO_OPT_SEL*/
+    thru_values_t	src_throughput;		/*source throughput values*/
+    thru_values_t	dest_throughput;	/*dest throughput values*/
+    td_values_t		transit_delay_t;	/*transit delay values*/
+    long		nc_estab_delay;		/*NC establishment  delay */
+    np_ulong		nc_estab_fail_prob;	/*NC establishment delay*/
+    np_ulong		residual_error_rate;	/*residual error rate*/
+    np_ulong		xfer_fail_prob;		/*transfer failure probability*/
+    np_ulong		nc_resilience;		/*NC resilience*/
+    long		nc_relay;		/*NC release delay*/
+    np_ulong		nc_rel_fail_prob;	/*NC release failure probability*/
+    long		protection_sel;		/*protection selected*/
+    long		priority_sel;		/*priority selected*/
+    long		max_accept_cost;	/*maximum acceptable cost*/
+}  N_qos_co_opt_sel_t;
+
+
+/*
+ *   NPI Primitive Definitions
+ */
+
+/*
+ *   Local management service primitives
+ */
+
+
+/*
+ *   Information request
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/*always N_INFO_REQ*/
+}  N_info_req_t;
+
+
+/*
+ *  Information acknowledgement
+ */
+
+typedef struct  
+{
+    np_ulong PRIM_type;			/*always N_INFO_ACK*/
+    np_ulong NSDU_size;			/*maximum NSDU size*/
+    np_ulong ENSDU_size;			/*maximum ENSDU size*/
+    np_ulong CDATA_size;			/*connect diata size*/
+    np_ulong DDATA_size;			/*discon data size*/
+    np_ulong ADDR_size;			/*address size*/
+    np_ulong ADDR_length;			/*address length*/
+    np_ulong ADDR_offset;			/*address offset*/
+    np_ulong QOS_length;			/*QOS values offset*/
+    np_ulong QOS_offset;			/*QOS values offset*/
+    np_ulong QOS_range_length;		/*length of QOS values' range*/
+    np_ulong QOS_range_offset;		/*offset of QOS values' range*/
+    np_ulong OPTIONS_flags;		/*bit masking for options supported*/
+    np_ulong NIDU_size;			/*network if data unit size*/
+    long SERV_type;			/*service type*/
+    np_ulong CURRENT_state;		/*current state*/
+    np_ulong PROVIDER_type;		/*type of NS provider*/
+}  N_info_ack_t;
+
+
+/*
+ *   Service types supported by NS provider
+ */
+#define N_CONS		1	/*Connection-mode network service supported*/
+#define N_CLNS		2	/*Connection-less network service supported*/
+
+
+/*
+*   Valid provider types
+*/
+#define N_SNICFP	1
+#define N_SUBNET	2
+
+/*
+ *   Bind request
+ */
+
+
+
+typedef struct
+{
+    np_ulong PRIM_type;			/*always N_BIND_REQ*/
+    np_ulong ADDR_length;			/*length of address*/
+    np_ulong ADDR_offset;			/*offset of address*/
+    np_ulong CONIND_number;		/*requested # of connect-*/
+					/*indications to be queued*/
+    np_ulong BIND_flags;			/*bind flags*/
+} N_bind_req_t;
+
+
+/*
+ *  Bind Acknowledgement
+ */
+typedef struct
+{
+    np_ulong PRIM_type;			/* always unbind N_BIND_ACK */
+    np_ulong ADDR_length;			/* address length */
+    np_ulong ADDR_offset;			/* offset of address */
+    np_ulong CONIND_number;		/* connection of indications */
+    np_ulong TOKEN_value;			/* value of token assigned to streams */
+} N_bind_ack_t;
+
+
+/*
+ *	Unbind request
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/* always unbind N_BIND_/REQ */
+} N_unbind_req_t;
+
+
+/*
+ *	Options management request
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/* always N_OPTMGMT_REQ */
+    np_ulong QOS_length;			/* length of QOS parameter values */
+    np_ulong QOS_offset;			/* offset of QOS parameter values */
+    np_ulong OPTMGMT_flags;		/* options management flags */
+} N_optmgmt_req_t;
+
+
+
+
+
+/*
+ *	Error acknowledgement for CONS services
+ */
+typedef struct
+{
+    np_ulong PRIM_type;			/* always N_ERROR_ACK */
+    np_ulong ERROR_prim;			/* primitive in error */
+    np_ulong NPI_error;			/* NP1 error code */
+    np_ulong UNIX_error;			/* UNIX error code */
+} N_error_ack_t;
+
+
+
+/*
+ *	Successful completion acknowledgement
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/* always N_OK_ACK */
+    np_ulong CORRECT_prim;			/* primitive being acknowledged */
+} N_ok_ack_t;
+
+
+
+/*
+ *	CONS PRIMITIVES
+ */
+
+
+/*
+ *	Network connection request
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/* always N_COMM_REQ */
+    np_ulong DEST_length;			/* destination address length */
+    np_ulong DEST_offset;			/* destination address offset */
+    np_ulong CONN_flags;			/* bit masking for options flags */
+    np_ulong QOS_length;			/* length of QOS parameter values */
+    np_ulong QOS_offset;			/* offset of QOS parameter values */
+} N_conn_req_t;
+
+
+/*
+ *	Connection indication
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/* always N_COMM_IND */
+    np_ulong DEST_length;			/* destination address length */
+    np_ulong DEST_offset;			/* destination address offset */
+    np_ulong SRC_length;			/* source address length */
+    np_ulong SRC_offset;			/* source address offset */
+    np_ulong SEQ_number;			/* sequence number */
+    np_ulong CONN_flags;			/* bit masking for options flags */
+    np_ulong QOS_length;			/* length of QOS parameter values */
+    np_ulong QOS_offset;			/* offset of QOS parameter values */
+} N_conn_ind_t;
+
+
+
+/*
+ *	Connection response
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/* always N_CONN_RES */
+    np_ulong TOKEN_value;			/* NC response token value */
+    np_ulong RES_length;			/* responding address length */
+    np_ulong RES_offset;			/* responding address offset */
+    np_ulong SEQ_number;			/* sequence number */
+    np_ulong CONN_flags;			/* bit masking for options flags */
+    np_ulong QOS_length;			/* length of QOS parameter values */
+    np_ulong QOS_offset;			/* offset of QOS parameter values */
+} N_conn_res_t;
+
+
+
+/*
+ *	Connection confirmation
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/* always N_CONN_CON */
+    np_ulong RES_length;			/* responding address length */
+    np_ulong RES_offset;			/* responding address offset */
+    np_ulong CONN_flags;			/* bit masking for options flags */
+    np_ulong QOS_length;			/* length of QOS parameter values */
+    np_ulong QOS_offset;			/* offset of QOS parameter values */
+} N_conn_con_t;
+
+
+
+/*
+ *	Connection mode data transfer request
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/* always N_CONN_CON */
+    np_ulong DATA_xfer_flags;		/* data transfer flags */
+} N_data_req_t;
+
+
+/*
+ *	NPI MORE_DATA_FLAG for segmenting NSDU into more than 1 NIDUs
+ */
+#define N_MORE_DATA_FLAG	0x00000001L  	/*indicates that the next NIDU*/
+						/*is part of this NSDU */
+/*
+ *	NPI Receipt confirmation request set flag
+ */
+#define N_RC_FLAG		0x00000002L	/* indicates if receipt */
+						/* confirmation is required */
+
+
+/*
+ *	Incoming data indication for an NC
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/* always N_DATA_REQ */
+    np_ulong DATA_xfer_flags;		/* data transfer flags */
+} N_data_ind_t;
+
+
+/*
+ *	Data acknowledgement request
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/* always N_DATACK_REQ */
+} N_datack_req_t;
+
+
+/*
+ *	Data acknowledgement indication
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/* always N_DATACK_IND */
+} N_datack_ind_t;
+
+/*
+ *	Expedited data transfer request
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/* always N_EXDATA_REQ */
+} N_exdata_req_t;
+
+
+/*
+ *	Expedited data transfer indication
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/* always N_EXDATA_IND */
+} N_exdata_ind_t;
+
+
+/*
+ *	NC reset request
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/* always N_RESET_REQ */
+    np_ulong RESET_reason;			/* reason for reset */
+} N_reset_req_t;
+
+/*
+ *	NC reset indication
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/* always N_RESET_IND */
+    np_ulong RESET_orig;			/* reset originator */
+    np_ulong RESET_reason;			/* reason for reset */
+} N_reset_ind_t;
+
+/*
+ *	NC reset response
+ */
+typedef struct
+{
+    np_ulong PRIM_type;			/* always N_RESET_RES */
+} N_reset_res_t;
+
+
+/*
+ *	NC reset confirmed
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/* always N_RESET_CON */
+} N_reset_con_t;
+
+
+/*
+ *	NC disconnection request
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/* always N_DISCON_REQ */
+    np_ulong DISCON_reason;		/* reason */
+    np_ulong RES_length;			/* responding address length */
+    np_ulong RES_offset;			/* responding address offset */
+    np_ulong SEQ_number;			/* sequence number */
+} N_discon_req_t;
+
+
+/*
+ *	NC disconnection indication
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;			/*  */
+    np_ulong DISCON_orig;			/*  */
+    np_ulong DISCON_reason;		/*  */
+    np_ulong RES_length;			/*  */
+    np_ulong RES_offset;			/*  */
+    np_ulong SEQ_number;
+} N_discon_ind_t;
+
+
+
+/*
+ *	CLNS PRIMITIVES
+ */
+
+/*
+*	Unitdata transfer request
+*/
+
+typedef struct
+{
+    np_ulong PRIM_type;		/* always N_UNITDATA_REQ */
+    np_ulong DEST_length;		/* destination address length */
+    np_ulong DEST_offset;		/* destination address offset */
+    np_ulong RESERVED_field[2];	/* reserved field for DLPI compatibility */
+} N_unitdata_req_t;
+
+
+/*
+ *	Unitdata transfer indication
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;		/* always N_UNITDATA_IND */
+    np_ulong DEST_length;		/* source address length */
+    np_ulong DEST_offset;		/* source address offset */
+    np_ulong SRC_length;		/* source address length */
+    np_ulong SRC_offset;		/* source address offset  */
+    np_ulong RESERVED_field;	/* reserved field for DLPI compatibility */
+} N_unitdata_ind_t;
+
+
+/*
+ *	Unidata error indication for CLNS services
+ */
+
+typedef struct
+{
+    np_ulong PRIM_type;		/* always N_UDERROR_IND */
+    np_ulong DEST_length;		/* destination address length */
+    np_ulong DEST_offset;		/* destination address offset */
+    np_ulong RESERVED_field;	/* reserved field for DLPI compatibility */
+    np_ulong ERROR_type;		/* error type */
+} N_uderror_ind_t;
+
+
+
+
+/*
+ *The following represents a union of all the NPI primitives
+ */
+
+union N_primitives
+{
+    np_ulong		type;
+    N_info_req_t	info_req;	/* information request */
+    N_info_ack_t	info_ack;	/* information acknowledgement */
+    N_bind_req_t	bind_req;	/* bind request */
+    N_bind_ack_t	bind_ack;	/* bind acknowledgement */
+    N_unbind_req_t	unbind_req;	/* unbind acknowledgement */
+    N_optmgmt_req_t	optmgmt_req;	/* options management request */
+    N_error_ack_t	error_ack;	/* error acknowledgement */
+    N_uderror_ind_t 	uderror_ind;	/* unitdata error indication */
+    N_ok_ack_t		ok_ack;		/* ok acknowledgement */
+    N_conn_req_t	conn_req;	/* connect request */
+    N_conn_ind_t	conn_ind;	/* connect indication */
+    N_conn_res_t	conn_res;	/* connect response */
+    N_conn_con_t	conn_con;	/* connect confirm */
+    N_data_req_t	data_req;	/* data request */
+    N_data_ind_t	data_ind;	/* data indictation */
+    N_datack_req_t	datack_req;	/* data acknowledgement request */
+    N_datack_ind_t	datack_ind;	/* data acknowledgement indication */
+    N_exdata_req_t	exdata_req;	/* expedited data request */
+    N_exdata_ind_t	exdata_ind;	/* expedited data indication */
+    N_reset_req_t	reset_req;	/* reset request */
+    N_reset_ind_t	reset_ind;	/* reset indication */
+    N_reset_res_t	reset_res;	/* reset response */
+    N_reset_con_t	reset_con;	/* reset confirm */
+    N_discon_req_t	discon_req;	/* disconnect request */
+    N_discon_ind_t	discon_ind;	/* disconnect indication */
+    N_unitdata_req_t	unitdata_req;	/* unitdata request */
+    N_unitdata_ind_t	unitdata_ind;	/* unitdata indication */
+};
+
+
+#endif					/* from top of file */
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/poll.h /usr/src/linux/drivers/streams/LiS/include/sys/poll.h
--- debug/drivers/streams/LiS/include/sys/poll.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/poll.h	Mon Dec 16 16:36:40 1996
@@ -0,0 +1,107 @@
+/*                               -*- Mode: C -*- 
+ * <strpoll> --- poll
+ * Author          : gram & nemo
+ * Created On      : Mon Oct 17 11:37:12 1994
+ * RCS Id          ; $Id: poll.h,v 1.3 1996/01/27 00:40:00 dave Exp $
+ * Last Modified By: Francisco J. Ballesteros
+ * Last Modified On: Tue Sep 26 15:40:02 1995
+ * Update Count    : 6
+ * Status          : Unknown, Use with caution!
+ * Prefix(es)      : 
+ * Requirements    :
+ * Purpose         :
+ *                 :
+ *    Copyright (C) 1995  Graham Wheeler, Francisco J. Ballesteros
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    gram@aztec.co.za, nemo@ordago.uc3m.es
+ */
+
+#ifndef _SYS_POLL_H
+#define	_SYS_POLL_H
+
+/*  -------------------------------------------------------------------  */
+#ifndef _POLL_H
+#include <sys/LiS/poll.h>	/* streams module symbols & types */
+#endif
+
+
+/*  -------------------------------------------------------------------  */
+/*
+ * Structure of file descriptor/event pairs supplied in
+ * the poll arrays.
+ *
+ * Magic Garden calls this "struct pollfd", AT&T STREAMS Programers Guide
+ * calls it "struct poll".
+ */
+typedef struct poll {
+	int fd;				/* file desc to poll */
+	short events;			/* events of interest on fd */
+	short revents;			/* events that occurred on fd */
+} pollfd_t;
+
+/* KLUDGE ATTACK FROM MIKEL */
+struct pollfd {
+	int fd;				/* file desc to poll */
+	short events;			/* events of interest on fd */
+	short revents;			/* events that occurred on fd */
+} ;
+/* KLUDGE ATTACK FROM MIKEL */
+/*
+ * Testable select events
+ */
+#define	POLLIN		0x0001		/* fd is readable */
+#define	POLLPRI		0x0002		/* high priority info at fd */
+#define	POLLOUT		0x0004		/* fd is writeable (won't block) */
+#define	POLLRDNORM	0x0040		/* normal data is readable */
+#define	POLLWRNORM	POLLOUT
+#define	POLLRDBAND	0x0080		/* out-of-band data is readable */
+#define	POLLWRBAND	0x0100		/* out-of-band data is writeable */
+#define	POLLMSG		0x0200		/* M_SIG at head of queue */
+
+#define	POLLNORM	POLLRDNORM
+
+/*
+ * Non-testable poll events (may not be specified in events field,
+ * but may be returned in revents field).
+ */
+#define	POLLERR		0x0008		/* fd has error condition */
+#define	POLLHUP		0x0010		/* fd has been hung up on */
+#define	POLLNVAL	0x0020		/* invalid pollfd entry */
+
+
+#ifndef poll
+
+# ifdef LINUX
+
+#  ifndef _LINUX_UNISTD_H
+#  include <linux/unistd.h>
+#  endif
+
+static inline _syscall3(int,poll,void *,pollbuf,long,n,int,timout)
+
+# else
+
+extern int poll(pollfd_t *fds, unsigned long nfds, int timeout);
+
+# endif
+
+#endif
+
+/*  -------------------------------------------------------------------  */
+
+#endif	/* _SYS_POLL_H */
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/sockio.h /usr/src/linux/drivers/streams/LiS/include/sys/sockio.h
--- debug/drivers/streams/LiS/include/sys/sockio.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/sockio.h	Mon Dec 16 16:36:40 1996
@@ -0,0 +1,24 @@
+/* 
+ * SVR4 style ifstats.  Needed for source code compatibility with
+ * SVR4 drivers that want this structure.
+ */
+#ifndef IFSTATS_DEFINED
+
+#define IFSTATS_DEFINED                 /* for other include files */
+
+struct ifstats 
+{
+    long	 ifs_ipackets ;
+    long	 ifs_opackets ;
+    long	 ifs_oerrors ;
+    long	 ifs_ierrors ;
+    void	*ifs_addrs ;
+    void	*ifs_next ;
+    long	 ifs_mtu ;
+    char	*ifs_name;
+    short	 ifs_unit;
+    short	 ifs_active;
+    int		 ifs_collisions;
+} ;
+
+#endif
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/strconfig.h /usr/src/linux/drivers/streams/LiS/include/sys/strconfig.h
--- debug/drivers/streams/LiS/include/sys/strconfig.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/strconfig.h	Wed Jan  1 13:04:40 1997
@@ -0,0 +1,126 @@
+/*                               -*- Mode: C -*- 
+ * strconfig.h --- configuration symbols for LiS
+ * Author          : Francisco J. Ballesteros
+ * Created On      : Tue May 31 21:40:37 1994
+ * Last Modified By: David Grothe
+ * RCS Id          : $Id: strconfig.h,v 1.3 1996/01/07 20:48:32 dave Exp $
+ * Purpose         : just document symbols
+ * ----------------______________________________________________
+ *    Copyright (C) 1995  Graham Wheeler, Francisco J. Ballesteros
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    gram@aztec.co.za, nemo@ordago.uc3m.es
+ */
+
+
+#ifndef _LIS_CONFIG_H
+#define _LIS_CONFIG_H 1
+
+/*  -------------------------------------------------------------------  */
+/*				 Dependencies                            */
+
+#ifdef LINUX
+#include <linux/major.h>		/* for MAX_CHRDEV */
+#else
+#define	MAX_CHRDEV	256
+#endif
+
+
+/*  -------------------------------------------------------------------  */
+/*				   Symbols                               */
+
+
+
+/* this is to use safe version of streams api, to get nice warnings and so
+ * on...
+ */
+#ifdef LIS_CONFIG_SAFE
+#define SAFE 1
+#endif
+
+/* This is to use a test version
+ */
+#if defined(LIS_TESTING) || defined(LIS_DEBUG)
+#define TEST 1
+
+#endif
+
+/*  -------------------------------------------------------------------  */
+/* This is only for documentation purposes
+ */
+
+#define SHARE          /* you can RW */
+#define EXPORT         /* you can R */
+#define PRIVATE        /* you can't */
+
+/*  -------------------------------------------------------------------  */
+/*		       Global tunable vars. and symbols                  */
+
+/*
+ * Maximum number of mblk headers to keep on hand for fast allocation
+ */
+#define	MAX_MBLKS	10
+
+
+/* From mod.h:
+ * (we've been using a char for the module id, so if the # of modules
+ * get's over 255 we should define  mid_t and use this.
+ */
+#define FMNAMESZ        16	/* Max module name size */
+
+#define MAX_STRDEV	MAX_CHRDEV /*Max # of stream devices */
+#define MAX_STRMOD	MAX_CHRDEV /* Max # of stream modules */
+#define MAX_STRAMOD	8	/* max # of autopushed mods per str */
+#define MAX_APUSH       8	/* max # of autopushed mods */
+#ifdef __KERNEL__
+extern int lis_reuse_modsw;	/* we reuse modsw entries if this is true */
+#endif				/* __KERNEL__ */
+
+
+/* From queue.h:
+ */
+#define NBAND   256		/* Max # of bands. Keep below 256 */
+
+/* From stream.c: 
+ */
+#define LIS_CLTIME   15000	/* # of milli-secs. to wait on close */
+#define LIS_RTIME    1		/* # of secs. to wait to fwd held msg */
+#define LIS_MAXPSZ   4096	/* max. packet size (must be non-zero) */
+#define LIS_MINPSZ   0		/* min. packet size */
+
+#define LIS_MEMLIMIT	(1*1024*1024) /*  STREAMS memory limit */
+
+#ifdef __KERNEL__
+extern unsigned long lis_strthresh;	/* configurable STREAMS memory limit */
+extern int lis_nstrpush;	/* maximum # of pushed modules */
+extern int lis_strhold;		/* if not zero str hold feature's activated*/
+#endif				/* __KERNEL__ */
+
+/* From msg.h:
+ */
+#ifdef __KERNEL__
+extern int lis_strmsgsz;		/* maximum stream message size */
+#endif				/* __KERNEL__ */
+
+
+#endif /*!_LIS_CONFIG_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/stream.h /usr/src/linux/drivers/streams/LiS/include/sys/stream.h
--- debug/drivers/streams/LiS/include/sys/stream.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/stream.h	Wed Jan  1 13:04:40 1997
@@ -0,0 +1,288 @@
+/*                               -*- Mode: C -*- 
+ * <stream.h> --- Linux STREAMS common declarations. 
+ * Author          : gram & nemo
+ * Created On      : Mon Oct 17 11:37:12 1994
+ * RCS Id          ; $Id: stream.h,v 1.8 1996/01/27 00:40:01 dave Exp $
+ * Last Modified By: David Grothe
+ * Restrictions    : SHAREd items can be read/writen by usr
+ *                 : EXPORTed items can only be read by usr
+ *                 : PRIVATEd items cannot be read nor writen
+ * Purpose         : provide basic Streams types and declarations
+ *                 : for the modules/drivers developers.
+ *
+ *    Copyright (C) 1995  Graham Wheeler, Francisco J. Ballesteros
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    gram@aztec.co.za, nemo@ordago.uc3m.es
+ */
+
+#ifndef _STREAM_H
+#define _STREAM_H
+#define  STREAM_H
+
+/*
+ * Always use the safe routines.  A driver writer can make
+ * a simple mistake and easily panic the kernel anyway, so why
+ * make it even easier?  -- DMG
+ */
+#ifndef SAFE
+#define	SAFE		1
+#endif
+
+/*
+ * I heartily recommend using this feature.  It allows you to know
+ * who allocated pieces of memory used by streams.  It makes it
+ * particularly easy to track down lost streams buffers.
+ */
+#ifndef MSG_TRACE
+#define	MSG_TRACE	1
+#endif
+
+/*  -------------------------------------------------------------------  */
+/*                               Dependencies                            */
+
+/* This are std defines to allow you to include only `stream.h' and run
+ * miles w/o including nothing else from LiS. */
+
+/* plain usr API */
+#ifndef _STRPORT_H
+#include <sys/strport.h>	/* poring structures */
+#endif
+
+#ifndef _LIS_CONFIG_H
+#include <sys/strconfig.h>	/* streams config symbols are here */
+#endif
+#ifndef _STR_MSG_H
+#include <sys/strmsg.h>		/* streams msgs */
+#endif
+#ifndef _STR_OPTS_H
+#include <sys/stropts.h>	/* streams operations */
+#endif
+#ifndef	DKI_H
+#include <sys/dki.h>		/* SVR4 compatible prototypes */
+#endif
+#ifndef	_DDI_H
+#include <sys/ddi.h>		/* SVR4 compatible prototypes */
+#endif
+
+/*include everything exported to usr-level from LiS internal modules */
+
+#ifndef _SHARE_H
+#include <sys/LiS/share.h>	/* some generic stuff */
+#endif
+#ifndef _MSG_H
+#include <sys/LiS/msg.h>	/* streams msgs management */
+#endif
+#ifndef _MSGUTL_H
+#include <sys/LiS/msgutl.h>	/* streams msg utilities  */
+#endif
+#ifndef _MOD_H
+#include <sys/LiS/mod.h>	/* streams modules */
+#endif
+#ifndef _QUEUE_H
+#include <sys/LiS/queue.h>	/* streams queue symbols & types */
+#endif
+#ifndef _BUFFCALL_H
+#include <sys/LiS/buffcall.h>	/* buffcalls & mem stuff */
+#endif
+#ifndef _EVENTS_H
+#include <sys/LiS/events.h>	/* streams events */
+#endif
+#ifndef _STATS_H
+#include <sys/LiS/stats.h>	/* streams statistics */
+#endif
+#ifndef _HEAD_H
+#include <sys/LiS/head.h>	/* streams statistics */
+#endif
+#ifndef _WAIT_H
+#include <sys/LiS/wait.h>	/* timers,waits,... */
+#endif
+#ifndef	_STRMDBG_H
+#include <sys/LiS/strmdbg.h>	/* debugging stuff */
+#endif
+
+
+
+/*  -------------------------------------------------------------------  */
+/*                               Entry points                            */
+
+/* This are just definitions to the appropriate functions exported
+ * from any of the <sys/LiS/...> stuff
+ * We shouldn't have exported symbols starting w/ other than `lis' to
+ * avoid kernel namespace pollution. 
+ */
+
+
+/* get ptr to the queue behind q. That queue with q_next == q.
+ * returns NULL if no such queue
+ */
+#ifdef __KERNEL__
+#define backq(q)	lis_backq(q)
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+
+/* test for flow cntl in band
+ * returns STR_OK if msg can be put(), STR_ERR (0) if not.
+ */
+#ifdef __KERNEL__
+#define bcanput(q,b)	lis_bcanput((q),(b))
+#define bcanputnext(q,b) lis_bcanput((q)->q_next,(b))
+#define canput(q)       bcanput((q),0)
+#define canputnext(q)   bcanput((q)->q_next,0)
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+#ifdef __KERNEL__
+#define  noenable(q)    lis_noenable(q)   
+#define  enableok(q)    lis_enableok(q)   
+#define  canenable(q)   lis_canenable(q)  
+#define  putnext(q, mp) lis_putnext(q, mp)
+#define  qreply(q, mp)  lis_qreply(q, mp) 
+#define	 OTHERQ(q)      LIS_OTHERQ(q)     
+#define	 RD(q)          LIS_RD(q)         
+#define	 WR(q)          LIS_WR(q)         
+#define  SAMESTR(q)     LIS_SAMESTR(q)    
+#define	 strqset	lis_strqset
+#define	 strqget	lis_strqget
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+
+#ifdef __KERNEL__
+
+/*Remove a msg block (2nd arg) from the msg */
+#define rmvb(m,b)	lis_rmvb(m,b)
+
+/* Allocate a message */
+#define allocb(s1,s2)	lis_allocb(s1,s2,"mblk " __FILE__,__LINE__)
+#define esballoc(b,s,p,f) lis_esballoc(b,s,p,f,"mblk " __FILE__,__LINE__)
+
+/* Check if a message can be allocated */
+#define testb(s1,s2)	lis_testb(s1,s2)
+
+/* Free a message block */
+#define freeb(b)	lis_freeb(b)
+
+/* Free a message list */
+#define freemsg(m)	lis_freemsg(m)
+
+/* Duplicate a message block */
+#define dupb(b)		lis_dupb(b)
+
+/* Duplicate a message */
+#define dupmsg(m)	lis_dupmsg(m)
+
+/* Copy a message block */
+#define copyb(b)	lis_copyb(b)
+
+/* Copy a message */
+#define copymsg(m)	lis_copymsg(m)
+
+/* Link message blocks */
+#define linkb(b)	lis_linkb(b)
+
+/* Unlink first block */
+#define unlinkb(m)	lis_unlinkb(m)
+
+/* Pull up the first N bytes */
+#define pullupmsg(m,s)	lis_pullupmsg(m,s)
+
+/* Trim first/last(N<0) bytes */
+#define adjmsg(m,s)	lis_adjmsg(m,s)
+
+/* # data bytes */
+#define msgdsize(m)	lis_msgdsize(m)
+
+/* # bytes of first msg block type */
+#define xmsgsize(b)	lis_xmsgsize(b)
+
+/* # bytes in all blocks */
+#define msgsize(m)	lis_msgsize(m)
+
+/* Remove first msg from queue */
+#define getq(q)	lis_getq(q)
+
+/* Remove this msg from queue */
+#define rmvq(q,m)	lis_rmvq(q,m)
+
+/* Flush messages */
+#define flushq(q,s)	lis_flushq(q,s)
+
+/* Append message to queue */
+#define putq(q,m)	lis_putq(q,m)
+
+/* Put message back onto queue */
+#define putbq(q,m)	lis_putbq(q,m)
+
+/* Insert message(3) before message(2) or at end */
+#define insq(q,m1,m2)	lis_insq(q,m1,m2)
+
+/* Zero-byte ctl msg */
+#define putctl(q,i)	lis_putctl(q,i)
+
+/* One-byte ctl msg */
+#define putctl1(q,i1,i2)	lis_putctl1(q,i1,i2)
+
+
+
+/* Schedule a service procedure */
+#define qenable(q)	lis_qenable(q)
+
+
+/* recover from allocb failure: call this when allocb() rets NULL
+ * func will be called asap when a buffer for size bytes is available.
+ * arg is the argument given to func
+ * Returns STR_OK if ok and STR_ERR if couldn't install func.
+ */
+#define bufcall 	 lis_bufcall
+#define esbbcall	 lis_esbbcall
+#define unbufcall	 lis_unbufcall
+
+/* Check is msg is a data msg
+ */
+#define datamsg(type)	lis_datamsg(type)
+#define isdatamsg(mp)   lis_isdatamsg(mp)
+#define isdatablk(mb)   lis_isdatablk(mb)
+
+#endif				/* __KERNEL__ */
+
+/*  -------------------------------------------------------------------  */
+
+
+extern int
+lis_sysputpmsg(struct inode *, struct file *, char *, char *, int, int);
+extern int
+lis_sysgetpmsg(struct inode *, struct file *, char *, char *, int *, int *);
+
+#ifdef __KERNEL__
+extern int lis_init_stream_subsystem(int memlimit);
+void lis_scantmout_handler(unsigned long arg);
+void lis_runqueues(void) ;
+#endif /* __KERNEL_ */
+
+/*  -------------------------------------------------------------------  */
+
+
+#endif /*!_STREAM_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/strmsg.h /usr/src/linux/drivers/streams/LiS/include/sys/strmsg.h
--- debug/drivers/streams/LiS/include/sys/strmsg.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/strmsg.h	Wed Jan  1 13:04:41 1997
@@ -0,0 +1,262 @@
+/*                               -*- Mode: C -*- 
+ * <strmsg.h> --- Linux STREAMS message types
+ * Author          : gram & nemo
+ * Created On      : Mon Oct 17 11:37:12 1994
+ * RCS Id          ; $Id: strmsg.h,v 1.2 1996/01/27 00:40:02 dave Exp $
+ * Last Modified By: David Grothe
+ * Purpose         : Provide Streams message types
+ *                 :
+ *
+ *    Copyright (C) 1995  Graham Wheeler, Francisco J. Ballesteros
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    gram@aztec.co.za, nemo@ordago.uc3m.es
+
+ */
+
+#ifndef _STR_MSG_H
+#define _STR_MSG_H 1
+/*  *******************************************************************  */
+/*                               Dependencies                            */
+
+#ifndef _LIS_CONFIG_H
+#include <sys/strconfig.h>	/* streams config symbols are here */
+#endif
+#ifndef _MSG_H
+#include <sys/LiS/msg.h>	/* streams msg symbols & types */
+#endif
+#ifndef _MSGUTL_H
+#include <sys/LiS/msgutl.h>	/* streams msg utilities  */
+#endif
+#ifndef _QUEUE_H
+#include <sys/LiS/queue.h>	/* streams queue symbols & types */
+#endif
+#ifndef _MOD_H
+#include <sys/LiS/mod.h>	/* streams module symbols & types */
+#endif
+
+/*  *******************************************************************  */
+/*                                 Symbols                               */
+
+/*  -------------------------------------------------------------------  */
+/* STREAMS normal priority message types
+ */
+
+#define QNORM		0
+
+#define M_DATA		0
+#define M_PROTO		1
+#define M_BREAK		2
+#define M_CTL		3
+#define M_DELAY		4
+#define M_IOCTL		5
+#define M_PASSFP	6
+#define M_RSE		7
+#define M_SETOPTS	8
+#define M_SIG		9
+
+/*  -------------------------------------------------------------------  */
+/* STREAMS high priority message types
+ */
+
+#define QPCTL		10
+
+#define M_COPYIN	(QPCTL+0)
+#define M_COPYOUT	(QPCTL+1)
+#define M_ERROR		(QPCTL+2)
+#define M_FLUSH		(QPCTL+3)
+#define M_HANGUP	(QPCTL+4)
+#define M_IOCACK	(QPCTL+5)
+#define M_IOCNAK	(QPCTL+6)
+#define M_IOCDATA	(QPCTL+7)
+#define M_PCPROTO	(QPCTL+8)
+#define M_PCRSE		(QPCTL+9)
+#define M_PCSIG		(QPCTL+10)
+#define M_READ		(QPCTL+11)
+#define M_STOP		(QPCTL+12)
+#define M_START		(QPCTL+13)
+#define M_STARTI	(QPCTL+14)
+#define M_STOPI		(QPCTL+15)
+
+
+/*  -------------------------------------------------------------------  */
+/*
+ * Flag for transparent ioctls (actually every ioctl will be transparent:)
+ */
+#define TRANSPARENT     (unsigned int)(-1)
+
+/*  *******************************************************************  */
+
+/* Max ioctl block size
+ */
+#define MAXIOCBSZ       1024
+
+/*  *******************************************************************  */
+/* cpyblk_t (copyrec,M_COPYIN,M_COPYOUT) flags
+ */
+#define STRCANON        0x01            /* b_cont data block contains */
+                                        /* canonical format specifier */
+#define RECOPY          0x02            /* perform I_STR copyin again, */
+                                        /* this time using canonical */
+                                        /* format specifier */
+
+/*  *******************************************************************  */
+
+/* flags for  stroptions (M_SETOPTS)  message 
+ */
+#define SO_ALL          0xffff  /* set all old options */
+#define SO_READOPT      0x0001  /* set read option */
+#define SO_WROFF        0x0002  /* set write offset */
+#define SO_MINPSZ       0x0004  /* set min packet size */
+#define SO_MAXPSZ       0x0008  /* set max packet size */
+#define SO_HIWAT        0x0010  /* set high water mark */
+#define SO_LOWAT        0x0020  /* set low water mark */
+#define SO_MREADON      0x0040  /* set read notification ON */
+#define SO_MREADOFF     0x0080  /* set read notification OFF */
+#define SO_NDELON       0x0100  /* old TTY semantics for NDELAY reads/writes */
+#define SO_NDELOFF      0x0200  /* STREAMS semantics for NDELAY reads/writes */
+#define SO_ISTTY        0x0400  /* the stream is acting as a terminal */
+#define SO_ISNTTY       0x0800  /* the stream is not acting as a terminal */
+#define SO_TOSTOP       0x1000  /* stop on background writes to this stream */
+#define SO_TONSTOP      0x2000  /* do not stop on background writes to stream*/
+#define SO_BAND         0x4000  /* water marks affect band */
+#define SO_DELIM        0x8000  /* messages are delimited */
+#define SO_NODELIM      0x010000 /* turn off delimiters */
+#define SO_STRHOLD      0x020000 /* enable strwrite message coalescing */
+
+
+/*  *******************************************************************  */
+/*                                  Types                                */
+
+typedef unsigned long str_ulong;
+typedef unsigned short str_ushort;
+
+/*  *******************************************************************  */
+
+
+/* M_IOCTL message type.
+ */
+
+typedef
+struct iocblk {
+  SHARE
+        int     ioc_cmd;        /* ioctl command type */
+        uid_t ioc_uid;        /* usr id */
+        gid_t ioc_gid;        /* grp id */
+        u_int	ioc_id;        /* ioctl id */
+        u_int	ioc_count;     /* count of bytes in data field */
+        int     ioc_error;      /* error code */
+        int     ioc_rval;       /* return value  */
+} iocblk_t;
+
+/*  *******************************************************************  */
+
+/*  Sent to mux drivers to indicate a link.
+ */
+typedef
+struct linkblk {
+  EXPORT
+        struct queue *l_qtop;   /* lowest level write queue of upper stream */
+                                /* (set to NULL for persistent links) */
+        struct queue *l_qbot;   /* highest level write queue of lower stream */
+        int     l_index;        /* index for lower stream. */
+} linkblk_t;
+
+/*  *******************************************************************  */
+
+/*  M_COPYIN and M_COPYOUT message types.
+ */
+
+typedef 
+struct copyreq {
+  SHARE
+        int     cq_cmd;                 /* ioctl command (from ioc_cmd) */
+        o_uid_t cq_uid;                 /* usr id */
+        o_gid_t cq_gid;                 /* grp id */
+        uint    cq_id;                  /* ioctl id (from ioc_id) */
+        caddr_t cq_addr;                /* address to copy data to/from */
+        uint    cq_size;                /* number of bytes to copy */
+        int     cq_flag;                /* see above */
+        mblk_t *cq_private;             /* private state information */
+} copyreq_t;
+
+/*  *******************************************************************  */
+
+/* M_IOCDATA message type.
+ */
+typedef
+struct copyresp {
+  SHARE
+        int     cp_cmd;                 /* ioctl command (from ioc_cmd) */
+        o_uid_t cp_uid;                 /* usr id */
+        o_gid_t cp_gid;                 /* grp id */
+        uint    cp_id;                  /* ioctl id (from ioc_id) */
+        caddr_t cp_rval;                /* status of request: 0 -> success */
+                                        /*              non-zero -> failure */
+        mblk_t *cp_private;             /* private state information */
+} copyresp_t;
+
+
+
+/*  *******************************************************************  */
+
+/* M_SETOPTS message.  This is sent upstream
+ * by a module or driver to set stream head options.
+ */
+typedef
+struct stroptions {
+  SHARE
+        str_ulong   so_flags;               /* options to set */
+        short   so_readopt;             /* read option */
+        str_ushort  so_wroff;               /* write offset */
+        long    so_minpsz;              /* minimum read packet size */
+        long    so_maxpsz;              /* maximum read packet size */
+        str_ulong   so_hiwat;               /* read queue high water mark */
+        str_ulong   so_lowat;               /* read queue low water mark */
+        unsigned char so_band;          /* band for water marks */
+} stroptions_t;
+
+/*  *******************************************************************  */
+
+/* The structure for M_EVENT & M_PCEVENT is not defined. I think we are
+ * not going to support such things as a general event subsytem, etc.:
+ *
+ * The structure for M_EVENT and M_PCEVENT messages is sent upstream
+ * by a module or driver to have the stream head manage an event
+ * It is also contained in the first M_DATA
+ * block of an M_IOCTL message for the I_STREV and I_UNSTREV ioctls.
+ *
+ * struct str_evmsg { ... };
+ */
+
+
+/*  -------------------------------------------------------------------  */
+
+
+/* Is this msg type a high priority one?
+ */
+#define lis_hipri(t)	((t)>=QPCTL)
+
+/*  *******************************************************************  */
+#endif /*!_STR_MSG_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
+
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/stropts.h /usr/src/linux/drivers/streams/LiS/include/sys/stropts.h
--- debug/drivers/streams/LiS/include/sys/stropts.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/stropts.h	Wed Jan  1 13:04:41 1997
@@ -0,0 +1,370 @@
+/*                               -*- Mode: C -*- 
+ * <stropts> --- STREAMS ops.
+ * Author          : gram & nemo
+ * Created On      : Mon Oct 17 11:37:12 1994
+ * RCS Id          ; $Id: stropts.h,v 1.4 1996/01/29 17:36:02 dave Exp $
+ * Last Modified By: David Grothe
+ *                 :
+ *    Copyright (C) 1995  Graham Wheeler, Francisco J. Ballesteros
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    gram@aztec.co.za, nemo@ordago.uc3m.es
+ */
+
+#ifndef _STR_OPTS_H
+#define _STR_OPTS_H
+
+/*  *******************************************************************  */
+/*                               Dependencies                            */
+
+#ifndef _SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifndef _LIS_CONFIG_H
+#include <sys/strconfig.h>
+#endif
+
+
+/*  *******************************************************************  */
+/*                                 Symbols                               */
+
+/*
+ *  timeout for enernity
+ */
+
+#define INFTIM          -1
+
+/*  *******************************************************************  */
+
+/*
+ * Write opts.
+ */
+
+#define SNDZERO         0x001           /* send a zero length message */
+#define SNDPIPE         0x002           /* send SIGPIPE on write and */
+                                        /* putmsg if sd_werror is set */
+
+/*
+ *  Read opts that can be defined with SO_READOPT (so_readopt values)
+ */
+
+#define RNORM           0x0000  /* byte stream */
+#define RMSGD           0x0001  /* message discard */
+#define RMSGN           0x0002  /* message non-discard */
+
+#define RMODEMASK       0x0003  /* RMODE bits */
+
+/* As Solaris' guys say:
+ * "These next three read options are added for the sake of
+ * user-level transparency.  RPROTDAT will cause the stream head
+ * to treat the contents of M_PROTO and M_PCPROTO message blocks
+ * as data.  RPROTDIS will prevent the stream head from failing
+ * a read with EBADMSG if an M_PROTO or M_PCPROTO message is on
+ * the front of the stream head read queue.  Rather, the protocol
+ * blocks will be silently discarded and the data associated with
+ * the message (in linked M_DATA blocks), if any, will be delivered
+ * to the user.  RPROTNORM sets the default behavior, where read
+ * will fail with EBADMSG if an M_PROTO or M_PCPROTO are at the
+ * stream head."
+ *
+ * For compatibility, we use the same bits as SVR4.
+ */
+
+#define RPROTDAT        0x0004  /* turn M*PROTO into M_DATA */
+#define RPROTDIS        0x0008  /* discard M*PROTO */
+#define RPROTNORM       0x0010  /* normal proto */
+
+#define RPROTMASK       0x001C  /* RPROT bits */
+
+/*  *******************************************************************  */
+
+/*
+ *  flags for M_FLUSH
+ */
+
+#define FLUSHR          0x01    /* flush read side */
+#define FLUSHW          0x02    /* flush write side */
+#define FLUSHRW         0x03    /* flush both read & write sides */
+#define FLUSHBAND       0x10    /* flush msg for band priority */
+
+/*  *******************************************************************  */
+
+/*
+ *  events for SIGPOLL to be sent
+ */
+
+#define S_INPUT         0x0001          /* any msg but hipri on read Q */
+#define S_HIPRI         0x0002          /* high priority msg on read Q */
+#define S_OUTPUT        0x0004          /* write Q no longer full */
+#define S_MSG           0x0008          /* signal msg at front of read Q */
+#define S_ERROR         0x0010          /* error msg arrived at stream head */
+#define S_HANGUP        0x0020          /* hangup msg arrived at stream head */
+#define S_RDNORM        0x0040          /* normal msg on read Q */
+#define S_WRNORM        S_OUTPUT
+#define S_RDBAND        0x0080          /* out of band msg on read Q */
+#define S_WRBAND        0x0100          /* can write out of band */
+#define S_BANDURG       0x0200          /* modifier to S_RDBAND, to generate */
+                                        /* SIGURG instead of SIGPOLL */
+#define S_ALL		0x03FF		/* every event */
+
+/*  *******************************************************************  */
+
+/*
+ * Stream buffer structure for putpmsg and getpmsg system calls
+ */
+
+typedef
+struct strbuf {
+    int     maxlen;                 /* no. of bytes in buffer */
+    int     len;                    /* no. of bytes returned */
+    char    *buf;                   /* pointer to data */
+} strbuf_t;
+
+/*  *******************************************************************  */
+
+/*
+ * User level routines for getmsg/putmsg
+ */
+#ifdef LINUX
+
+# ifndef _LINUX_UNISTD_H
+# include <linux/unistd.h>
+# endif
+
+static inline _syscall5(int,putpmsg,int,fd,
+			void *,ctlptr,void *,dataptr,int,band,int,flags)
+static inline _syscall5(int,getpmsg,int,fd,
+			void *,ctlptr,void *,dataptr,int *,bandp,int *,flagsp)
+
+#else
+
+int	putpmsg(int fd, struct strbuf *ctlptr,
+			struct strbuf *dataptr,
+			int band,
+			int flags) ;
+int	getpmsg(int fd, struct strbuf *ctlptr,
+			struct strbuf *dataptr,
+			int *bandp,
+			int *flagsp) ;
+
+#endif
+
+#define	putmsg(f,c,d,g)	putpmsg(f,c,d,-1,g)
+#define	getmsg(f,c,d,g)	getpmsg(f,c,d,NULL,g)
+
+#ifdef QNX
+#ifndef GCOM_OPEN
+#define open gcom_open
+#endif
+extern int gcom_open( const char *__path, int __oflag, ... );
+#endif
+/*
+ * Flags for getmsg() and putmsg() syscall arguments.
+ * A value of zero will cause getmsg() to return
+ * the first message on the stream head read queue and putpmsg() to send
+ * a normal priority message.
+ */
+#define RS_HIPRI        0x01    /* high priority message */
+#define RS_NORM         0x00    /* normal message */
+
+/*  *******************************************************************  */
+
+/* Flags for getpmsg() and putpmsg() syscall arguments.
+ * These are settable by the user and will be set on return
+ * to indicate the priority of message received.
+ */
+#define MSG_HIPRI       0x01            /* send/recv high priority message */
+#define MSG_ANY         0x02            /* recv any messages */
+#define MSG_BAND        0x04            /* recv messages from specified band */
+
+/*  *******************************************************************  */
+
+/* Flags returned as value of getmsg() and getpmsg() syscall.
+ */
+#define MORECTL         1               /* more ctl info is left in message */
+#define MOREDATA        2               /* more data is left in message */
+
+
+/*  *******************************************************************  */
+
+/*
+ * Define to indicate that all multiplexors beneath a stream should
+ * be unlinked.
+ */
+
+#define MUXID_ALL       (-1)
+
+/*  *******************************************************************  */
+
+/*
+ *  Flag definitions for the I_ATMARK ioctl.
+ */
+
+#define ANYMARK         0x01
+#define LASTMARK        0x02
+
+/*  *******************************************************************  */
+
+/*
+ *   STREAMS Ioctls
+ */
+
+#define STRIOC          ('S'<<8)
+#define STR		STRIOC
+#define I_NREAD         (STRIOC | 1)
+#define I_PUSH          (STRIOC | 2)
+#define I_POP           (STRIOC | 3)
+#define I_LOOK          (STRIOC | 4)
+#define I_FLUSH         (STRIOC | 5)
+#define I_SRDOPT        (STRIOC | 6)
+#define I_GRDOPT        (STRIOC | 7)
+#define I_STR           (STRIOC | 8)
+#define I_SETSIG        (STRIOC | 9)
+#define I_GETSIG        (STRIOC | 10)
+#define I_FIND          (STRIOC | 11)
+#define I_LINK          (STRIOC | 12)
+#define I_UNLINK        (STRIOC | 13)
+#define I_PEEK          (STRIOC | 14)
+#define I_FDINSERT      (STRIOC | 15)
+#define I_SENDFD        (STRIOC | 16)
+#define I_RECVFD        (STRIOC | 17)
+#define I_SWROPT        (STRIOC | 18)
+#define I_GWROPT        (STRIOC | 19)
+#define I_LIST          (STRIOC | 20)
+#define I_PLINK         (STRIOC | 21)
+#define I_PUNLINK       (STRIOC | 22)
+#define I_SETEV         (STRIOC | 23)
+#define I_GETEV         (STRIOC | 24)
+#define I_STREV         (STRIOC | 25)
+#define I_UNSTREV       (STRIOC | 26)
+#define I_FLUSHBAND     (STRIOC | 27)
+#define I_CKBAND        (STRIOC | 28)
+#define I_GETBAND       (STRIOC | 29)
+#define I_ATMARK        (STRIOC | 30)
+#define I_SETCLTIME     (STRIOC | 31)
+#define I_GETCLTIME     (STRIOC | 32)
+#define I_CANPUT        (STRIOC | 33)
+/*
+ * The following ioctls are specific to this STREAMS implementation.
+ */
+#define I_LIS_GET_MAXMSGMEM (STRIOC | 248)
+#define I_LIS_SET_MAXMSGMEM (STRIOC | 249)
+#define I_LIS_GET_MAXMEM (STRIOC | 250)
+#define I_LIS_SET_MAXMEM (STRIOC | 251)
+#define I_LIS_GETSTATS  (STRIOC | 252)	/* see include/sys/LiS/stats.h */
+#define I_LIS_PRNTSTRM  (STRIOC | 253)
+#define	I_LIS_PRNTMEM	(STRIOC | 254)
+#define I_LIS_SDBGMSK   (STRIOC | 255)
+
+/*  -------------------------------------------------------------------  */
+/*                                  Types                                */
+
+/*
+ * I_STR ioctl user data
+ */
+
+typedef
+struct strioctl {
+    int     ic_cmd;                 /* command */
+    int     ic_timout;              /* timeout value */
+    int     ic_len;                 /* length of data */
+    char    *ic_dp;                 /* pointer to data */
+} strioctl_t;
+
+/*  *******************************************************************  */
+
+/*
+ *  I_PEEK ioctl
+ */
+
+typedef
+struct strpeek {
+    struct strbuf   ctlbuf;
+    struct strbuf   databuf;
+    long            flags;
+} strpeek_t;
+/*  *******************************************************************  */
+
+/*
+ * Stream I_FDINSERT ioctl format
+ */
+
+typedef
+struct strfdinsert {
+    struct strbuf   ctlbuf;
+    struct strbuf   databuf;
+    long            flags;
+    int             fildes;
+    int             offset;
+} strfdinsert_t;
+
+/*
+ * Receive file descriptor structure
+ */
+
+typedef
+struct strrecvfd {
+    int fd;
+    uid_t uid;
+    gid_t gid;
+    char fill[8];
+} strrecvfd_t;
+
+/*  *******************************************************************  */
+
+/*
+ *  I_LIST ioctl.
+ */
+
+typedef
+struct str_mlist {
+    char l_name[FMNAMESZ+1];
+} str_mlist_t;
+
+typedef
+struct str_list {
+    int               sl_nmods;
+    struct str_mlist *sl_modlist;
+} str_list_t;
+
+/*  *******************************************************************  */
+
+/*
+ * For I_FLUSHBAND ioctl.  Describes the priority
+ * band for which the operation applies.
+ */
+
+typedef
+struct bandinfo {
+    unsigned char   bi_pri;
+    int             bi_flag;
+} bandinfo_t;
+
+/*  *******************************************************************  */
+/*                         Shared global variables                       */
+
+
+
+/*  *******************************************************************  */
+
+#endif /*!_STR_OPTS_H*/
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/LiS/include/sys/strport.h /usr/src/linux/drivers/streams/LiS/include/sys/strport.h
--- debug/drivers/streams/LiS/include/sys/strport.h	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/LiS/include/sys/strport.h	Wed Jan  1 13:04:41 1997
@@ -0,0 +1,77 @@
+/*                               -*- Mode: C -*- 
+ * <strport.h> --- Linux STREAMS portability declarations. 
+ * Author          : gram & nemo
+ * Created On      : Fri Mar 24 2:40:21 1995
+ * RCS Id          ; $Id: strport.h,v 1.4 1996/01/20 17:00:53 dave Exp $
+ * Last Modified By: David Grothe
+ * Restrictions    : SHAREd items can be read/writen by usr
+ *                 : EXPORTed items can only be read by usr
+ *                 : PRIVATEd items cannot be read nor writen
+ * Purpose         : All system dependent stuff goes here. The idea
+ *                 : is that different versions of this file can be
+ *                 : used to port STREAMS to other operating systems
+ *                 : as well as providing a user-space testbed environment.
+ *
+ *    Copyright (C) 1995  Graham Wheeler, Francisco J. Ballesteros
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    You can reach us by email to any of
+ *    gram@aztec.co.za, nemo@ordago.uc3m.es
+ */
+
+#ifndef _STRPORT_H
+#define _STRPORT_H
+
+/*  *******************************************************************  */
+/*                               Dependencies                            */
+
+#if	defined( __MSDOS__)
+#include <sys/LiS/dos-mdep.h>
+#elif defined(LINUX)
+#include <sys/LiS/linux-mdep.h>
+#elif defined(USER)
+#include <sys/LiS/user-mdep.h>
+#elif defined (QNX)
+#include <sys/LiS/qnx-mdep.h>
+#elif defined(SYS_SCO)
+#include <sys/LiS/sco-mdep.h>
+#elif defined(SYS_54)
+#include <sys/LiS/sys54-mdep.h>
+#elif defined(PORTABLE)
+#include <sys/LiS/port-mdep.h>
+#endif /* !__MSDOS__ */
+
+#ifndef OPENFAIL
+#define OPENFAIL	(-1)
+#endif
+#ifndef INFPSZ
+#define INFPSZ		(-1)
+#endif
+
+#ifdef __KERNEL__
+extern char	*lis_errmsg(int lvl) ;
+extern void	*lis_malloc(int nbytes, int class, char *file_name,int line_nr);
+extern void	 lis_free(void *ptr, char *file_name,int line_nr);
+#endif				/* __KERNEL__ */
+
+#endif /* _STRPORT_H */
+
+
+/*----------------------------------------------------------------------
+# Local Variables:      ***
+# change-log-default-name: "~/src/prj/streams/src/NOTES" ***
+# End: ***
+  ----------------------------------------------------------------------*/
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/Makefile /usr/src/linux/drivers/streams/Makefile
--- debug/drivers/streams/Makefile	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/Makefile	Mon Dec 16 16:36:41 1996
@@ -0,0 +1,22 @@
+#
+# Makefile for the kernel STREAMS device drivers.
+#
+#
+
+
+SUB_DIRS := LiS
+O_TARGET := sub_dirs
+L_TARGET := streams.a
+M_OBJS   :=
+L_OBJS   := 
+
+$(L_TARGET):	FORCE
+	make -C ./LiS
+	make -C ./pkg
+	cp ./LiS/streams.a .
+	ar r streams.a pkg/drivers.o
+
+fastdep:	FORCE
+	make -C ./LiS/head/linux deps
+
+FORCE:
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/pkg/Makefile /usr/src/linux/drivers/streams/pkg/Makefile
--- debug/drivers/streams/pkg/Makefile	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/pkg/Makefile	Mon Dec 16 16:36:41 1996
@@ -0,0 +1,10 @@
+
+all:	subdirs drivers.o
+
+subdirs:
+	set -e; for i in `ls -p | grep /`; do $(MAKE) -C $$i; done
+
+drivers.o:	FORCE
+	ld -r -o drivers.o `ls */*.o`
+
+FORCE:
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/pkg/proto/Makefile /usr/src/linux/drivers/streams/pkg/proto/Makefile
--- debug/drivers/streams/pkg/proto/Makefile	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/pkg/proto/Makefile	Mon Dec 16 16:36:41 1996
@@ -0,0 +1,10 @@
+#
+# Prototype makefile for package subdirectories
+#
+#
+# Include directory that contains the file "config.h"
+#
+LIS_INCL	= ../../LiS/head/linux
+
+Space.o:		Space.c
+	$(CC) -I$(LIS_INCL) -c	Space.c
diff -p --unified --exclude-from=exclude --new-file --recursive debug/drivers/streams/pkg/proto/Space.c /usr/src/linux/drivers/streams/pkg/proto/Space.c
--- debug/drivers/streams/pkg/proto/Space.c	Wed Dec 31 18:00:00 1969
+++ /usr/src/linux/drivers/streams/pkg/proto/Space.c	Mon Dec 16 16:36:41 1996
@@ -0,0 +1 @@
+char		proto_space_filler ;
diff -p --unified --exclude-from=exclude --new-file --recursive debug/fs/read_write.c /usr/src/linux/fs/read_write.c
--- debug/fs/read_write.c	Mon Dec  2 16:36:58 1996
+++ /usr/src/linux/fs/read_write.c	Mon Dec 16 16:36:35 1996
@@ -155,8 +155,10 @@ asmlinkage int sys_write(unsigned int fd
 	if (!file->f_op || !file->f_op->write)
 		goto out;
 	error = 0;
+#if 0				/* let driver have 0-length write */
 	if (!count)
 		goto out;
+#endif
 	error = locks_verify_area(FLOCK_VERIFY_WRITE,inode,file,file->f_pos,count);
 	if (error)
 		goto out;
diff -p --unified --exclude-from=exclude --new-file --recursive debug/fs/select.c /usr/src/linux/fs/select.c
--- debug/fs/select.c	Mon Dec  2 16:36:59 1996
+++ /usr/src/linux/fs/select.c	Tue Dec 24 10:00:42 1996
@@ -45,7 +45,7 @@
  * Linus noticed.  -- jrs
  */
 
-static void free_wait(select_table * p)
+void select_free_wait(select_table * p)
 {
 	struct select_table_entry * entry = p->entry + p->nr;
 
@@ -67,7 +67,7 @@ static void free_wait(select_table * p)
  * and we aren't going to sleep on the select_table.  -- jrs
  */
 
-static int check(int flag, select_table * wait, struct file * file)
+int select_check(int flag, select_table * wait, struct file * file)
 {
 	struct inode * inode;
 	struct file_operations *fops;
@@ -122,17 +122,17 @@ end_check:
 repeat:
 	current->state = TASK_INTERRUPTIBLE;
 	for (i = 0 ; i < n ; i++) {
-		if (FD_ISSET(i,in) && check(SEL_IN,wait,current->files->fd[i])) {
+		if (FD_ISSET(i,in) && select_check(SEL_IN,wait,current->files->fd[i])) {
 			FD_SET(i, res_in);
 			count++;
 			wait = NULL;
 		}
-		if (FD_ISSET(i,out) && check(SEL_OUT,wait,current->files->fd[i])) {
+		if (FD_ISSET(i,out) && select_check(SEL_OUT,wait,current->files->fd[i])) {
 			FD_SET(i, res_out);
 			count++;
 			wait = NULL;
 		}
-		if (FD_ISSET(i,ex) && check(SEL_EX,wait,current->files->fd[i])) {
+		if (FD_ISSET(i,ex) && select_check(SEL_EX,wait,current->files->fd[i])) {
 			FD_SET(i, res_ex);
 			count++;
 			wait = NULL;
@@ -143,7 +143,7 @@ repeat:
 		schedule();
 		goto repeat;
 	}
-	free_wait(&wait_table);
+	select_free_wait(&wait_table);
 	free_page((unsigned long) entry);
 	current->state = TASK_RUNNING;
 	return count;
diff -p --unified --exclude-from=exclude --new-file --recursive debug/include/asm/semaphore.h /usr/src/linux/include/asm/semaphore.h
--- debug/include/asm/semaphore.h	Mon Dec  2 16:37:16 1996
+++ /usr/src/linux/include/asm/semaphore.h	Mon Dec 23 10:45:02 1996
@@ -7,16 +7,27 @@
  * SMP- and interrupt-safe semaphores..
  *
  * (C) Copyright 1996 Linus Torvalds
+ *
+ * Modified 1996-12-23 by Dave Grothe <dave@gcom.com> to fix bugs in
+ *                     the original code and to make semaphore waits
+ *                     interruptible so that processes waiting on
+ *                     semaphores can be killed.
+ *
+ * If you would like to see an analysis of this implementation, please
+ * ftp to gcom.com and download the file
+ * /pub/linux/src/semaphore/semaphore-2.0.24.tar.gz.
+ *
  */
 
 struct semaphore {
 	int count;
-	int waiting;
+	int waking;
+	int lock ;			/* to make waking testing atomic */
 	struct wait_queue * wait;
 };
 
-#define MUTEX ((struct semaphore) { 1, 0, NULL })
-#define MUTEX_LOCKED ((struct semaphore) { 0, 0, NULL })
+#define MUTEX ((struct semaphore) { 1, 0, 0, NULL })
+#define MUTEX_LOCKED ((struct semaphore) { 0, 0, 0, NULL })
 
 asmlinkage void down_failed(void /* special register calling convention */);
 asmlinkage void up_wakeup(void /* special register calling convention */);
@@ -32,17 +43,62 @@ extern void __up(struct semaphore * sem)
 extern inline void down(struct semaphore * sem)
 {
 	__asm__ __volatile__(
-		"# atomic down operation\n"
-		"1:\n\t"
-		"movl $1b,%%eax\n\t"
+		"# atomic down operation\n\t"
+		"movl $1f,%%eax\n\t"
 #ifdef __SMP__
 		"lock ; "
 #endif
 		"decl 0(%0)\n\t"
-		"js " SYMBOL_NAME_STR(down_failed)
+		"js " SYMBOL_NAME_STR(down_failed) "\n"
+		"1:\n"
 		:/* no outputs */
 		:"c" (sem)
 		:"ax","dx","memory");
+}
+
+/*
+ * Primitives to spin on a lock.  Needed only for SMP version.
+ */
+extern inline void get_buzz_lock(int *lock_ptr)
+{
+#ifdef __SMP__
+        while (xchg(lock_ptr,1) != 0) ;
+#endif
+} /* get_buzz_lock */
+
+extern inline void give_buzz_lock(int *lock_ptr)
+{
+#ifdef __SMP__
+        *lock_ptr = 0 ;
+#endif
+} /* give_buzz_lock */
+
+asmlinkage int down_failed_interruptible(void);  /* params in registers */
+
+/*
+ * This version waits in interruptible state so that the waiting
+ * process can be killed.  The down_failed_interruptible routine
+ * returns negative for signalled and zero for semaphore acquired.
+ */
+extern inline int down_interruptible(struct semaphore * sem)
+{
+	int	ret ;
+
+        __asm__ __volatile__(
+                "# atomic interruptible down operation\n\t"
+                "movl $2f,%%eax\n\t"
+#ifdef __SMP__
+                "lock ; "
+#endif
+                "decl 0(%1)\n\t"
+                "js " SYMBOL_NAME_STR(down_failed_interruptible) "\n\t"
+                "xorl %%eax,%%eax\n"
+                "2:\n"
+                :"=a" (ret)
+                :"c" (sem)
+                :"ax","dx","memory");
+
+	return(ret) ;
 }
 
 /*
diff -p --unified --exclude-from=exclude --new-file --recursive debug/include/asm/unistd.h /usr/src/linux/include/asm/unistd.h
--- debug/include/asm/unistd.h	Mon Dec  2 16:37:15 1996
+++ /usr/src/linux/include/asm/unistd.h	Mon Dec 16 16:36:36 1996
@@ -169,6 +169,9 @@
 #define __NR_sched_rr_get_interval	161
 #define __NR_nanosleep		162
 #define __NR_mremap		163
+#define	__NR_putpmsg		164
+#define __NR_getpmsg		165
+#define	__NR_poll		166
 
 /* XXX - _foo needs to be __foo, while __NR_bar could be _NR_bar. */
 #define _syscall0(type,name) \
diff -p --unified --exclude-from=exclude --new-file --recursive debug/init/main.c /usr/src/linux/init/main.c
--- debug/init/main.c	Mon Dec  2 16:37:07 1996
+++ /usr/src/linux/init/main.c	Mon Dec 16 16:36:36 1996
@@ -67,6 +67,7 @@ extern long kmalloc_init(long,long);
 extern void sock_init(void);
 extern unsigned long pci_init(unsigned long, unsigned long);
 extern void sysctl_init(void);
+extern void streams_init(void);
 
 extern void no_scroll(char *str, int *ints);
 extern void swap_setup(char *str, int *ints);
@@ -828,6 +829,7 @@ asmlinkage void start_kernel(void)
 #endif
 	dquot_init();
 	arch_syms_export();
+	streams_init() ;
 	sti();
 	check_bugs();
 
diff -p --unified --exclude-from=exclude --new-file --recursive debug/kernel/printk.c /usr/src/linux/kernel/printk.c
--- debug/kernel/printk.c	Mon Dec  2 16:37:08 1996
+++ /usr/src/linux/kernel/printk.c	Mon Dec 16 16:36:36 1996
@@ -23,7 +23,7 @@
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 
-#define LOG_BUF_LEN	8192
+#define LOG_BUF_LEN	(64*1024)
 
 static char buf[1024];
 
diff -p --unified --exclude-from=exclude --new-file --recursive debug/kernel/sched.c /usr/src/linux/kernel/sched.c
--- debug/kernel/sched.c	Mon Dec  2 16:37:07 1996
+++ /usr/src/linux/kernel/sched.c	Mon Dec 23 15:51:55 1996
@@ -4,6 +4,8 @@
  *  Copyright (C) 1991, 1992  Linus Torvalds
  *
  *  1996-04-21	Modified by Ulrich Windl to make NTP work
+ *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and
+ *              make semaphores SMP safe
  */
 
 /*
@@ -482,32 +484,47 @@ bad:
 	printk("       *q = %p\n",*q);
 }
 
+
 /*
  * Semaphores are implemented using a two-way counter:
  * The "count" variable is decremented for each process
- * that tries to sleep, while the "waiting" variable is
- * incremented _while_ the process is sleeping on that
- * semaphore. 
+ * that tries to sleep, while the "waking" variable is
+ * incremented when the "up()" code goes to wake up waiting
+ * processes.
  *
  * Notably, the inline "up()" and "down()" functions can
  * efficiently test if they need to do any extra work (up
  * needs to do something only if count was negative before
  * the increment operation.
+ *
+ * This routine must execute atomically.
  */
-static inline void normalize_semaphore(struct semaphore *sem)
+static inline int waking_non_zero(struct semaphore *sem)
 {
-	atomic_add(xchg(&sem->waiting,0), &sem->count);
+	int	ret ;
+	long	flags ;
+
+	get_buzz_lock(&sem->lock) ;
+	save_flags(flags) ;
+	cli() ;
+
+	if ((ret = (sem->waking > 0)))
+		sem->waking-- ;
+
+	restore_flags(flags) ;
+	give_buzz_lock(&sem->lock) ;
+	return(ret) ;
 }
 
 /*
  * When __up() is called, the count was negative before
- * incrementing it, and we need to wake up somebody. In
- * most cases "waiting" will be positive, and the normalization
- * will allow things to continue. However, if somebody has
- * /just/ done a down(), it may be that count was negative
- * without waiting being positive (or in the generic case
- * "count is more negative than waiting is positive"), and
- * the waiter needs to check this itself (see __down).
+ * incrementing it, and we need to wake up somebody.
+ *
+ * This routine adds one to the count of processes that need to
+ * wake up and exit.  ALL waiting processes actually wake up but
+ * only the one that gets to the "waking" field first will gate
+ * through and acquire the semaphore.  The others will go back
+ * to sleep.
  *
  * Note that these functions are only called when there is
  * contention on the lock, and as such all this is the
@@ -517,54 +534,85 @@ static inline void normalize_semaphore(s
  */
 void __up(struct semaphore *sem)
 {
-	normalize_semaphore(sem);
+	atomic_inc(&sem->waking) ;
 	wake_up(&sem->wait);
 }
 
-void __down(struct semaphore * sem)
+/*
+ * Perform the "down" function.  Return zero for semaphore acquired,
+ * return negative for signalled out of the function.
+ *
+ * If called from __down, the return is ignored and the wait loop is
+ * not interruptible.  This means that a task waiting on a semaphore
+ * using "down()" cannot be killed until someone does an "up()" on
+ * the semaphore.
+ *
+ * If called from __down_interruptible, the return value gets checked
+ * upon return.  If the return value is negative then the task continues
+ * with the negative value in the return register (it can be tested by
+ * the caller).
+ *
+ * Either form may be used in conjunction with "up()".
+ *
+ */
+int __do_down(struct semaphore * sem, int task_state)
 {
 	struct task_struct *tsk = current;
 	struct wait_queue wait = { tsk, NULL };
+	int		  ret = 0 ;
 
-	/*
-	 * The order here is important. We add ourselves to the
-	 * wait queues and mark ourselves sleeping _first_. That
-	 * way, if a "up()" comes in here, we'll either get
-	 * woken up (up happens after the wait queues are set up)
-	 * OR we'll have "waiting > 0".
-	 */
-	tsk->state = TASK_UNINTERRUPTIBLE;
+	tsk->state = task_state;
 	add_wait_queue(&sem->wait, &wait);
-	atomic_inc(&sem->waiting);
 
 	/*
-	 * Ok, we're set up. The only race here is really that
-	 * an "up()" might have incremented count before we got
-	 * here, so we check "count+waiting". If that is larger
-	 * than zero, we shouldn't sleep, but re-try the lock.
+	 * Ok, we're set up.  sem->count is known to be less than zero
+	 * so we must wait.
+	 *
+	 * We can let go the lock for purposes of waiting.
+	 * We re-acquire it after awaking so as to protect
+	 * all semaphore operations.
+	 *
+	 * If "up()" is called before we call waking_non_zero() then
+	 * we will catch it right away.  If it is called later then
+	 * we will have to go through a wakeup cycle to catch it.
+	 *
+	 * Multiple waiters contend for the semaphore lock to see
+	 * who gets to gate through and who has to wait some more.
 	 */
-	if (sem->count+sem->waiting <= 0) {
-		/*
-		 * If "count+waiting" <= 0, we have to wait
-		 * for a up(), which will normalize the count.
-		 * Remember, at this point we have decremented
-		 * count, and incremented up, so if count is
-		 * zero or positive we need to return to re-try
-		 * the lock.  It _may_ be that both count and
-		 * waiting is zero and that it is still locked,
-		 * but we still want to re-try the lock in that
-		 * case to make count go negative again so that
-		 * the optimized "up()" wake_up sequence works.
-		 */
-		do {
-			schedule();
-			tsk->state = TASK_UNINTERRUPTIBLE;
-		} while (sem->count < 0);
+	for (;;)
+	{
+		if (waking_non_zero(sem))	/* are we waking up?  */
+		    break ;			/* yes, exit loop */
+
+		if (   task_state == TASK_INTERRUPTIBLE
+		    && (tsk->signal & ~tsk->blocked)	/* signalled */
+		   )
+		{
+		    ret = -EINTR ;		/* interrupted */
+		    atomic_inc(&sem->count) ;	/* give up on down operation */
+		    break ;
+		}
+
+		schedule();
+		tsk->state = task_state;
 	}
+
 	tsk->state = TASK_RUNNING;
 	remove_wait_queue(&sem->wait, &wait);
-	normalize_semaphore(sem);
+	return(ret) ;
+
+} /* __do_down */
+
+void __down(struct semaphore * sem)
+{
+	__do_down(sem,TASK_UNINTERRUPTIBLE) ; 
 }
+
+int __down_interruptible(struct semaphore * sem)
+{
+	return(__do_down(sem,TASK_INTERRUPTIBLE)) ; 
+}
+
 
 static inline void __sleep_on(struct wait_queue **p, int state)
 {
Binary files debug/scripts/lxdialog/lxdialog and /usr/src/linux/scripts/lxdialog/lxdialog differ
